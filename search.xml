<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Youth(青春)</title>
    <url>/2017/01/06/youth/</url>
    <content><![CDATA[<h2 id="青春"><a href="#青春" class="headerlink" title="青春"></a>青春</h2><p><strong>塞缪尔</strong></p>
<p>&emsp;&emsp;青春不是年华，而是心境；青春不是桃面、丹唇、柔膝，而是深沉的意志，恢宏的想象，炙热的恋情；青春是生命的深泉在涌流。<br>&emsp;&emsp;青春气贯长虹，勇锐盖过怯弱，进取压倒苟安。如此锐气，二十后生而有之，六旬男子则更多见。年岁有加，并非垂老，理想丢弃，方堕暮年。<br>&emsp;&emsp;岁月悠悠，衰微只及肌肤；热忱抛却，颓废必致灵魂。忧烦，惶恐，丧失自信，定使心灵扭曲，意气如灰。<br>&emsp;&emsp;无论年届花甲，拟或二八芳龄，心中皆有生命之欢乐，奇迹之诱惑，孩童般天真久盛不衰。人人心中皆有一台天线，只要你从天上人间接受美好、希望、欢乐、勇气和力量的信号，你就青春永驻，风华常存。<br>&emsp;&emsp;一旦天线下降，锐气便被冰雪覆盖，玩世不恭、自暴自弃油然而生，即使年方二十，实已垂垂老矣；然则只要树起天线，捕捉乐观信号，你就有望在八十高龄告别尘寰时仍觉年轻。</p>
<h2 id="YOUTH"><a href="#YOUTH" class="headerlink" title="YOUTH"></a>YOUTH</h2><p><strong>Samuel Ullman</strong> </p>
<p>&emsp;&emsp;Youth is not a time of life; it is a state of mind; it is not a matter of rosy cheeks, red lips and supple knees; it is a matter of the will, a quality of the imagination, a vigor of the emotions; it is the freshness of the deep springs of life.<br>&emsp;&emsp;Youth means a tempera-mental predominance of courage over timidity, of the appetite for adventure over the love of ease. This often exists in a man of 60 more than a boy of 20.　Nobody grows old merely by a number of years.　We grow old by deserting our ideals.<br>&emsp;&emsp;Years may wrinkle the skin, but to give up enthusiasm wrinkles the soul. Worry, fear, self-distrust bows the heart and turns the spring back to dust.<br>&emsp;&emsp;Whether 60 or 16, there is in every human being’s heart the lure of wonder, the unfailing childlike appetite of what’s next and the joy of the game of living.　In the center of your heart and my heart there is a wireless station: so long as it receives messages of beauty, hope, cheer, courage and power from men and from the Infinite, so long are you young.<br>&emsp;&emsp;When the aerials are down, and your spirit is covered with snows of cynicism and the ice of pessimism, then you are grown old, even at 20, but as long as your aerials are up, to catch waves of optimism, there is hope you may die young at 80.</p>
]]></content>
      <categories>
        <category>美文</category>
      </categories>
      <tags>
        <tag>青春</tag>
        <tag>激情</tag>
      </tags>
  </entry>
  <entry>
    <title>Markdown文件规范</title>
    <url>/2017/01/01/file_standard/</url>
    <content><![CDATA[<blockquote>
<p>Markdown是一种可以使用普通文本编辑器编辑的标记语言，通过简单的标记语法，可以自动生成具有一定样式的文本。markdown语法简单明了，学习容易，而且功能比纯文本要强，因此很多人用他来写博客，比如WordPress和大型的CMS如Joomla、Drupal等都支持markdown。除此之外markdown还用于github中README.md用于编写说明文档。</p>
</blockquote>
<h1 id="文件头格式规范"><a href="#文件头格式规范" class="headerlink" title="文件头格式规范"></a>文件头格式规范</h1><figure class="highlight stylus"><table><tr><td class="code"><pre><span class="line">---</span><br><span class="line">title: 诫子书</span><br><span class="line">date: <span class="number">2017</span>-<span class="number">04</span>-<span class="number">15</span> <span class="number">16</span>:<span class="number">20</span>:<span class="number">00</span></span><br><span class="line">updated: <span class="number">2017</span>-<span class="number">04</span>-<span class="number">15</span> <span class="number">16</span>:<span class="number">20</span>:<span class="number">00</span></span><br><span class="line">comments: false</span><br><span class="line">tags: [励志]</span><br><span class="line">categories: 文言</span><br><span class="line">permalink: to_son</span><br><span class="line">description: xx</span><br><span class="line">---</span><br></pre></td></tr></table></figure>
<h2 id="title"><a href="#title" class="headerlink" title="title"></a>title</h2><ul>
<li>文章标题</li>
</ul>
<h2 id="date"><a href="#date" class="headerlink" title="date"></a>date</h2><ul>
<li>文件编写日期</li>
</ul>
<h2 id="updated"><a href="#updated" class="headerlink" title="updated"></a>updated</h2><ul>
<li>更新时间</li>
</ul>
<h2 id="comments"><a href="#comments" class="headerlink" title="comments"></a>comments</h2><ul>
<li>是否开启评论true or false </li>
</ul>
<h2 id="tags"><a href="#tags" class="headerlink" title="tags"></a>tags</h2><ul>
<li>tomcat</li>
<li>nginx</li>
<li>java</li>
<li>markdown</li>
<li>js</li>
<li>ajax</li>
<li>html5</li>
<li>前端</li>
<li>青春</li>
<li>励志</li>
<li>读书</li>
<li>激情</li>
<li>…</li>
</ul>
<h2 id="categories"><a href="#categories" class="headerlink" title="categories"></a>categories</h2><ul>
<li>文言</li>
<li>美文</li>
<li>诗歌</li>
<li>文档</li>
<li>技术</li>
<li>摄影</li>
<li>小说</li>
<li>…<h2 id="description"><a href="#description" class="headerlink" title="description"></a>description</h2></li>
<li>文章概述，如果不为空，则预览的时候显示后标签后面的内容（作用和正文中的分隔符作用差不多）</li>
</ul>
<h1 id="正文格式规范"><a href="#正文格式规范" class="headerlink" title="正文格式规范"></a>正文格式规范</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt; &amp;emsp;&amp;emsp;其实非常喜欢这...</span><br><span class="line"></span><br><span class="line"># 标题一</span><br><span class="line">## 标题二</span><br><span class="line">### 标题三    </span><br><span class="line">XXXXXXXX</span><br><span class="line">## 标题二.1</span><br></pre></td></tr></table></figure>
<h2 id="说明"><a href="#说明" class="headerlink" title="说明"></a>说明</h2><ul>
<li>我们用引用符号<code>&gt;</code> 来规范文本格式，作为摘要部分，一般情况下，摘要要大于150个字，因为摘要的前150个字用于作为首页摘要简讯</li>
<li>斜体<code>*摘要：*</code>注明摘要部分开始，这不是必需，而是规范。</li>
</ul>
]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>markdown</tag>
      </tags>
  </entry>
  <entry>
    <title>Markdown效果预览</title>
    <url>/2017/01/01/markdown_use/</url>
    <content><![CDATA[<h1 id="概要"><a href="#概要" class="headerlink" title="概要"></a>概要</h1><p>&emsp;&emsp;小书匠是一款专为markdown写作而设计的编辑器。<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">//首行空两格</span><br><span class="line">&amp;emsp;&amp;emsp;</span><br></pre></td></tr></table></figure></p>
<h1 id="主要功能"><a href="#主要功能" class="headerlink" title="主要功能"></a>主要功能</h1><ol>
<li><p><strong>专为markdown写作设计的文档编辑器</strong>，让用户心无旁骛的进行创作。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">//加粗</span><br><span class="line">**专为markdown写作设计的文档编辑器**</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>多种编辑模式</strong>。单栏编辑，双栏编辑，三栏编辑，全屏写作，全屏阅读…想怎么切换，就怎么切换，就是这样随心所欲。</p>
</li>
<li><strong>多种编辑器实现</strong>。codemirror编辑器（提供vim,emacs按键，行专注等），ace编辑器（提供vim，emacs按键绑定，显示行号），轻量编辑器，CJK竖排编辑器</li>
<li><strong>多种主题选择</strong>。包括编辑器主题，预览区代码高亮主题，及预览区用户自定义css。<a id="more"></a></li>
<li><strong>丰富的语法支持</strong>。不仅提供了常用的commanmarkdown语法，还提供了许多有用的扩展语法，比如==Latex公式==，==表格==, ==目录==， ==脚注==, ==视频==, ==音频==, ==附件==, ==checklist==, ==流程图==等。更多语法可查看&lt;小书匠语法使用手册&gt;</li>
<li><strong>代码块文字格式语法</strong>。语法可查看&lt;小书匠语法使用手册&gt;</li>
<li><strong>第三方同步</strong>。==浏览器存储==, ==本地文件系统存储==, ==dropbox==, ==evernote==, ==印象笔记==,==有道笔记==, ==为知笔记==, ==github==等多种存储方案，保证了用户数据的安全，也让用户在存储方案上有了更多的选择。</li>
<li><strong>支持evernote，印象笔记</strong>。提供双向操作，可以将文章保存到evernote/印象笔记上，也可以从evernote/印象笔记上导入数据。同时提供标签，附件，图片，待办等相关处理。</li>
<li><strong>强大的文件管理功能</strong>。文件信息，标签，附件，音频，视频，图片管理。</li>
<li><strong>发布功能</strong>。 支持将文章发布到博客平台上。</li>
<li><strong>邮件发送功能</strong>。</li>
<li><strong>sourceMap对照功能</strong>。方便在源markdown文件和生成的html文件上进行比较，特别适合markdown初学者使用，了解每一个markdown解析产生的结果，也适用于文章后期的校对上。</li>
<li><strong>ppt</strong>。</li>
<li><strong>ppt跨屏演示</strong></li>
<li><strong>pdf预览</strong></li>
<li><strong>typewriter scrolling</strong></li>
<li><strong>autocomplete 和 snippets 功能</strong></li>
</ol>
<h1 id="离线版下载地址"><a href="#离线版下载地址" class="headerlink" title="离线版下载地址"></a>离线版下载地址</h1><p><a href="http://soft.xiaoshujiang.com" target="_blank" rel="noopener">http://soft.xiaoshujiang.com</a></p>
<h1 id="WEB版访问地址"><a href="#WEB版访问地址" class="headerlink" title="WEB版访问地址"></a>WEB版访问地址</h1><p><a href="http://markdown.xiaoshujiang.com" target="_blank" rel="noopener">http://markdown.xiaoshujiang.com</a></p>
<h1 id="元数据使用说明"><a href="#元数据使用说明" class="headerlink" title="元数据使用说明"></a>元数据使用说明</h1><p>语法开关元数据项，可以到设置面板里的语法扩展标签页下查看对应的元数据标识．在元数据里true时，表示当前文档强制打开该语法，false时表示强制关闭该语法．如果没有对应的元数据，则使用全局设置里的语法开关.</p>
<p><code>preview_previewType</code>元数据，可用的值为<code>normal</code>和<code>presentation</code>．用于文章在打开时，控制是否需要系统切换对应的预览界面．如果文章里没有该项元数据，或者元数据值不正确，则系统默认使用<code>normal</code>预览界面．该元数据仅控制文章打开时初始化的界面，用户依然可以通过按钮在不同预览界面间切换．</p>
<h1 id="浏览器存储"><a href="#浏览器存储" class="headerlink" title="浏览器存储"></a>浏览器存储</h1><p>系统对创建的文章，都会在浏览器存储上进行保存。包括像evernote/印象笔记/github/dropbox等导入的文章，也都会保存一份副本，并创建一个标识，表示跟哪些第三方存储关联。</p>
<h2 id="标题，标签"><a href="#标题，标签" class="headerlink" title="标题，标签"></a>标题，标签</h2><p>文章标题的处理规则：如果文章内存在元数据title，则系统自动使用元数据内的title做为标题。如果文章未使用到元数据功能，用户可以通过维护文章信息按钮，修改标题。标签tags的规则也跟标题一样。</p>
<h2 id="附件"><a href="#附件" class="headerlink" title="附件"></a>附件</h2><p>文章使用<code>./</code>做为附件的引用标识。对于<code>图片</code>，<code>音频</code>，<code>视频</code>，<code>附件</code>等链接的处理，系统只处理以<code>./</code>开头的链接，并转换成附件真实的地址进行显示。用户可以通过工具栏的<code>插入图片</code>，<code>插入音频</code>，<code>插入视频</code>，<code>插入附件</code>等按钮上传附件。</p>
<h1 id="evernote-印象笔记"><a href="#evernote-印象笔记" class="headerlink" title="evernote/印象笔记"></a>evernote/印象笔记</h1><p>小书匠编辑器提供对evernote/印象笔记的支持，下面的使用说明默认用户已经完成了evernote/印象笔记的绑定操作，并将当前的工作平台切换到evernote/印象笔记下。</p>
<h2 id="新建"><a href="#新建" class="headerlink" title="新建"></a>新建</h2><p>通过新建按钮后，创建的文章将自动关联到evernote/印象笔记上(<strong>注:这里仅仅是在文章上创建一个关联的标识，只有当用户保存后，才能在服务器上查看到新的笔记</strong>)</p>
<h2 id="打开"><a href="#打开" class="headerlink" title="打开"></a>打开</h2><p>点击笔记，系统将自动把笔记导入，并将当前文章切换为导入的笔记内容。导入的文章自动与evernote/印象笔记上的笔记关联，下次再点击该笔记时，将直接从浏览器存储上打开。用户可以通过切换存储平台<code>浏览器存储</code>，来删除该缓存的文件。导入的笔记如果本地没有缓存，系统将对服务器上的笔记进行判断，如果笔记是通过小书匠编辑器进行保存，并且文章在保存后没有被操作过，则系统自动使用保存时附带的markdown附件做为文章内容，重新导入。如果笔记已经被修改，或者笔记不是通过小书匠编辑器进行保存的，系统将自动将文章转换成markdown格式。</p>
<h2 id="保存"><a href="#保存" class="headerlink" title="保存"></a>保存</h2><p>对于新创建的文章，用户可以直接保存<code>ctrl+s</code>，系统将弹出一个选择笔记本的窗口，确认后，系统将保存当前文章到evernote/印象笔记上。（在弹出窗口上选择笔记本时，如果用户选择了笔记，系统将覆盖该笔记）</p>
<p>对于已经存在的文章，但还没有保存到evernote/印象笔记，用户可以通过另存为<code>ctrl+shift+s</code>将当前文章保存到evernote/印象笔记上。</p>
<p>不管是保存，还是另存为，保存成功后，系统都将自动对当前文章与evernote/印象笔记上的笔记进行关联。下次保存时<code>ctrl+s</code>系统将自动同步保存到evernote/印象笔记上。</p>
<h2 id="删除"><a href="#删除" class="headerlink" title="删除"></a>删除</h2><p>系统不提供删除操作，用户需要自己到evernote/印象笔记端删除，如果本地缓存了笔记，可以通过<code>浏览器存储</code>删除缓存。</p>
<h2 id="重命名"><a href="#重命名" class="headerlink" title="重命名"></a>重命名</h2><p>直接修改元数据title，如果文章内未使用元数据功能，可通过<code>浏览器存储</code>里的修改文章信息进行修改</p>
<h2 id="标签管理"><a href="#标签管理" class="headerlink" title="标签管理"></a>标签管理</h2><p>系统自动通过每篇文章的元数据<code>tags</code>提取为笔记的标签。</p>
<h2 id="附件管理"><a href="#附件管理" class="headerlink" title="附件管理"></a>附件管理</h2><p>打开时，系统自动将笔记上的附件导入到文章对应的附件管理器上。保存时，系统将根据<strong>文章内对附件的引用</strong>，将附件保存到服务器上。这里的引用包括<code>音频</code>，<code>视频</code>，<code>附件</code>，<code>图片</code>。如果文章内使用到了<code>流程图</code>，<code>序列图</code>，<code>公式</code>，<code>统计图</code>等，系统将会把这些内容转换成图片进行保存。由于evernote/印象笔记在部分终端不提供视频，音频的支持，查看保存的文章时，对应的音频，视频将以附件的形式存储。</p>
<h2 id="待办事项"><a href="#待办事项" class="headerlink" title="待办事项"></a>待办事项</h2><p>目前系统仅同步了待办事项。</p>
<h1 id="github-dropbox"><a href="#github-dropbox" class="headerlink" title="github/dropbox"></a>github/dropbox</h1><h2 id="新建-1"><a href="#新建-1" class="headerlink" title="新建"></a>新建</h2><p>参考<code>evernote/印象笔记</code>的<code>新建</code></p>
<h2 id="打开-1"><a href="#打开-1" class="headerlink" title="打开"></a>打开</h2><p>参考<code>evernote/印象笔记</code>的<code>打开</code><br>不同的是，github/dropbox只能打开扩展名为<code>html</code>，<code>markdown</code>，<code>md</code>，<code>mkd</code>以及无扩展名的文件。</p>
<h2 id="保存-1"><a href="#保存-1" class="headerlink" title="保存"></a>保存</h2><p>参考<code>evernote/印象笔记</code>的<code>保存</code><br>不同的是，github/dropbox保存时，仅保存了markdown文章本身，并不会将markdown转换成html进行保存，也不会处理附件相关的内容。<br>对于新文章的保存，github/dropbox存储需要用户指定文件名及存储的位置。</p>
<h2 id="删除-1"><a href="#删除-1" class="headerlink" title="删除"></a>删除</h2><p>系统不提供删除操作</p>
<h2 id="重命名-1"><a href="#重命名-1" class="headerlink" title="重命名"></a>重命名</h2><p>系统不提供重命名操作，只能通过另存为<code>ctrl+shift+s</code>，保存成新的文件。</p>
<h1 id="本地文件系统存储"><a href="#本地文件系统存储" class="headerlink" title="本地文件系统存储"></a>本地文件系统存储</h1><p>本地文件系统存储仅在离线版提供支持。</p>
<h2 id="新建-2"><a href="#新建-2" class="headerlink" title="新建"></a>新建</h2><p>参考<code>evernote/印象笔记</code>的<code>新建</code></p>
<h2 id="打开-2"><a href="#打开-2" class="headerlink" title="打开"></a>打开</h2><p>参考<code>github/dropbox</code>的<code>打开</code><br>不同的是，本地文件系统存储在打开文件时，将会自动关联文章内的附件引用标识<code>./</code>，自动抓取同级目录下对应的附件资源。</p>
<h2 id="保存-2"><a href="#保存-2" class="headerlink" title="保存"></a>保存</h2><p>参考<code>github/dropbox</code>的<code>保存</code><br>不同的是，本地文件系统存储在保存时，不仅保存了markdown文章，还会处理附件相关的内容，将附件保存到同级目录下，请确保附件的名称不要重复，防止数据被覆盖丢失。</p>
<h2 id="删除-2"><a href="#删除-2" class="headerlink" title="删除"></a>删除</h2><p>右击相应的文章可进行删除操作</p>
<h2 id="重命名-2"><a href="#重命名-2" class="headerlink" title="重命名"></a>重命名</h2><p>右击相应的文章可进行重命名操作</p>
<h1 id="发布"><a href="#发布" class="headerlink" title="发布"></a>发布</h1><p>小书匠编辑器<strong>离线版</strong>提供文章发布功能，用户可以将自己的文章发布到博客系统上。发布功能实现了博客的metaweblogAPI（newPost, editPost, newMediaObject）。使用该发布功能，需要博客系统提供对应的api接口，系统将转换成html的文章和图片自动提交到博客系统上。</p>
<p><strong>配置发布示例：</strong><br>博客链接地址：比如<code>http://www.cnblogs.com/[用户名]/</code><br>用户名：用户在该博客上的用户名<br>密码：用户在该博客上的密码</p>
<p><strong>测试通过的博客地址：</strong><br>博客园：<code>http://www.cnblogs.com/[用户名]/</code><br>开源中国：<code>http://my.oschina.net/[用户名]/blog</code></p>
<h1 id="邮件发送"><a href="#邮件发送" class="headerlink" title="邮件发送"></a>邮件发送</h1><p>小书匠编辑器提供邮件发送功能，系统将对当前文章转换成html格式后进行发送，并对图片，视频等文件以附件的形式进行发送。</p>
<h1 id="导出"><a href="#导出" class="headerlink" title="导出"></a>导出</h1><p>小书匠编辑器提供多种格式的导出文件功能。==html==,==markdown==,==html(inlinestyle)==,==word==,==zip==,==pdf==。</p>
<p><strong>zip导出</strong>： 该导出将导出文章的所有信息，包括markdown,html,markdown文章内引用的所有附件，公式，流程图等对应的图片文件，以及方便再次导入时需要的标识数据文件。</p>
<p><strong>pdf导出</strong>：目前pdf导出只能在chrome版浏览器上使用。</p>
<h1 id="导入"><a href="#导入" class="headerlink" title="导入"></a>导入</h1><p>小书匠编辑器提供markdown, html, zip三种导入功能，并且实现了文本文件直接拖动导入功能。</p>
<p><strong>zip导入</strong>：导入的zip文件必需是由小书匠编辑器导出的文件。</p>
<h1 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h1><p>web版实现了图片直接粘贴功能，用户不仅可以拖动图片上传，还可以直接复制粘贴图片。</p>
]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>markdown</tag>
        <tag>小书匠</tag>
      </tags>
  </entry>
  <entry>
    <title>以书为伴</title>
    <url>/2017/01/07/book/</url>
    <content><![CDATA[<p>&emsp;&emsp;通常看一个读些什么书就可知道他的为人，就像看他同什么人交往就可知道他的为人一样，因为有人以人为伴，也有人以书为伴。无论是书友还是朋友，我们都应该以最好的为伴。<br>&emsp;&emsp;好书就像是你最好的朋友。它始终不渝，过去如此，现在如此，将来也永远不变。它是最有耐心，最令人愉悦的伴侣。在我们穷愁潦倒，临危遭难时，它也不会抛弃我们，对我们总是一如既往地亲切。在我们年轻时，好书陶冶我们的性情，增长我们的知识；到我们年老时，它又给我们以慰藉和勉励。<a id="more"></a><br>&ensp;人们常常因为喜欢同一本书而结为知已，就像有时两个人因为敬慕同一个人而成为朋友一样。有句古谚说道：&quot;爱屋及屋。&quot;其实&quot;爱我及书&quot;这句话蕴涵更多的哲理。书是更为真诚而高尚的情谊纽带。人们可以通过共同喜爱的作家沟通思想，交流感情，彼此息息相通，并与自己喜欢的作家思想相通，情感相融。<br>&emsp;&emsp;好书常如最精美的宝器，珍藏着人生的思想的精华，因为人生的境界主要就在于其思想的境界。因此，最好的书是金玉良言和崇高思想的宝库，这些良言和思想若铭记于心并多加珍视，就会成为我们忠实的伴侣和永恒的慰藉。<br>&emsp;&emsp;书籍具有不朽的本质，是为人类努力创造的最为持久的成果。寺庙会倒坍，神像会朽烂，而书却经久长存。对于伟大的思想来说，时间是无关紧要的。多年前初次闪现于作者脑海的伟大思想今日依然清新如故。时间惟一的作用是淘汰不好的作品，因为只有真正的佳作才能经世长存。<br>&emsp;&emsp;书籍介绍我们与最优秀的人为伍，使我们置身于历代伟人巨匠之间，如闻其声，如观其行，如见其人，同他们情感交融，悲喜与共，感同身受。我们觉得自己仿佛在作者所描绘的舞台上和他们一起粉墨登场。<br>&emsp;&emsp;即使在人世间，伟大杰出的人物也永生不来。他们的精神被载入书册，传于四海。书是人生至今仍在聆听的智慧之声，永远充满着活力。</p>
]]></content>
      <categories>
        <category>美文</category>
      </categories>
      <tags>
        <tag>读书</tag>
      </tags>
  </entry>
  <entry>
    <title>爱的深沉</title>
    <url>/2017/01/15/oak/</url>
    <content><![CDATA[<h2 id="第一篇："><a href="#第一篇：" class="headerlink" title="第一篇："></a>第一篇：</h2><p>&emsp;&emsp;今天下午在言谈之中，忽然想起一首诗——舒婷的《致橡树》，致橡树 读后感。虽然这不是一首纯粹描述爱情的诗句，但是许多人却从中看出了爱情该有的态度。记得以前最喜欢其中的一句“我必须是你近旁的一株木棉，做为树的形象和你站在一起。”正是这种努力成长为树的信念，让我一度动容。自古以来，女性的形象似乎就被设定为了柔情似水、若柳扶风，长久以来受到压迫的旧社会的妇女也习惯了依附男人而生。拥有与失去似乎向来不是由女性向导，而只是被动地承受。<br>&emsp;&emsp;也许真的存在那种耐心极好的男人，那就是极品了，不是你我轻易能够遇到的。男人的确喜欢温柔的女人，但是温柔不是软弱无力、不是悲泣啼哭，温柔的女人也可以拥有一个坚毅的灵魂。泪水也许会换来男人一时的柔情，但总怕终有一天，这个曾经给予你温暖的手也会因为疲倦而无力地垂下。我想我是不愿当这棵菟丝花的，那样只能努力地依附大树而生，<a id="more"></a>贪婪地榨取大树的精力来得到生存，让大树的躯干无法得到伸展。我愿意用我的智慧来经营我的感情和生活，将自己塑造成一个温柔的女人和一个并肩的战友，拥有自己独特的和煦而坚定的微笑。当欣赏江山如画的时候，我愿意化为一汪春水，为这副风景增添一抹丽色;当遭遇风浪袭人的时候，我亦可以和你一起迎风而上 ，而不是委屈地退缩害怕、逃离。</p>
<h2 id="第二篇："><a href="#第二篇：" class="headerlink" title="第二篇："></a>第二篇：</h2><p>&emsp;&emsp;《致橡树》是我非常喜欢的一首诗，记得上大学的时候，我把这首诗写在了日记里，对诗中的每一句都曾仔细的斟酌和品味，后来常常把它默记在心里。随着年龄的增长，对诗中所体现的那种至高无上的爱情更是感受至深。近几天，我在看央视播放的电视剧《相思树》，当这首诗被男女主人公深情朗诵的时候，让我又一次产生了强烈的思想共鸣，也让我想起了很多的往事，往事不可追，但却永远珍藏在内心深处，还有往事中的他伴我在记忆的空间里飞呀飞……</p>
<h2 id="致橡树"><a href="#致橡树" class="headerlink" title="致橡树"></a>致橡树</h2><p><em>舒婷</em><br>我如果爱你——<br>绝不像攀援的凌霄花，<br>借你的高枝炫耀自己；<br>我如果爱你——<br>绝不学痴情的鸟儿，<br>为绿荫重复单调的歌曲；<br>也不止像泉源，<br>常年送来清凉的慰藉；<br>也不止像险峰，<br>增加你的高度，衬托你的威仪。<br>甚至日光，<br>甚至春雨。<br><img src="/pic/mumian.jpg" alt><br>不，这些都还不够！<br>我必须是你近旁的一株木棉，<br>作为树的形象和你站在一起。<br>根，紧握在地下；<br>叶，相触在云里。<br>每一阵风过，<br>我们都互相致意，<br>但没有人，<br>听懂我们的言语。<br>你有你的铜枝铁干，<br>像刀，像剑，<br>也像戟；<br>我有我红硕的花朵，<br>像沉重的叹息，<br>又像英勇的火炬。<br><img src="/pic/oak.jpg" alt><br>我们分担寒潮、风雷、霹雳；<br>我们共享雾霭、流岚、虹霓。<br>仿佛永远分离，<br>却又终身相依。<br>这才是伟大的爱情，<br>坚贞就在这里：<br>爱——<br>不仅爱你伟岸的身躯，<br>也爱你坚持的位置，<br>足下的土地。</p>
]]></content>
      <categories>
        <category>诗歌</category>
      </categories>
      <tags>
        <tag>爱情</tag>
      </tags>
  </entry>
  <entry>
    <title>阿里巴巴Java开发手册</title>
    <url>/2017/02/16/java_help_doc/</url>
    <content><![CDATA[<p>2017年开春之际，诚意献上重磅大礼：阿里巴巴Java开发手册，首次公开阿里官方Java代码规范标准。这套Java统一规范标准将有助于提高行业编码规范化水平，帮助行业人员提高开发质量和效率、大大降低代码维护成本。<br><img src="/pic/javashouce.jpeg" alt><br>你是否曾因Java代码规范版本纷杂而无所适从？</p>
<p>你是否想过代码规范能将系统故障率降低20%？</p>
<p>你是否曾因团队代码风格迥异而协同困难？</p>
<p>你是否正在review一些原本可以避免的故障？<a id="more"></a></p>
<p>你是否无法确定自己的代码足够健壮？ </p>
<h3 id="码出高效，码出质量！"><a href="#码出高效，码出质量！" class="headerlink" title="码出高效，码出质量！"></a>码出高效，码出质量！</h3><p>相比C++代码规范业界已经达成共识，Java代码规范业界比较混乱，我们期待这次发布的Java代码规范能够给业界带来一个标准，促使整体行业代码规范水平得到提高，最终能够帮助企业和开发者提升代码质量和降低代码故障率。</p>
<h3 id="阿里出品，质量保证！"><a href="#阿里出品，质量保证！" class="headerlink" title="阿里出品，质量保证！"></a>阿里出品，质量保证！</h3><p>阿里Java技术团队一手打造出Dubbo、JStorm、Fastjson等诸多流行开源框架，部分已成为Apache基金会孵化项目；</p>
<p>阿里在Java后端领域支撑起全球访问量最大的服务器集群；</p>
<p>Java代码构建的阿里双11业务系统订单处理能力达到17.5万笔/秒；</p>
<p>到目前已累计数亿行高并发、高稳定性的最佳Java代码实践；</p>
<p>……</p>
<p>此次首度公开的Java开发手册正是出自这样的团队，近万名阿里Java技术精英的经验总结，并经历了多次大规模一线实战检验及完善，铸就了这本高含金量的阿里Java开发手册。该手册以Java开发者为中心视角，划分为编程规约、异常日志规约、MYSQL规约、工程规约、安全规约五大块，再根据内容特征，细分成若干二级子目录。根据约束力强弱和故障敏感性，规约依次分为强制、推荐、参考三大类。此套规范不仅能让代码一目了然， 更有助于加强团队分工与合作、真正提升效率。 </p>
<h3 id="无规矩不成方圆-无规范不能协作"><a href="#无规矩不成方圆-无规范不能协作" class="headerlink" title="无规矩不成方圆 无规范不能协作"></a>无规矩不成方圆 无规范不能协作</h3><p>众所周知，制订交通法规表面上是要限制行车权，实际上是保障公众的人身安全。试想如果没有限速，没有红绿灯，没有规定靠右行驶，谁还敢上路行驶。 </p>
<p>同理，对软件来说，适当的规范和标准绝不是消灭代码内容的创造性、优雅性，而是限制过度个性化，以一种普遍认可的方式一起做事，降低故障率，提升协作效率。开发手册详细列举如何开发更加高效，更加容错，更加有协作性，力求知其然，更知其不然，结合正反例，提高代码质量。比如，异常日志处理时的各种不规范行为；集合转换的各种坑；创建线程池出现的等待队列OOM等。 </p>
<h3 id="阿里技术资深大咖联袂推荐"><a href="#阿里技术资深大咖联袂推荐" class="headerlink" title="阿里技术资深大咖联袂推荐"></a>阿里技术资深大咖联袂推荐</h3><p><strong>阿里高级研究员多隆</strong>：工程师对于代码，一定要“精益求精”，不论从性能，还是简洁优雅，都要具备“精益求精”的工匠精神，认真打磨自己的作品。 </p>
<p><strong>阿里研究员毕玄</strong>：一个优秀的工程师和一个普通工程师的区别，不是现在满天飞的架构图，他的功底就是体现在他写的每一行代码上。 </p>
<p><strong>阿里研究员玄难</strong>：代码是软件工程里面的产品设计、系统架构设计等工作的最后承载体，代码的质量决定了一切工作的成败。 </p>
<p><strong>阿里巴巴B2B事业群CTO李纯</strong>：好的软件产品离不开工程师高质量的代码及相互间顺畅的沟通与合作。简单，适用的代码规约背后所传递的是技术上的追求卓越、协同合作的精神，是每个技术团队不可缺失的重要利器。 </p>
<p><strong>阿里研究员、HipHop作者</strong>：赵海平（花名：福贝）：程序员是创造个性化作品的艺术家，但同时也是需要团队合作的工种。个性化应尽量表现在代码效率和算法方面，牺牲小我，成就大我。 </p>
<p><strong>拥抱规范，远离伤害！</strong></p>
<p>开发的同学们赶紧行动起来，遵守代码规范，你好，我好，大家好！ </p>
<p><strong>下载链接</strong>： <a href="http://pan.baidu.com/s/1o8bLJSm" target="_blank" rel="noopener">http://pan.baidu.com/s/1o8bLJSm</a> 密码: w9vw</p>
]]></content>
      <categories>
        <category>文档</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>阿里</tag>
      </tags>
  </entry>
  <entry>
    <title>誓刷红楼，品味经典</title>
    <url>/2017/05/11/dream_of_red/</url>
    <content><![CDATA[<blockquote>
<p>最近刷了一遍红楼，开始的目的是想借此了解一下清朝人们的生活状态，感受一下大观园富丽堂皇的生活，当然，也借此去找寻一下生活的意义；然而，迷上了红楼的文字艺术，辞藻的华丽，让人惊叹。即使是每一个丫头，佣人的名字艺术感也是非常强烈的，因是，在想，以后给某某取名，应多借鉴红楼。另外，关于清代人们的价值观，思想状态，也是有很多感受的，在这儿，就不细说，先列出优美的句子。</p>
</blockquote>
<h1 id="品读佳句"><a href="#品读佳句" class="headerlink" title="品读佳句"></a>品读佳句</h1><ul>
<li><p>你证我证，心证意证。是无有证，斯可云证。<br>无可云证，是立足境。无立足境，是方干净。</p>
<blockquote>
<p>彼此都想从对方得到感情的印证而频添烦恼；看来只有到了灭绝情谊，无需再验证时，方谈得上感情上的彻悟；到了万境归空，什么都无可验证之时，才是真正的立足之境。后一句是黛玉加的。证，在佛教用语中是领受、领悟道法之意，这里第一句中的证可以解释为印证。主要讲的是他们之间的感情纠葛。意谓彼此都想从对方心灵和表情达意中印证相互之间的感情；当然我们如果纯以禅理的角度讲可以理解为参禅的第一步。第二句“无有证”即无证，意谓无求于身外，不要证验，才谈得上参悟禅机，证得上层。第三句意谓到万境归空无证验可言时，才算找到了禅宗的境界。黛玉所续之句的意思是连禅境都放弃了才算是最彻底的。简单地说宝玉最终追求的是精神境界，而黛玉却连精神境界也一并不要了，从而达到空无纯明之境，“心体亦空，万缘俱寂”。这正好与禅宗三境界相对应。   </p>
</blockquote>
</li>
<li><p>菩提本无树，明镜亦非台。本来无一物，何处若尘埃。  </p>
</li>
<li><p>假作真时真亦假，无为有处有还无。</p>
<blockquote>
<p>《太虚幻境》   </p>
</blockquote>
</li>
<li><p>世事洞明皆学问，人情练达即文章。</p>
<blockquote>
<p>处事哲学乎？  </p>
</blockquote>
</li>
<li><p>莫失莫忘，仙寿恒昌。不离不弃，芳龄永继。</p>
<blockquote>
<p>“莫失莫忘,仙寿恒昌”是_贾宝玉佩带的通灵宝玉上的字,“不离不弃,芳龄永继“是薛宝钗佩带的金锁;简言“莫失莫忘，不离不弃”。  一块玉一块金，此之谓“金玉良缘”。</p>
</blockquote>
</li>
<li><p>满纸荒唐言，一把辛酸泪。都云作者痴，谁解其中味？</p>
</li>
<li><p>如花美眷，怎敌似水流年。</p>
</li>
<li><p>花谢花飞花满天，红消香断有谁怜？游丝软系飘春榭，落絮轻沾扑绣帘。<br>闺中女儿惜春暮，愁绪满怀无释处。手把花锄出绣帘，忍踏落花来复去？<br>柳丝榆荚自芳菲，不管桃飘与李飞。桃李明年能再发，明年闺中知有谁？<br>三月香巢已垒成，梁间燕子太无情！明年花发虽可啄，却不道人去梁空巢也倾。<br>一年三百六十日，风刀霜剑严相逼。明媚鲜妍能几时？一朝飘泊难寻觅。<br>花开易见落难寻，阶前闷杀葬花人。独倚花锄泪暗洒，洒上空枝见血痕。<br>杜鹃无语正黄昏，荷锄归去掩重门。青灯照壁人初睡，冷雨敲窗被未温。<br>怪奴底事倍伤神？半为怜春半恼春。怜春忽至恼忽去，至又无言去不闻。<br>昨宵庭外悲歌发，知是花魂与鸟魂。花魂鸟魂总难留，鸟自无言花自羞。<br>愿依胁下生双翼，随花飞到天尽头。天尽头,何处有香丘?<br>未若锦囊收艳骨，一杯净土掩风流。 质本洁来还洁去，强于污淖陷渠沟。<br>尔今死去依收葬，未卜依身何日丧? 依今葬花人笑痴，他年葬依知是谁?<br>试看春残花渐落，便是红颜老死时。 一朝春尽红颜老，花落人亡两不知!  </p>
<blockquote>
<p>这是黛玉的《葬花吟》。最有名的我想是开头的“花谢花飞飞满天，红消香断有谁怜”跟结尾处“一朝春尽红颜老，花落人亡两不知”两句；翻译几句：<br>花开易见落难寻，阶前闷杀葬花人。花开时容易被人发现，花落时却难寻觅，这真让我这个葬花人发愁啊!<br>侬今葬花人笑痴，他年葬侬知是谁? 我今天葬花别人笑我傻，等我死时却又不知谁来埋葬我呢?<br>试看春残花渐落，便是红颜老死时。看那春天将尽花也渐渐飘落，就是如花红颜衰老将死之时。<br>一朝春尽红颜老，花落人亡两不知！等到哪一天春天彻底逝去，美人迟暮之后，花也落尽，人也去世，两边再无相知。  </p>
</blockquote>
</li>
<li><p>寒塘渡鹤影，冷月葬花魂。</p>
<blockquote>
<p>对仗炒鸡工整。  </p>
</blockquote>
</li>
<li><p>春恨秋悲皆自惹，花容月貌为谁妍。  </p>
</li>
<li><p>滴不尽相思血泪抛红豆 ，开不完春柳春花满画楼，<br>睡不稳纱窗风雨黄昏后 ，忘不了新愁与旧愁。</p>
</li>
<li><p>厚地高天，堪叹古今情不尽；痴男怨女，可怜风月债难偿。</p>
</li>
<li><p>太高人愈妒，过洁世同嫌。</p>
</li>
<li><p>世人都晓神仙好，只有功名忘不了！<br>古今将相在何方，荒冢一堆草没了！<br>世人都晓神仙好，只有金银忘不了！<br>终朝只恨聚无多，及到多时眼闭了！<br>世人都晓神仙好，只有娇妻忘不了！<br>君生日日说恩情，君死又随人去了！<br>世人都晓神仙好，只有儿孙忘不了！<br>痴心父母古来多，孝顺子孙谁见了！</p>
<blockquote>
<p> 《好了歌》诗歌内容隐射小说情节，表达了作者对现实的愤懑和失望。  </p>
</blockquote>
</li>
<li><p>茜纱窗下，公子无缘。<br>黄土垅中，卿何薄命。</p>
</li>
<li><p>意淫二字，惟心会而不可口传，可神通而不可语达。</p>
</li>
<li><p>任凭弱水三千，我只取一瓢饮。</p>
<blockquote>
<p>弱水三千只取一瓢饮。</p>
</blockquote>
</li>
<li><p>纵然生得好皮囊，腹内原来草莽。</p>
<blockquote>
<p>这原始初中时候最喜欢的的一句，嘲讽下某某人</p>
</blockquote>
</li>
<li><p>半卷湘帘半掩门，碾冰为土玉为盆。<br>偷来梨蕊三分白，借得梅花一缕魂。<br>月窟仙人缝缟袂，秋闺怨女拭啼痕。<br>娇羞默默同谁诉，倦倚西风夜已昏。</p>
</li>
<li><p>女儿悲，青春已大守空闺。女儿愁，悔教夫婿觅封侯。<br>女儿喜，对镜晨妆颜色美。女儿乐，秋千架上春衫薄。</p>
</li>
<li><p>茶靡花开，末路之美，开到荼蘼花事了，尘烟过，知多少? </p>
<blockquote>
<p>悲伤的茶靡花–开到荼蘼花事了。  </p>
</blockquote>
</li>
<li><p>偶因一回顾，便为心上人。  </p>
</li>
<li><p>瘦影自临春水照，卿须怜我我怜卿。</p>
<blockquote>
<p>孤芳自赏，憔悴的黛玉…</p>
</blockquote>
</li>
</ul>
<h1 id="人物别号"><a href="#人物别号" class="headerlink" title="人物别号"></a>人物别号</h1><ul>
<li><p>林黛玉——潇湘妃子</p>
</li>
<li><p>薛宝钗——蘅芜君</p>
</li>
<li><p>李 纨——稻香老农</p>
</li>
<li><p>史湘云——枕霞旧友</p>
</li>
<li><p>贾宝玉——怡红公子</p>
</li>
<li><p>贾探春——蕉下客</p>
</li>
<li><p>贾迎春——菱洲</p>
</li>
<li><p>贾惜春——藕榭</p>
</li>
</ul>
<h1 id="人物名称"><a href="#人物名称" class="headerlink" title="人物名称"></a>人物名称</h1><ul>
<li><p>十二金钗：林黛玉、薛宝钗、贾元春、贾迎春、贾探春、贾惜春、李纨、妙玉、史湘云、王熙凤、贾巧姐、秦可卿。 　　</p>
</li>
<li><p>十二丫环：晴雯、麝月、袭人、鸳鸯、雪雁、紫鹃、碧痕、平儿、香菱、金钏、司棋、抱琴。  </p>
</li>
<li><p>十二家人：赖大、焦大、王善保、周瑞、林之孝、乌进孝、包勇、吴贵、吴新登、邓好时、王柱儿、余信。   </p>
</li>
<li><p>十二儿：庆儿、昭儿、兴儿、隆儿、坠儿、喜儿、寿儿、丰儿、住儿、小舍儿、李十儿、玉柱儿。  </p>
</li>
<li><p>十二贾氏：贾敬、贾赦、贾政、贾宝玉、贾琏、贾珍、贾环、贾蓉、贾兰、贾芸、贾蔷、贾芹。   </p>
</li>
<li><p>十二官：琪官、芳官、藕官、蕊官、药官、玉官、宝官、龄官、茄官、艾官、豆官、葵官。   </p>
</li>
<li><p>七尼：妙玉、智能、智通、智善、圆信、大色空、净虚。  </p>
</li>
<li><p>七彩：彩屏、彩儿、彩凤、彩霞、彩鸾、彩明、彩云。  </p>
</li>
<li><p>四春：贾元春、贾迎春、贾探春、贾惜春。  </p>
</li>
<li><p>四宝：贾宝玉、甄宝玉、薛宝钗、薛宝琴。  </p>
</li>
<li><p>四薛：薛蟠、薛蝌、薛宝钗、薛宝琴。 　 </p>
</li>
<li><p>四王：王夫人、王熙凤、王子腾、王仁。 　</p>
</li>
<li><p>四尤：尤老娘、尤氏、尤二姐、尤三姐。   </p>
</li>
<li><p>四草辈：贾蓉、贾兰、贾芸、贾芹。  </p>
</li>
<li><p>四玉辈：贾珍、贾琏、贾环、贾瑞。 　</p>
</li>
<li><p>四文辈：贾敬、贾赦、贾政、贾敏 。　</p>
</li>
<li><p>四代辈：贾代儒、贾代化、贾代修、贾代善。 　</p>
</li>
<li><p>四烈婢：晴雯、金钏、鸳鸯、司棋。 　</p>
</li>
<li><p>四清客：詹光、单聘仁、程日兴、王作梅。 　</p>
</li>
<li><p>四无辜：石呆子、张华、冯渊、张金哥。 　</p>
</li>
<li><p>四小厮：茗烟、扫红、锄药、伴鹤。 　 </p>
</li>
<li><p>四小：小鹊、小红、小蝉、小舍儿。 　　</p>
</li>
<li><p>四婆子：刘姥姥、马道婆、宋嬷嬷、张妈妈。 　 </p>
</li>
<li><p>四情友：秦锺、蒋玉菡、柳湘莲、东平王。 </p>
</li>
<li><p>四壮客：乌进孝、冷子兴、山子野、方椿。  </p>
</li>
<li><p>四宦官：载权、夏秉忠、周太监、裘世安。  </p>
</li>
<li><p>文房四宝：抱琴、司棋、侍画、入画。  </p>
</li>
<li><p>四珍宝：珍珠、琥珀、玻璃、翡翠。  </p>
</li>
<li><p>一主三仆：史湘云–翠缕、笑儿、篆儿。贾探春–侍画、翠墨、小蝉。贾宝玉–茗烟、袭人、晴雯。林黛玉–紫鹃、雪雁、春纤。贾惜春–入画、彩屏、彩儿。贾迎春–彩凤、彩云、彩霞。</p>
</li>
</ul>
]]></content>
      <categories>
        <category>小说</category>
      </categories>
      <tags>
        <tag>读书</tag>
        <tag>佳句</tag>
        <tag>红楼梦</tag>
      </tags>
  </entry>
  <entry>
    <title>经典诫子书</title>
    <url>/2017/04/15/to_son/</url>
    <content><![CDATA[<blockquote>
<p>其实非常喜欢这篇文章，推荐给亲⊙o记得第一次读到这篇文章的时候在初中，当时很励志，以此鞭策自己，如今看来任然可以作为终身的信条O(∩_∩)O/年轻一定要奋斗，严格要求自己，宁静致远，这样不会再年老的时候发出“悲守穷庐，将复何及”的感叹！而且要树立终身学习的观念，寻找适合自己的学习方法，每个人的学习能力存在差异可能不容易改变，但是时间的累积会让你获得意想不到的收获 ~ 朋友们加油吧。</p>
</blockquote>
<h1 id="原文"><a href="#原文" class="headerlink" title="原文"></a>原文</h1><p><em>诸葛亮</em><br>夫君子之行，静以修身，俭以养德。<br>非淡泊无以明志，非宁静无以致远。<br>夫学须静也，才须学也。<br>非学无以广才，非志无以成学。<br>淫慢则不能励精，险躁则不能治性。<br>年与时驰，意与日去，遂成枯落，多不接世。<br>悲守穷庐，将复何及？</p>
<blockquote>
<p>&emsp;&emsp;最喜欢“宁静致远”。</p>
</blockquote>
<h1 id="创作背景"><a href="#创作背景" class="headerlink" title="创作背景"></a>创作背景</h1><p>&emsp;&emsp;这篇文章当作于蜀汉建兴十二年（元234年），是诸葛亮晚年写给他八岁的儿子诸葛瞻的一封家书。诸葛亮一生为国，鞠躬尽瘁，死而后已。他为了蜀汉国家事业日夜操劳，顾不上亲自教育儿子，于是写下这篇书信告诫诸葛瞻。</p>
<h1 id="作品鉴赏"><a href="#作品鉴赏" class="headerlink" title="作品鉴赏"></a>作品鉴赏</h1><p>&emsp;&emsp;古代家训，大都浓缩了作者毕生的生活经历、人生体验和学术思想等方面内容，不仅他的子孙从中获益颇多，就是今人读来也大有可借鉴之处。三国时蜀汉丞相诸葛亮被后人誉为“智慧之化身”，他的《诫子书》也可谓是一篇充满智慧之语的家训，是古代家训中的名作。文章阐述修身养性、治学做人的深刻道理，读来发人深省。它也可以看作是诸葛亮对其一生的总结，后来更成为修身立志的名篇。<br>&emsp;&emsp;《诫子书》的主旨是劝勉儿子勤学立志，修身养性要从淡泊宁静中下功夫，最忌怠惰险躁。文章概括了做人治学的经验，着重围绕一个“静”字加以论述，同时把失败归结为一个“躁”字，对比鲜明。<br>&emsp;&emsp;在《诫子书》中，诸葛亮教育儿子，要“澹泊”自守，“宁静”自处，鼓励儿子勤学励志，从澹泊和宁静的自身修养上狠下功夫。他说，“夫学须静也，才须学也，非学无以广才，非志无以成学”。意思是说，不安定清静就不能为实现远大理想而长期刻苦学习，要学得真知必须使身心在宁静中研究探讨，人们的才能是从不断的学习中积累起来的；不下苦功学习就不能增长与发扬自己的才干；没有坚定不移的意志就不能使学业成功。《诸葛亮教育儿子切忌心浮气躁，举止荒唐。在书信的后半部分，他则以慈父的口吻谆谆教导儿子：少壮不努力，老大徒伤悲。这话看起来不过是老生常谈罢了，但它是慈父教诲儿子的，字字句句是心中真话，是他人生的总结，因而格外令人珍惜。<br>&emsp;&emsp;这篇《诫子书》，不但讲明修身养性的途径和方法，也指明了立志与学习的关系；不但讲明了宁静淡泊的重要，也指明了放纵怠慢、偏激急躁的危害。诸葛亮不但在大的原则方面对其子严格要求，循循善诱，甚至在一些具体事情上也体现出对子女的细微关怀。在这篇《诫子书》中，有宁静的力量：“静以修身”，“非宁静无以致远”；有节俭的力量：“俭以养德”；有超脱的力量：“非澹泊无以明志”；有好学的力量：“夫学须静也，才须学也”；有励志的力量：“非学无以广才，非志无以成学”；有速度的力量：“淫慢则不能励精”；有性格的力量：“险躁则不能治性”；有惜时的力量：“年与时驰，意与岁去”；有想象的力量：“遂成枯落，多不接世，悲守穷庐，将复何及”；有简约的力量。这篇文章短短几十字，传递出的讯息，比起长篇大论，诫子效果好得多。<br>&emsp;&emsp;文章短小精悍，言简意赅，文字清新雅致，不事雕琢，说理平易近人，这些都是这篇文章的特出之处。</p>
]]></content>
      <categories>
        <category>文言</category>
      </categories>
      <tags>
        <tag>励志</tag>
      </tags>
  </entry>
  <entry>
    <title>遥远的救世主</title>
    <url>/2017/05/12/distant_savior/</url>
    <content><![CDATA[<blockquote>
<p>不知道是谁推荐过《遥远的救世主》，也不知怎么就把它和《天道》相连，以为是两本书，总之就是记住了。后来知道《天道》是电视剧，众人捧的热烈，改编自这本书。很偶然的机会，图书馆里看到了它，就借来一观。五十万字，不是随意打发下午时光就可看完的。小说里佛学的光辉、哲学的深奥与“禅”的玄机不谈，“文化属性”也不说，这不是我如今的知识层面所能评判的，仅能在思想上被“灌输”而已，然后再顺便感慨几句晦涩难懂，大呼看不明白，作者有才。废话不多说，列些句子，慢慢品味。</p>
</blockquote>
<h1 id="品读佳句"><a href="#品读佳句" class="headerlink" title="品读佳句"></a>品读佳句</h1><ul>
<li><p>一颗阴暗的心，永远托不起一张灿烂的脸。  </p>
</li>
<li><p>人从根本上是面对两个问题，一，生存，得活下来；二，是要回答生命价值的问题，让心有个安处。</p>
</li>
<li><p>有招有术的感情，招术里是什么不去论它了，没招没术的感情，剩下的就该是造物主给的那颗心了。  </p>
<blockquote>
<p>命题错误，答既有错；只要是需要证明的感情就有错误。</p>
</blockquote>
</li>
<li><p>当人一旦从危险里跳出来，他就不再去关注这个事物的危险了，他的目光就会全部落在这个事物的利益上。  </p>
</li>
<li><p>神即道，道法自然，如来。  </p>
<blockquote>
<p>神就是道，道就是规律，规律如来，容不得你思议，按规律办事的人就是神。</p>
</blockquote>
</li>
<li><p>女人是形式逻辑的典范，是辩证逻辑的障碍，我无意摧残女人，也不想被女人摧残。  </p>
</li>
<li><p>女人和男人的对话方式只有两个，要么躺着，要么站着。</p>
</li>
<li><p>进了窄门，神立刻就会告诉你：我是不存在的，神就是你自己。但是，证到如此也并不究竟，神是什么?神即道，道法自然，如来。  </p>
</li>
<li><p>文明对于不能以人字来界定的人无能为力。  </p>
</li>
<li><p>所谓的神话竟是这么简单。原来能做到实事求是就是神话！原来能说老实话，能办老实事的人就是神！  </p>
</li>
<li><p>衡量一种文化属性不是看它积淀的时间长短，而是看它与客观规律的距离远近。  </p>
</li>
<li><p>一、天上掉馅饼的神话，实惠、破格，是为市井文化。<br>二、最不道德的道德，明辨是非，是为哲人文化。<br>三、不打碎点东西，不足以缘起主题，大智大爱，是为英雄文化。  </p>
</li>
<li><p>无论做什么，市场都不是一块无限大的蛋糕。神话的实质就是强力作用的杀富济贫，这就可能产生两个问题，一是杀富是不是破坏性开采市场资源?二是让井底的人扒着井沿看了一眼再掉下去是不是让他患上精神绝症?  </p>
</li>
<li><p>这就是圆融世故，不显山不露水，各得其所。可品性这东西，今天缺个角、明天裂道缝，也就离塌陷不远了。  </p>
</li>
<li><p>生存法则很简单，就是忍人所不忍，能人所不能。忍是一条线，能是一条线，两者的间距就是生存机会。  </p>
</li>
<li><p>这东西有点像禅，知之为不知，不知更非知。  </p>
</li>
<li><p>强势文化就是遵循事物规律的文化，弱势文化就是依赖强者的道德期望破格获取的文化，也是期望救主的文化。强势文化在武学上被称为“秘笈”，而弱势文化由于易学、易懂、易用，成了流行品种。  </p>
</li>
<li><p>比如说文化产业，文学、影视是扒拉灵魂的艺术，如果文学、影视的创作能破解更高思维空间的文化密码，那么它的功效就是启迪人的觉悟、震撼人的灵魂，这就是众生所需，就是功德、市场、名利，精神拯救的暴利与毒品麻醉的暴利完全等值，而且不必像贩毒那样耍花招，没有心理成本和法律风险。  </p>
</li>
<li><p>股票的暴利并不产生于生产经营，而是产生于股票市场本身的投机性。它的运作动力是：把你口袋里的钱装到我口袋里去。它的规则是：把大多数羊的肉填到极少数狼的嘴里。私募基金是从狼嘴里夹肉，这就要求你得比狼更黑更狠，但是心理成本也更高，而且又多了一重股市之外的风险。所以，得适可而止。  </p>
</li>
<li><p>《圣经》的教义如果不能经受逻辑学的检验，可能在实践上就会存在障碍。如果经受了逻辑学的检验，那表明神的思维即是人的思维，就会否定神性。换一种说法，神性如果附加上人性的期望值，神性就打了折扣。然而神性如果失去了人性的期望值，那么人还需要神吗?  </p>
</li>
<li><p>基督教相信，太高的道德平台需要太高的教育、太深的觉悟和太复杂的炼造过程，是一道靠人性本能很难迈进的窄门。于是，基督教便有了神与人的约，有了神的关于天国与火湖、永生与死亡的应许，让凡夫俗子因为恐惧死亡和向往天堂而守约。这是智与善的魔术，非读懂的人不能理解。但《圣经》告诉世人了，要进窄门。  </p>
</li>
<li><p>说魔说鬼都是个表述，本质是思维逻辑和价值观与普通人不同，所谓的地域之门也无非是价值观冲突所带来的精神痛苦。如果你是觉者，我尊敬你，向你学习，如果你是魔鬼，我鉴别你，弃你而去。  </p>
</li>
<li><p>即便是呼之欲出，你也讲不出，因为一说就错，这就像法律不能单纯以推理定罪，得允许在可能与事实之间存续一个演化的过程。  </p>
</li>
<li><p>红颜知己自古有之，这还得看男人是不是一杯好酒，自古又有几个男人能把自己酿到淡而又淡的名贵?这不适为之而可为的事情。  </p>
</li>
<li><p>我把一个女人所能及的事都做了，包括我的廉耻和可能被你认为的淫荡，以后我就不遗憾了。  </p>
</li>
<li><p>你是一块玉，但我不是匠人，你要求的，是一种雄性文化的魂，我不能因为你没说出来而装不知道。接受你，就接受了一种高度，我没有这个自信。  </p>
</li>
<li><p>你让我用灵魂而不是文字去理解一个女人的圣洁。你这样做，是基于一种对应的人格，谢谢你能这样评价我。  </p>
</li>
<li><p>你是那么的执著于孤独吗?我就眼看着让你走了，可心在问我，那我又该怎么去疼你?  </p>
</li>
<li><p>所有的幸福、快乐、委屈，在这一刻都找到了接纳的地方。  </p>
</li>
<li><p>顿悟天堂地狱的分别无二，证到极乐了。  </p>
</li>
<li><p>视社会依次有三个层面：技术、制度和文化。小到一个人，大到一个国家一个民族，任何一种命运归根到底都是那种文化属性的产物。强势文化造就强者，弱势文化造就弱者，这是规律，也可以理解为天道，不以人的意志为转移。  </p>
</li>
<li><p>俄罗斯是一个伟大的名族，历史上没有什么人能够战胜他们，但是再世界两大阵营五十多年意识形态的对抗里，他们却输在了他们还没有完全读懂的文化里，而美国，尊重客观规律的文化，赢得了靠飞机大炮赢得不了的胜利，以至于连联合国都成了一个失宠的王妃；在中国，有人动不动就拿民主指责共产党，但是他们根本就不知道，中国的政治文化也是传统文化的牺牲品，把沉积了几千年文化属性问题都记在一个只有几十年的政党的账上，这不公平，也不是真是的国情。</p>
</li>
<li><p>丁对小丹说：不管是文化艺术还是生存艺术，有道无术，术尚可求也，有术无道，止于术；你的前途在于众生，众生没有真理真相，只有好恶，所以你就有了价值。觉悟天道，是名开天眼，你缺的就是这双眼睛，你需要的也是这双天眼，是一双剥离了政治，文化，传统，道德，宗教之分别的眼睛。然后再如实关照政治，文化，传统把文化道德颠倒了的真理真相再颠倒回来，不管随便你怎么写怎么拍，都是新意，深度，这就是钱，就是名利，成就，价值。</p>
<blockquote>
<p>丁为晓丹创造了一个神话，揭示了文化属性决定命运，使晓丹觉悟。  </p>
</blockquote>
</li>
</ul>
<h1 id="资源共享"><a href="#资源共享" class="headerlink" title="资源共享"></a>资源共享</h1><p><strong>小说下载链接：</strong> <a href="http://pan.baidu.com/s/1cmyvU2" target="_blank" rel="noopener">http://pan.baidu.com/s/1cmyvU2</a> 密码：9620  </p>
<p><strong>电视剧《天道》：</strong> <a href="http://pan.baidu.com/s/1sloBCXf" target="_blank" rel="noopener">http://pan.baidu.com/s/1sloBCXf</a> 密码：s0az</p>
]]></content>
      <categories>
        <category>小说</category>
      </categories>
      <tags>
        <tag>读书</tag>
        <tag>豆豆</tag>
        <tag>遥远的救世主</tag>
        <tag>佳句</tag>
      </tags>
  </entry>
  <entry>
    <title>重温滕王阁</title>
    <url>/2017/05/11/to_son/</url>
    <content><![CDATA[<blockquote>
<p>读《滕王阁序》，我会在开始时同情王勃的遭遇；然而，读至“老当益壮，宁移白首之心，穷且益坚，不坠青云之志”时，我便渐渐由同情变为了赞赏与佩服。这篇骈文是才华横溢的才子王勃仕途终结之作，面对如此人生困境，他也能即兴诵出这等有气势的句子，实在让人可叹，可敬。今天，记录于此，留待后日继续欣赏。</p>
</blockquote>
<h1 id="原文"><a href="#原文" class="headerlink" title="原文"></a>原文</h1><p>&emsp;&emsp;<em>王勃</em><br>&emsp;&emsp;豫章故郡，洪都新府。星分翼轸(zhěn)，地接衡庐。襟三江而带五湖，控蛮荆而引瓯（ōu）越。物华天宝，龙光射牛斗之墟；人杰地灵，徐孺下陈蕃之榻。雄州雾列，俊采星驰，台隍(huáng)枕夷夏之交，宾主尽东南之美。都督阎公之雅望，棨(qǐ )戟(jǐ)遥临；宇文新州之懿(yì)范，襜(chān )帷(wéi)暂驻。十旬休假，胜友如云；千里逢迎，高朋满座。腾蛟起凤，孟学士之词宗；紫电青霜，王将军之武库。家君作宰，路出名区；童子何知，躬逢胜饯。<br>&emsp;&emsp;时维九月，序属三秋。潦（lǎo）水尽而寒潭清，烟光凝（ning)而暮山紫。俨(yǎn)骖騑(cān fēi)于上路，访风景于崇阿。临帝子之长洲，得仙人之旧馆。层峦耸翠，上出重霄；飞阁流丹，下临无地。鹤汀（tīng）凫(fú )渚，穷岛屿之萦(yíng)回；桂殿兰宫，即冈峦之体势。<br>&emsp;&emsp;披绣闼（tà），俯雕甍(méng )。山原旷其盈视，川泽纡(yū)其骇瞩。闾(lǘ)阎(yán) 扑地，钟鸣鼎食之家；舸（gě)舰弥津，青雀黄龙之轴（zhú)。云销雨霁(jì)，彩彻区明（云衢）。落霞与孤鹜齐飞，秋水共长天一色。渔舟唱晚，响穷彭蠡（lǐ ）之滨；雁阵惊寒，声断衡阳之浦。<br>&emsp;&emsp;遥襟俯畅，逸兴遄(chuán)飞。爽籁发而清风生，纤歌凝而白云遏(è)。睢(suī)园绿竹，气凌彭泽之樽(zūn)；邺(yè)水朱华，光照临川之笔。四美具，二难并。穷睇眄(dì miǎn)于中天，极娱游于暇日。天高地迥，觉宇宙之无穷；兴尽悲来，识盈虚之有数。望长安于日下，目吴会（kuài）于云间。地势极而南溟深，天柱高而北辰远。关山难越，谁悲失路之人；萍水相逢，尽是他乡之客。怀帝阍(hūn)而不见，奉宣室以何年？<br>&emsp;&emsp;嗟乎！时运不齐，命途多舛(chuǎn)；冯唐易老，李广难封。屈贾谊（yì）于长沙，非无圣主；窜梁(liang)鸿于海曲，岂乏明时？所赖君子见机，达人知命。老当益壮，宁移白首之心；穷且益坚，不坠青云之志。酌贪泉而觉爽，处涸辙（hézhé）而尤欢。北海虽赊（shē），扶摇可接；东隅已逝，桑榆非晚。孟尝高洁，空余报国之情；阮籍猖狂，岂效穷途之哭？<br>&emsp;&emsp;勃，三尺微命，一介书生，无路请缨，等终军之弱冠（guàn）；有怀投笔，慕宗悫（què）之长风。舍簪（zān）笏（hù）于百龄，奉晨昏于万里。非谢家之宝树，接孟氏之芳邻。他日趋庭，叨(tāo)陪鲤对；今晨捧袂(mèi)，喜托龙门。杨意不逢，抚凌云而自惜；钟期既遇，奏流水以何惭？<br>&emsp;&emsp;呜呼！胜地不常，盛筵(yán)难再；兰亭已矣，梓(zi)泽(ze)丘墟。临别赠言，幸承恩于伟饯；登高作赋，是所望于群公。敢竭鄙怀，恭疏短引；一言均赋，四韵俱成；请洒潘江，各倾陆海云尔。</p>
<h1 id="译文"><a href="#译文" class="headerlink" title="译文"></a>译文</h1><p>&emsp;&emsp;汉代的豫章旧郡，现在称洪都府。它处在翼、轸二星的分管区域，与庐山和衡山接壤。以三江为衣襟，以五湖为腰带，控制楚地，连接瓯越。这里地上物产的精华，乃是天的宝物，宝剑的光气直射牛、斗二星之间；人有俊杰是因为地有灵秀之气，徐孺子竟然在太守陈蕃家下榻(世说新语记载，太守陈蕃赏识徐孺子，专门为其在家中设置榻，当徐孺子来的时候，就将榻放下来，徐孺子走了就将榻吊起来，此处应该是称赞滕王阁的东道主欣赏才俊，也有夸赞宾客的成分)。雄伟的州城像雾一样涌起，俊美的人才像流星一样飞驰。城池倚据在荆楚和华夏交接的地方，宴会上客人和主人都是东南一带的俊杰。声望崇高的阎都督公，（使）打着仪仗（的高人）远道而来；德行美好的宇文新州刺史，（让）驾着车马（的雅士）也在此暂时驻扎。正好赶上十日一休的假日，才华出众的朋友多得如云；迎接千里而来的客人，尊贵的朋友坐满宴席。文章的辞彩如蛟龙腾空、凤凰飞起，那是文词宗主孟学士；紫电和清霜这样的宝剑，出自王将军的武库里。家父做交趾县令，我探望父亲路过这个有名的地方；我一个小孩子知道什么，却有幸亲自遇到了这样盛大的宴会。<br>&emsp;&emsp;时间是九月，季节为深秋。蓄积的雨水已经消尽，潭水寒冷而清澈，烟光雾气凝结，傍晚的山峦呈现出紫色。驾着豪华的马车行驶在高高的道路上，到崇山峻岭中观望风景。来到滕王营建的长洲上，看见他当年修建的楼阁。重叠的峰峦耸起一片苍翠，上达九霄；凌空架起的阁道上，朱红的油彩鲜艳欲滴，从高处往下看，地好像没有了似的。仙鹤野鸭栖止的水边平地和水中小洲，极尽岛屿曲折回环的景致；桂树与木兰建成的宫殿，随着冈峦高低起伏的态势。<br>&emsp;&emsp;打开精美的阁门，俯瞰雕饰的屋脊，放眼远望辽阔的山原充满视野，迂回的河流湖泊使人看了惊叹。房屋排满地面，有不少官宦人家；船只布满渡口，都装饰着青雀黄龙的头形。云消雨散，阳光普照，天空明朗。落霞与孤独的野鸭一齐飞翔，秋天的江水和辽阔的天空浑然一色。渔船唱着歌傍晚回来，歌声响遍鄱阳湖畔；排成行列的大雁被寒气惊扰，叫声消失在衡阳的水边。<br>&emsp;&emsp;远望的胸怀顿时舒畅，飘逸的兴致油然而生。排箫发出清脆的声音，引来阵阵清风；纤细的歌声仿佛凝住不散，阻止了白云的飘动。今日的宴会很像是当年睢园竹林的聚会，在座的诗人文士狂饮的气概压过了陶渊明；又有邺水的曹植咏荷花那样的才气，文采可以直射南朝诗人谢灵运。良辰、美景、赏心、乐事，四美都有，贤主、嘉宾，难得却得。放眼远望半空中，在闲暇的日子里尽情欢乐。天高地远，感到宇宙的无边无际；兴致已尽，悲随之来，认识到事物的兴衰成败有定数。远望长安在夕阳下，遥看吴越在云海间。地势偏远，南海深不可测；天柱高耸，北极星远远悬挂。雄关高山难以越过，有谁同情不得志的人?在座的各位如浮萍在水上相聚，都是客居异乡的人。思念皇宫却看不见，等待在宣室召见又是何年?<br>&emsp;&emsp;唉!命运不顺畅，路途多艰险。冯唐容易老，李广封侯难。把贾谊贬到长沙，并非没有圣明的君主；让梁鸿到海边隐居，难道不是在政治昌明的时代?能够依赖的是君子察觉事物细微的先兆，通达事理的人知道社会人事的规律。老了应当更有壮志，哪能在白发苍苍时改变自己的心志?处境艰难反而更加坚强，不放弃远大崇高的志向。喝了贪泉的水，仍然觉得心清气爽；处在干涸的车辙中，还能乐观开朗。北海虽然遥远，乘着旋风仍可以到达；少年的时光虽然已经消逝，珍惜将来的岁月还不算晚。孟尝品行高洁，却空有一腔报国的热情；怎能效法阮籍狂放不羁，在无路可走时便恸哭而返?<br>&emsp;&emsp;我，地位低下，一个书生。没有请缨报国的机会，虽然和终军的年龄相同；像班超那样有投笔从戎的胸怀，也仰慕宗悫“乘风破浪”的志愿。宁愿舍弃一生的功名富贵，到万里之外去早晚侍奉父亲。不敢说是谢玄那样的人才，却结识了诸位名家。过些天到父亲那里聆听教诲，一定要像孔鲤那样趋庭有礼，对答如流；今天举袖作揖谒见阎公，好像登上龙门一样。司马相如倘若没有遇到杨得意那样引荐的人，虽有文才也只能独自叹惋。既然遇到钟子期那样的知音，演奏高山流水的乐曲又有什么羞惭呢？<br>&emsp;&emsp;唉!名胜的地方不能长存，盛大的宴会难以再遇。当年兰亭宴饮集会的盛况已成为陈迹了，繁华的金谷园也成为荒丘废墟。临别赠言，作为有幸参加这次盛宴的纪念；登高作赋，那就指望在座的诸公了。冒昧给大家献丑，恭敬地写下这篇小序，我的一首四韵小诗也已写成。请各位像潘岳、陆机那样，展现如江似海的文才吧。</p>
<h1 id="作者"><a href="#作者" class="headerlink" title="作者"></a>作者</h1><p>&emsp;&emsp;《滕王阁序》，体裁：辞赋、骈文（魏晋以来产生的一种文体，又称骈俪文。骈文是与散文相对而言的。其主要特点是以四六句式为主，讲究对仗，因句式两两相对，犹如两马并驾齐驱，故被称为骈体。在声韵上，则讲究运用平仄，韵律和谐；修辞上注重藻饰和用典。由于骈文注重形式技巧，故内容的表达往住受到束缚，但运用得当，也能增强文章的艺术效果）；作者：王勃；别名：秋日登洪府滕王阁饯别序；年代：唐朝。<br>&emsp;&emsp;王勃（649～675年），唐代诗人。字子安。绛州龙门(今山西河津)人。王勃与杨炯、卢照邻、骆宾王以诗文齐名，并称“王杨卢骆”，亦称“初唐四杰”。王勃为隋末大儒王通的孙子（王通是隋末著名学者，号文中子），王通生二子，长名福郊，次名福峙，福峙即王勃之父，曾出任太常博士、雍州司功、交趾县令、六合县令、齐州长史等职。可知王勃生长于书香之家。<br>&emsp;&emsp;王勃才华早露，未成年即被司刑太常伯刘祥道赞为神童，向朝廷表荐，对策高第，授朝散郎。乾封初(666年)为沛王李贤征为王府侍读，两年后因戏为《檄英王鸡》文，被高宗怒逐出府。随即出游巴蜀。咸亨三年(672年)补虢州参军，因擅杀官奴当诛，遇赦除名。其父亦受累贬为交趾令。上元二年(675年)或三年(676年)，王勃南下探亲，渡海溺水，惊悸而死。其诗力求摆脱齐梁的绮靡诗风，文也有名，著名的《滕王阁序》就出自他之手。</p>
<h1 id="写作背景"><a href="#写作背景" class="headerlink" title="写作背景"></a>写作背景</h1><p>&emsp;&emsp;滕王阁因滕王李元婴得名。李元婴是唐高祖李渊的幼子，唐太宗李世民的弟弟，骄奢淫逸，品行不端，毫无政绩可言。但他精通歌舞，善画蝴蝶，很有艺术才情。他修建滕王阁，也是为了歌舞享乐的需要。这座江南名楼建于唐朝繁盛时期，又因王勃的一篇《滕王阁序》而很快出名。韩愈在《新修滕王阁记》中说：“愈少时，则闻江南多临观之美，而滕王阁独为第一，有瑰伟绝特之称。”<br>&emsp;&emsp;《滕王阁序》全称《秋日登洪府滕王阁饯别序》，又名《滕王阁诗序》《宴滕王阁序》，写于何时，有两种说法。唐末五代时人王定保的《唐摭言》说：“王勃著《滕王阁序》，时年十四。”那时，王勃的父亲可能任六合县(今属江苏)令，王勃赴六合经过洪州。又这篇序文中有“童子何知，躬逢胜饯”之语，也可佐证。元代辛文房《唐才子传》认为《滕王阁序》是上元二年(675)王勃前往交趾(在现在越南河内西北)看望父亲(那时他父亲任交趾县令)，路过南昌时所作。从这篇序文内容的博大、辞采的富赡来看，更像是成年作品。“童子”不一定就是指小孩，也可以是表示自己年轻无知的谦词。何况序文中有“无路请缨，等终军之弱冠”的话，“弱冠”是指二十岁。所以，关于写作时间，课文的注释解说采用后一种说法。<br>&emsp;&emsp;《新唐书·文艺传》记滕王阁诗会为：“九月九日都督大宴滕王阁，宿命其婿作序以夸客，因出纸笔遍请客，莫敢当，至勃，泛然不辞。都督怒，起更衣，遣吏伺其文辄报。一再报，语益奇，乃矍然曰：‘天才也!’请遂成文，极欢罢。”可见当时王勃年轻气盛，才华横溢，挥毫泼墨，语惊四座的情景。<br>&emsp;&emsp;关于王勃的生卒年，至今尚有歧说。杨炯《王勃集序》说他于唐高宗上元三年（676年）卒，年28岁。据此，王勃应生于唐太宗贞观二十三年（649年）。而王勃《春思赋》载：“咸亨二年（671年），余春秋二十有二。”据此推算，则当生于高宗永徽元年（65O年）。此为王勃自述，当可信，所以现在大多数学者认为王勃生于永徽元年（650年），卒于上元三年（676年），生年27岁。王勃是初唐诗坛上一位非常有才华的诗人，只活了27岁，确实令人痛惜。<br>&emsp;&emsp;王勃自幼聪慧好学，为时人所公认。《旧唐书》本传谓王勃：“六岁解属文，构思无滞，词情英迈，与兄才藻相类，父友杜易简常称之曰：此王氏三珠树也。”又有杨炯《王勃集序》说：“九岁读颜氏《汉书》，撰《指瑕》十卷。十岁包综六经，成乎期月，悬然天得，自符音训。时师百年之学，旬日兼之，昔人千载之机，立谈可见。”太常伯刘公称王绩为神童。唐高宗麟德元年（664年），王勃上书右相刘祥道，中有“所以慷慨于君侯者，有气存乎心耳”之语，求刘祥道表荐。刘即表荐于朝，王勃乃应麟德三年（666年）制科，对策高第，被授予朝散郎之职。此时的王勃，才14岁，尚是一少年。<br>&emsp;&emsp;沛王李贤闻王勃之名，召王勃为沛府修撰，十分爱重他。当时诸王经常斗鸡为乐，王勃闹着玩，写了一篇《檄周王鸡》，不料竟因此罹祸，唐高宗认为是使诸王闹矛盾，将王勃赶出沛王府。其实王勃此次受打击，并非真的因《檄周王鸡》而触怒高宗，而是因才高被嫉，所以杨炯《王勃集序》说他“临秀不容，寻反初服”。王勃被赶出沛王府后，便去游蜀，与杨炯等放旷诗酒，驰情于文场。《旧唐书·杨炯传》说：“炯与王勃、卢照邻、骆宾王以文词齐名，海内称为王杨卢骆，亦号为四杰。”<br>&emsp;&emsp;初唐四杰，在中国文学史上是一个非常著名的集团。作为一个集团，他们反对六朝以来颓废绮丽的风气，提出一些革新意见，开始把诗文从宫廷引向市井，从台阁移到江山和边塞，题材扩大了，风格也较清新刚健，对于革除齐梁余风、开创唐诗新气象，起了重要的作用。讲中国文学史，尤其是唐代文学史，没有不讲到王杨卢骆的。<br>&emsp;&emsp;王勃所遇到的第二次打击，是在虢州参军任上杀死自己所匿藏的官奴而犯罪。咸亨二年（671年）秋冬或第二年年初，王勃从蜀地返回长安参加科选。他的朋友凌季友当时为虢州司法，说虢州药物丰富，而他知医识药草，便为他在虢州谋得一个小小的参军之职。就在他任虢州参军期间，有个叫曹达的官奴犯罪，他将罪犯藏匿起来，后来又怕走漏风声，便杀死曹达以了其事，结果因此而犯了死罪。幸亏遇大赦，没有被处死。此事甚为蹊跷，王勃为什么要保护罪犯曹达，既藏匿保护又怎能将其杀死。据新旧《唐书》所载，王勃此次被祸，是因情才傲物，为同僚所嫉。官奴曹达事，有人怀疑为同僚设计构陷王勃，或者纯属诬陷，不无道理。总之王勃两次遭受打击，都与他的才华超人有关。<br>&emsp;&emsp;这次被祸，虽遇赦未丢掉性命，但宣告了他仕途的终结，也连累了他的父亲。王福峙因儿子王勃犯罪，被贬为交趾县令，远谪到南荒之外。王勃远行到交趾去看望父亲，途中溺水而死，从而结束了他年轻的生命。王勃的死，是渡水时遇难不幸而死，还是自杀，无从查考，总归是怀着一腔愁愤离开人世的。<br>&emsp;&emsp;王勃诗文俱佳，不愧为四杰之首，在扭转齐梁余风、开创唐诗上功劳尤大，为后世留下了一些不朽名篇。他的五言律诗《送杜少府之任蜀州》，成为中国诗歌史上的杰作，久为人们所传诵，“海内存知己，天涯若比邻”已成为千古名句，至今常被人们引用。而王勃最为人所称道、千百年来被传为佳话的，是他在滕王阁即席所赋《滕王阁序》。对此事，《唐摭言》所记最详。<br>&emsp;&emsp;上元二年（675年）秋，王勃前往交趾看望父亲，路过南昌时，正赶上都督阎伯屿新修滕王阁成，重阳日在滕王阁大宴宾客。王勃前往拜见，阎都督早闻他的名气，便请他也参加宴会。阎都督此次宴客，是为了向大家夸耀女婿孟学士的才学。让女婿事先准备好一篇序文，在席间当作即兴所作书写给大家看。宴会上，阎都督让人拿出纸笔，假意请诸人为这次盛会作序。大家知道他的用意，所以都推辞不写，而王勃以一个二十几岁的青年晚辈，竟不推辞，接过纸笔，当众挥笔而书。阎都督老大不高兴，拂衣而起，转入帐后，教人去看王勃写些什么。听说王勃开首写道“南昌故都，洪都新府”，都督便说：不过是老生常谈。又闻“星分翼轸，地接衡庐”，沉吟不语。等听到“落霞与孤骛齐飞，秋水共长天一色”，都督不得不叹服道：“此真天才，当垂不朽！”。《唐才子传》则记道：“勃欣然对客操觚，顷刻而就，文不加点，满座大惊。”<br>&emsp;&emsp;《唐摭言》等书所记，或者有些夸张，但王勃《滕王阁序》，确实为不朽之名篇。王勃于南昌阎都督宴上赋《滕王阁序》的佳话。实乃中国文学史上最为动人的故事。《新唐书》本传说王勃“属文，初不精思，先磨墨数升，则酣饮，引被覆面卧，及寤，援笔成篇，不易一字。”唐人段成式《酉阳杂俎》也说；“王勃每为碑颂，先磨墨数升，引被覆面卧，忽起一笔数之，初不窜点，时人谓之腹稿。”据此可知王勃文思敏捷，滕王阁上即兴而赋千古名篇，并非虚传。王勃作为古代一位极富才华的作家，未及而立之年便逝去，实在是中国文学的一大损失。<br>&emsp;&emsp;王勃虽然只活了27个春秋，但著述仍很多，曾撰《汉书指瑕》十卷，《周易发挥》五卷，《次论语》十卷，《舟中纂序》五卷，《千岁历》若干卷，可惜皆佚失。今所传者，唯《王子安集》16卷，也非全本。何林天教授点校整理的《重订新校王子安集》，收录了辑自日本的一些佚文，已由山西人民出版社出版</p>
<h1 id="艺术特色"><a href="#艺术特色" class="headerlink" title="艺术特色"></a>艺术特色</h1><p>&emsp;&emsp;《滕王阁序》是唐人王勃用骈文写的佳作。此文内容丰富，情真意切；对仗工整，声律和谐；手法多变，格调迥异；骈散结合，语言华美。千百年来，一直被世人广为传颂。在高中教材中，此文一直为广大师生所喜爱。这里，仅就个人对文章的一点浅陋理解，将本文的艺术手法作以简要梳理。</p>
<h2 id="一、文思细密，层层扣题"><a href="#一、文思细密，层层扣题" class="headerlink" title="一、文思细密，层层扣题"></a>一、文思细密，层层扣题</h2><p>&emsp;&emsp;本文原题是《秋日登洪府滕王阁饯别序》，全文谋篇布局，无不统于题目之下。第一段概写洪州地势之雄伟，物产之华美，人才之优秀，宾主之尊贵，紧扣题目“洪府”二字。第二段先叙写清澈幽寒之水，青紫暮色之山；再写仙境般之长洲，桂殿般之楼阁，展示了一幅壮美秀丽的滕王阁秋景图，紧扣题目“秋日” 、“登滕王阁”六字。第三段写滕王阁及周围景色之美，再一次紧扣题目“滕王阁”。第四段集中笔墨写阁中宴会场面，赞文人雅士之气概和风采，特别是“四美俱，二难并”一句，对良辰、美景、赏心、乐事和贤主嘉宾作总结赞美，紧扣题目“饯”。后面三段，笔锋一转，由盛赞良辰美景、文人雅士转为慨叹人生艰难、命运多舛，表达了正视现实、奋发向上的态度。最后交代有幸参加盛会，理当应命作序，紧扣题目“饯”“序”二字。纵观全文，由地及人、由人及景、由景及情，步步递进，层层扣题。</p>
<h2 id="二、写景状物，手法多变"><a href="#二、写景状物，手法多变" class="headerlink" title="二、写景状物，手法多变"></a>二、写景状物，手法多变</h2><p>&emsp;&emsp;王勃在文中运用灵活多变的手法描山绘水，将读者带入一种绝妙的佳境。    1、景情结合法。文章前半部分侧重写景，生动地展示了滕王阁壮美秀丽的图景，描绘了宴游唱和之欢乐。后半部分触景生情，反复抒发了作客他乡、怀才不遇的感慨，表达了对现实的不满。文中虽流露出相信时命运数的消极思想，但作者正视现实和奋发向上的进取精神在文中无处不在。可谓景中有情，情中见景。    2、色彩变化法。文章不惜笔墨，极力渲染，尽展色彩变化之美。如“紫电”、“青霜”、“耸翠”、“青雀”、“黄龙”、“白云”等，真可谓五光十色，摇曳生辉。特别是“潦水尽而寒潭清，烟光凝而暮山紫”一句，尽力表现出山光水色之色彩变化，上句用色淡雅，下句着色浓重，在对比中突出了秋日景象之色。    3、诗画统一法。文章第三段浓墨重彩地将滕王阁及周围景色推上了美的极致。文中写阁门美、屋宇美、山川美，写遍地宅舍、舸舰迷江、渔舟唱晚，真可谓是山清水秀、国富民强的江南风景图，特别是“落霞与孤鹜齐飞，秋水共长天一色”一句，既具有诗的意境，又兼备画的情调，想时像一幅充满诗意的大自然风景画，读时像一首妙趣绝伦的好诗，真是诗中有画，画中有诗。    4、虚实相间法。作者登高望远，不仅驰目四方，而且思接万里。文中既实写目之所见，又发挥想像，描摹目力难极之景。如为渲染阁中气氛，作者借助联想，让乐声唤来徐徐清风，让歌声阻遏高空行云，让雅士像陶渊明那样畅怀痛饮，让文人像谢灵运那般能诗善写。如此虚实相间，不仅使读者对所写之景有具体真实之感，又使读者视野开阔，目通万里。</p>
<h2 id="三、含蓄委婉，述志言情"><a href="#三、含蓄委婉，述志言情" class="headerlink" title="三、含蓄委婉，述志言情"></a>三、含蓄委婉，述志言情</h2><p>&emsp;&emsp;在大量的铺陈叙事之后，作者借含蓄委婉的笔法，腾挪跌宕之气势，宴游唱和之欢娱引出人世之艰难，仕途之崎岖，怀才之不遇，抒写了报国无门却奋发向上的执着态度。如第四自然段，兴尽悲来，“望长安于日下，指吴会于云间”委婉地抒发远离京城浪迹天涯之情。接着由关山难越，想到仕途失意，借屈原、贾谊、冯唐、李广的典故，抒发有志难伸的感慨，含蓄地表达了对所谓“圣君”“明时”的不满。“所赖君子安贪”三句，表达不因年华易逝和处境困顿而自暴自弃的精神，又以大鹏自比，表明扶摇直上九霄的凌云壮志。而后又借“失之东隅，收之桑榆”的说法，表明早年虽失意，但拯时匡世之信念并未泯灭。同时又反用“贪泉”“涸辙”“阮籍”之典，说明“出淤泥而不染”、“穷且益坚”之志。作者正是借多样的历史典故，委婉含蓄地述志言情。</p>
<h2 id="四、词藻华美，语约言丰"><a href="#四、词藻华美，语约言丰" class="headerlink" title="四、词藻华美，语约言丰"></a>四、词藻华美，语约言丰</h2><p>&emsp;&emsp;唐初的骈体文，还有齐梁之余风，辞藻繁多，典故滥用，即以形式上的浮艳来掩盖内容上的空虚，但王勃的《滕王阁序》却用骈文的形式表达丰富的内容，再现了交织于内心的失望与希望、痛苦与追求、落魄与奋进的感情历程，真可谓辞藻华美，语约言丰。其中妙词佳句，今天还脍炙人口，广为流传。如“星分翼轸”、“物华天宝”、“人杰地灵”、“雄州雾列”、“俊采星驰”、“胜友如云”、“高朋满座”、“ 关山难越”、“萍水相逢”、“冯唐易老，李广难封”、“老当益壮”、“穷且益坚”、“不坠青云之志”、“落霞与孤鹜齐飞，秋水共长天一色”……读之如饮醇酒，久而弥笃。典故如陶渊明、曹植、谢灵运、冯唐、李广、贾谊、梁鸿、贪泉、涸辙、北海、阮籍……这些典故并未使人陷入浓云晦雾之中，而是清新疏朗，意味隽永。读之令人荡气回肠，感染力极强。<br>&emsp;&emsp;总之，《滕王阁序》是古代骈文的精品，它既发挥了骈文特有的铺陈描写手法，又运用形散而神不散的散文之气于骈偶之中。字字绝妙，句句传神，章章生辉，使人读后有身临其境之感，正如都督阎公所言：“此真天才，当垂不朽矣！”它不但以其真实的情感和充实的内容区别于六朝及其以前那些无病呻吟或嘲风弄月者，而且打破了僵死陈旧的骈文格局和陈陈相因的文风，给骈文注入新的血液。</p>
<h1 id="读后感"><a href="#读后感" class="headerlink" title="读后感"></a>读后感</h1><h2 id="滕王阁序读后感（一）"><a href="#滕王阁序读后感（一）" class="headerlink" title="滕王阁序读后感（一）"></a>滕王阁序读后感（一）</h2><p>&emsp;&emsp;林中流淌的溪水，面前总会有巨石、横木拦住去路，河道也并非笔直，而是曲曲折折，总是阻止溪水前进。人生也正是这样。人所踏上的道路不是一帆风顺的，而是坎坷密布，荆棘丛生。时运不济，命途多舛。<br>&emsp;&emsp;在大唐王朝强盛的唐高宗年间，从绛州龙门走出了一位才高八斗的文人。他就是初唐四杰之一的王勃。他才华早露，十四岁时即被授予官职。然而他却在仕途至终因才华横溢而遭受了两次打击。这也宣告了他仕途的终结。<br>&emsp;&emsp;上元二年，滕王阁上，他即席作赋，写下了千古名篇《滕王阁序》，为历代传颂赞赏。今日，读《滕王阁序》，我会在开始时同情王勃的遭遇。然而，读至“老当益壮，宁移白首之心，穷且益坚，不坠青云之志”时，我便渐渐由同情变为了赞赏与佩服。读罢此文，我深有感触。<br>&emsp;&emsp;林中的溪水虽身处曲折的河道中，面对拦路的艰难险阻，却毫不畏惧、毫不气馁，只是聚成一股又一股的水流冲向障碍，冲破障碍，流向远方。人在经历了失败、打击、挫折后，需要一种乐观向上的心态，拥有这种心态后，人就会变得不畏困难，像溪水一样勇于面对，勇于承担，勇于挑战，在摔倒之后满怀信心地再度站起，为追寻成功继续前行。<br>&emsp;&emsp;王勃前往交趾看望自己被贬的父亲途中，心中还怀着两次打击给他留下的阴影。然而在《滕王阁序》却表现出了一种积极的壮怀。“酌贪泉而觉爽，处涸辙以犹欢”使人精神一振，感受到作者那种身处逆境却仍乐观向上的心情。西汉史学家司马迁惨遭酷刑，却最终完成了“史家绝唱”的《史记》。他在《报任安书》中写道盖西伯拘而演《周易》；仲尼厄而作《春秋》；屈原放逐，乃赋《离骚》；左丘失明，厥有《国语》；孙子膑脚，《兵法》修列；不韦迁蜀，世传《吕览》；韩非囚秦，《说难》、《孤愤》。《诗》三百篇，大氐贤圣发愤之所为作也。发明家爱迪生，失败两千多次后方才成功。音乐家贝多芬失聪，仍作出了一生中最伟大的音乐篇章。经历了痛苦的生命才能称其为人，真正的成功者都是从痛苦中超度出来的。古人在逆境，经历失败，这些不仅没有束缚他们的手脚，反而成就了他们的成功。若只是一味地感叹命运的不公，只会停滞不前，碌碌无为终此一生。<br>&emsp;&emsp;人生失意后，重要的不是别人的雪中送炭，而是自身需要一种积极乐观的态度去面对一切。命运是无情的，即使是叱咤疆场的一代名将李广也没有得到命运之神的眷顾，终身未得封侯，自刎沙场。海伦凯勒曾说过：“对于无可挽回的事，就应想得开点，不要总强求不可能的结果。”真正重要的并不是在一个人的身上发生了什么，而是这个人如何去看待。人不能只为自己的命运叹息，而是应该努力去改变命运。而改变命运就需要有向困难挑战的勇气和永不放弃的信心。而这些就需要心态的乐观。拥有了乐观的心态，人的心胸会变得宽广，不会总因失败而痛苦，心中会产生希望，进而会产生动力，使人继续向成功迈进。心态是成功的基石，正如一位名人所言：“播下一种心态，收获一种思想；播下一种思想，收获一种行为；播下一种行为，收获一种习惯；播下一种习惯，收获一种性格；播下一种性格，收获一种命运。”一切的根源就是一种心态。人如果改变了心态，就能改变他的命运。积极的心态，能使人重新振作，重拾信心；积极的心态，能使人不畏挑战，勇往直前；积极的心态，能使人坚持不懈，持之以恒，积极的心态，能使人超越自我，走向成功。<br>&emsp;&emsp;北海虽赊，扶摇可接，东隅已逝，桑榆非晚。林中的溪水，终有一天会流到广阔的大洋。人如果永怀积极乐观之心，终会铸成人生的辉煌。</p>
<h2 id="滕王阁序读后感（二）"><a href="#滕王阁序读后感（二）" class="headerlink" title="滕王阁序读后感（二）"></a>滕王阁序读后感（二）</h2><p>&emsp;&emsp;是夜，独坐于笼中，一盏青灯，半手残卷，摇头晃脑，念念有词，假马拉鬼了半天，也没见一只从天而将，衣袂飘飘的白狐，都是骗子，哪里来的什么白狐，算了，我也不是什么书生，遇不来也罢。<br>&emsp;&emsp;没来由的瞌睡，怎么这么困呢，想想白天也没干嘛啊，砸路灯，抢银行，打飞机，抢登钓鱼岛，这些也都不是我干的啊。不过在这里还是要向那几个妄图登陆钓鱼岛宣誓主权的英雄们致敬，你们的爱国热血激励了我们的什么什么，尽管已经麻木与主权是为谁而宣，但你们仍旧是英雄。我党呢已经见怪不怪了，按兵不动，坚持敌不动，我不动；敌动了，我抗议的一贯作风，只要不侵犯我党利益一切好说。一不小心又扯远了。<br>&emsp;&emsp;还是来说说解困，音乐已经不行了，听的都想吐了，就在灵魂即将出窍之际，又看到了这篇奇文，拿来一读，不得了啊，暑气顿消，困意全无啊，顿时神清气爽，夜不能寐啊。<br>&emsp;&emsp;正是王勃的《滕王阁序》，千古一序，名不虚传啊：<br>&emsp;&emsp;揽汉唐人文成一序，绝江山美景于片言。<br>&emsp;&emsp;此序一出，有没有滕王阁都无所谓了，什么文以阁名，阁以文传才是真，这滕王阁本一歌舞之地，现在矗在南昌那的意义也就是为南昌市人民政府挣点钱罢了，要说慕名前去看下我看十有八九，说绝对点肯定会失望的，就像你看新闻联播，跟现实完全不搭界（其实看新闻联播也就节目开始主持人报个日期是靠谱的），这读滕王阁序也是一样啊，里面描写的景色跟现实估计也不好比。<br>&emsp;&emsp;落霞与孤鹜齐飞，秋水共长天一色。渔舟唱晚，响穷彭蠡之滨；雁阵惊寒，声断衡阳之浦。如这般景色你就是请个高手来也PS不出此等画面，这般意境。况且每个人读出的景色画面也都不一样，完全是精神的享受了。说直白点是在意淫了。<br>&emsp;&emsp;我怀着无比敬仰的心情，就着拼音注释读了三遍，人一下子就机灵了，不困了，真的<br>&emsp;&emsp;何以解忧，唯有杜康，何以解困，首推此序啊。<br>&emsp;&emsp;唉，王勃就是死的太早了。</p>
<h2 id="滕王阁序读后感（三）"><a href="#滕王阁序读后感（三）" class="headerlink" title="滕王阁序读后感（三）"></a>滕王阁序读后感（三）</h2><p>&emsp;&emsp;滕王阁，是中国古代四大名楼之一（另外三座是岳阳楼、黄鹤楼、蓬莱阁）。而如果没有王勃的这篇千古流传的《膝王阁序》，滕王阁的盛名自然会削减不少。王勃乃“初唐四杰”之一，少年时期便有“神童”之名，其才情在这风华绝代的《膝王阁序》里得到了充分的展现：用词华美瑰丽，用典琳琅满目，行文气势磅礴、收放白如，既歌咏了滕王阁的雄伟壮观、宾主的才华横溢以及滕王阁周围的绝妙胜景，也抒发了自己怀才不遇、愤慈悲凉而又不甘沉沦的屈湘。《滕王阁序》由此奠定了其在中国古代文学史上不朽的地位。<br>&emsp;&emsp;就是这样一位满腹珠矶的才子，却得不到重用，郁郁寡欢，心情烦闷两个月后，王勃渡海去探望父亲时，不幸溺水身亡。<br>&emsp;&emsp;王勃的悲剧并不是很个别的现象，自古以来文人就常常成为统治者的工具，甚至仅仅是摆设。即如李白，已经达到了诗歌创作的顶峰，(<a href="http://www.lz13.cn)亦不过在皇帝的赏识下进官当一个御用文人，一个招之即来、抨之即去的“宠物”李白很不满，但又有什么办法呢？除了写下类似‘’仰天大笑出门去，我辈岂是蓬篙人“的诗句来一抒豪情，他并没有什么办法摆脱这种屈辱的地位。" target="_blank" rel="noopener">www.lz13.cn)亦不过在皇帝的赏识下进官当一个御用文人，一个招之即来、抨之即去的“宠物”李白很不满，但又有什么办法呢？除了写下类似‘’仰天大笑出门去，我辈岂是蓬篙人“的诗句来一抒豪情，他并没有什么办法摆脱这种屈辱的地位。</a><br>&emsp;&emsp;但几千年来中国文人的悲剧命运仅仅在于统治者吗？显然不是。文人往往自命不凡，的确，在知识普及程度很低的古代，一个饱读诗书的文人是可以在精神层面上俯视芸芸众生的。但这种精神上的距离，在实际生活中也使知识分子与人民大众有了隔膜像白居易那样写诗要让老婆婆也能明白的文人实属风毛麟角。脱离群众的后果是什么呢？上不能为统治者所用，下不屑与劳苦大众为伍。多少文人就这样落得个孤家寡人，潦倒而终。<br>&emsp;&emsp;还有，文人往往受”学而优则仕“的影响，把做官作为人生理想。殊不知，官场险恶，风云莫测。电视连续剧《铁齿铜牙纪晓岚》中，和坤有一段经典台词：”……纪先生您在文海遨游，而我却在宦海打滚儿。文海偶而有点小风小浪，宦海却永远是血雨腥风。“看，文坛与官场就有这样的差别！有些文人学会了政治权谋，摇身一变成为政治家，如王安石；另一些文人”保持本色“，除了几根硬骨头和一肚皮学问外，别无长处，于是官是做不下去的，如陶渊明。可悲的是，文人对统治者，在野则口诛笔伐，对官场黑暗也深恶痛绝，但朝廷一开始吸纳文人，绝大多数文人又趋之若鹜。明末张献忠举兵人蜀，长刀一挥，血流成河。可张献忠建立的”大西“政权一宣布”开科取士“，立刻有8000多名文人从四面八方赶到成都试图谋取功名，孰料全变成了张军的刀下之鬼。<br>&emsp;&emsp;千年一叹―中国文人的命运！</p>
]]></content>
      <categories>
        <category>文言</category>
      </categories>
      <tags>
        <tag>读书</tag>
      </tags>
  </entry>
  <entry>
    <title>JAVA线程总结</title>
    <url>/2017/07/03/java_thread/</url>
    <content><![CDATA[<h1 id="什么是线程？"><a href="#什么是线程？" class="headerlink" title="什么是线程？"></a>什么是线程？</h1><p>线程是进程的一个实体，是CPU调度和分派的基本单位，它是比进程更小的能独立运行的基本单位。线程自己基本上不拥有系统资源，只拥有一点在运行中必不可少的资源(如程序计数器，一组寄存器和栈)，但是它可与同属一个进程的其他的线程共享进程所拥有的全部资源。</p>
<p>有时候我们说线程是轻量级进程。就象进程一样，线程在程序中是独立的、并发的执行路径，每个线程有它自己的堆栈、自己的程序计数器和自己的局部变量。但是，与分隔的进程相比，进程中的线程之间的隔离程度要小。它们共享内存、文件句柄和其它每个进程应有的状态。</p>
<p>Java语言是第一个在语言本身中显式地包含线程的主流编程语言，它没有把线程化看作是底层操作系统的工具。</p>
<h1 id="为什么要用线程？"><a href="#为什么要用线程？" class="headerlink" title="为什么要用线程？"></a>为什么要用线程？</h1><ul>
<li>响应更快的 UI<br>（如GUI中事件线程）</li>
<li>利用多处理器系统<br>（单处理器多线程本质是处理器的短时间间隔复用，多处理器多线程就可以高效使用多处理器系统）</li>
<li>简化建模<br>（比如五大常用算法中的分治法，求多维数组的排序问题，多线程可以简化建模）</li>
<li>异步或后台处理<br>（这个很常见，比如轮询套接字，异步响应请求，servlet请求等等）</li>
</ul>
<p><strong>先不管那么多，看一个简单线程：一个计时线程案例</strong><br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 一个线程案例： （计时功能）</span></span><br><span class="line"><span class="comment">* 主线程开启一个打印素数的线程之后，主线程自己休息10秒，</span></span><br><span class="line"><span class="comment">* 10秒之后通过改变finished状态值，break新线程。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CalculatePrimes</span> <span class="keyword">extends</span> <span class="title">Thread</span></span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MAX_PRIMES = <span class="number">1000000</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> TEN_SECONDS = <span class="number">10000</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">volatile</span> <span class="keyword">boolean</span> finished = <span class="keyword">false</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] primes = <span class="keyword">new</span> <span class="keyword">int</span>[MAX_PRIMES];</span><br><span class="line">        <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">2</span>; count&lt;MAX_PRIMES; i++)&#123;</span><br><span class="line">            <span class="comment">// Check to see if the timer has expired</span></span><br><span class="line">            <span class="keyword">if</span> (finished) &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">boolean</span> prime = <span class="keyword">true</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j=<span class="number">0</span>; j&lt;count; j++)&#123;</span><br><span class="line">                <span class="keyword">if</span> (i % primes[j] == <span class="number">0</span>)&#123;</span><br><span class="line">                    prime = <span class="keyword">false</span>;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (prime)&#123;</span><br><span class="line">                primes[count++] = i;</span><br><span class="line">                System.out.println(<span class="string">"Found prime: "</span> + i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        CalculatePrimes calculator = <span class="keyword">new</span> CalculatePrimes();</span><br><span class="line">        calculator.start();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.sleep(TEN_SECONDS);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">catch</span> (InterruptedException e)&#123;</span><br><span class="line">            <span class="comment">// fall through</span></span><br><span class="line">        &#125;</span><br><span class="line">        calculator.finished = <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h1 id="线程的使用方法"><a href="#线程的使用方法" class="headerlink" title="线程的使用方法"></a>线程的使用方法</h1><h2 id="从生命周期5状态说起"><a href="#从生命周期5状态说起" class="headerlink" title="从生命周期5状态说起"></a>从生命周期5状态说起</h2><ul>
<li>新建（new Thread）<br>当创建Thread类的一个实例（对象）时，此线程进入新建状态（未被启动）。<br>例如：Thread  t1=new Thread();</li>
<li>就绪（runnable）<br>线程已经被启动，正在等待被分配给CPU时间片，也就是说此时线程正在就绪队列中排队等候得到CPU资源。例如：t1.start();</li>
<li>运行（running）<br>线程获得CPU资源正在执行任务（run()方法），此时除非此线程自动放弃CPU资源或者有优先级更高的线程进入，线程将一直运行到结束。</li>
<li>死亡（dead）<br>当线程执行完毕或被其它线程杀死，线程就进入死亡状态，这时线程不可能再进入就绪状态等待执行。<br>自然终止：正常运行run()方法后终止<br>异常终止：调用stop()方法让一个线程终止运行</li>
<li>堵塞（blocked）<br>由于某种原因导致正在运行的线程让出CPU并暂停自己的执行，即进入堵塞状态。<br>正在睡眠：用sleep(longt)方法可使线程进入睡眠方式。一个睡眠着的线程在指定的时间过去可进入就绪状态。<br>正在等待：调用wait()方法。（调用motify()方法回到就绪状态）<br>被另一个线程所阻塞：调用suspend()方法。（调用resume()方法恢复）</li>
</ul>
<h2 id="三种创建线程的方法"><a href="#三种创建线程的方法" class="headerlink" title="三种创建线程的方法"></a>三种创建线程的方法</h2><p>1.继承Thread类创建线程类<br>（1）定义Thread类的子类，并重写该类的run方法，该run方法的方法体就代表了线程要完成的任务。因此把run()方法称为执行体。<br>（2）创建Thread子类的实例，即创建了线程对象。<br>（3）调用线程对象的start()方法来启动该线程。<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FirstThreadTest</span> <span class="keyword">extends</span> <span class="title">Thread</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">//重写run方法，run方法的方法体就是现场执行体</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(;i&lt;<span class="number">100</span>;i++)&#123;</span><br><span class="line">        System.out.println(getName()+<span class="string">"  "</span>+i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i&lt; <span class="number">100</span>;i++)&#123;</span><br><span class="line">            System.out.println(Thread.currentThread().getName()+<span class="string">"  : "</span>+i);</span><br><span class="line">            <span class="keyword">if</span>(i==<span class="number">20</span>)&#123;</span><br><span class="line">                <span class="keyword">new</span> FirstThreadTest().start();</span><br><span class="line">                <span class="keyword">new</span> FirstThreadTest().start();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>2.通过Runnable接口创建线程类<br>（1）定义runnable接口的实现类，并重写该接口的run()方法，该run()方法的方法体同样是该线程的线程执行体。<br>（2）创建 Runnable实现类的实例，并依此实例作为Thread的target来创建Thread，该Thread对象才是真正的线程对象。<br>（3）调用线程对象的start()方法来启动该线程。<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RunnableThreadTest</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> i;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(i = <span class="number">0</span>;i &lt;<span class="number">100</span>;i++)&#123;</span><br><span class="line">            System.out.println(Thread.currentThread().getName()+<span class="string">" "</span>+i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; <span class="number">100</span>;i++)&#123;</span><br><span class="line">            System.out.println(Thread.currentThread().getName()+<span class="string">" "</span>+i);</span><br><span class="line">            <span class="keyword">if</span>(i==<span class="number">20</span>)&#123;</span><br><span class="line">                RunnableThreadTest rtt = <span class="keyword">new</span> RunnableThreadTest();</span><br><span class="line">                <span class="keyword">new</span> Thread(rtt,<span class="string">"新线程1"</span>).start();</span><br><span class="line">                <span class="keyword">new</span> Thread(rtt,<span class="string">"新线程2"</span>).start();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>3.通过Callable和Future创建线程<br>（1）创建Callable接口的实现类，并实现call()方法，该call()方法将作为线程执行体，并且有返回值。<br>（2）创建Callable实现类的实例，使用FutureTask类来包装Callable对象，该FutureTask对象封装了该Callable对象的call()方法的返回值。<br>（3）使用FutureTask对象作为Thread对象的target创建并启动新线程。<br>（4）调用FutureTask对象的get()方法来获得子线程执行结束后的返回值。<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.Callable;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.ExecutionException;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.FutureTask;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CallableThreadTest</span> <span class="keyword">implements</span> <span class="title">Callable</span>&lt;<span class="title">Integer</span>&gt;</span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Integer <span class="title">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(;i&lt;<span class="number">100</span>;i++)&#123;</span><br><span class="line">            System.out.println(Thread.currentThread().getName()+<span class="string">" "</span>+i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> i;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        CallableThreadTest ctt = <span class="keyword">new</span> CallableThreadTest();</span><br><span class="line">        FutureTask&lt;Integer&gt; ft = <span class="keyword">new</span> FutureTask&lt;&gt;(ctt);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; <span class="number">100</span>;i++)&#123;</span><br><span class="line">            System.out.println(Thread.currentThread().getName()+<span class="string">" 的循环变量i的值"</span>+i);</span><br><span class="line">            <span class="keyword">if</span>(i==<span class="number">20</span>)&#123;</span><br><span class="line">                <span class="keyword">new</span> Thread(ft,<span class="string">"有返回值的线程"</span>).start();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            System.out.println(<span class="string">"子线程的返回值："</span>+ft.get());</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e)&#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (ExecutionException e)&#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>采用实现Runnable、Callable接口的方式创见多线程时，优势是：<br>线程类只是实现了Runnable接口或Callable接口，还可以继承其他类。<br>在这种方式下，多个线程可以共享同一个target对象，所以非常适合多个相同线程来处理同一份资源的情况，从而可以将CPU、代码和数据分开，形成清晰的模型，较好地体现了面向对象的思想。<br>劣势是：<br>编程稍微复杂，如果要访问当前线程，则必须使用Thread.currentThread()方法。</p>
<p>使用继承Thread类的方式创建多线程时优势是：<br>编写简单，如果需要访问当前线程，则无需使用Thread.currentThread()方法，直接使用this即可获得当前线程。<br>劣势是：<br>线程类已经继承了Thread类，所以不能再继承其他父类。</p>
<h2 id="一些常见API"><a href="#一些常见API" class="headerlink" title="一些常见API"></a>一些常见API</h2><p>在介绍生命周期的时候，我们已经接触了一些常见API,建议直接看API文档<a href="http://tool.oschina.net/apidocs/apidoc?api=jdk_7u4" target="_blank" rel="noopener">JDK7-API-java.lang.Thread</a><br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">常用API</span></span><br><span class="line"><span class="comment">**/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//几毫秒加几纳秒之后调用线程将阻塞，直到目标线程完成为止.调用线程继续。</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">join</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">join</span><span class="params">(<span class="keyword">long</span> millis)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">join</span><span class="params">(<span class="keyword">long</span> millis,<span class="keyword">int</span> nanos)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//继承Object.导致线程进入等待状态，直到它被其他线程通过notify()或者notifyAll唤醒。该方法只能在同步方法中调用。如果当前线程不是锁的持有者，该方法抛出一个IllegalMonitorStateException异常。</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">wait</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">wait</span><span class="params">(<span class="keyword">long</span> millis)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">wait</span><span class="params">(<span class="keyword">long</span> millis,<span class="keyword">int</span> nanos)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//随机选择一个在该对象上调用wait方法的线程，解除其阻塞状态。该方法只能在同步方法或同步块内部调用。如果当前线程不是锁的持有者，该方法抛出一个IllegalMonitorStateException异常。</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">notify</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//解除所有那些在该对象上调用wait方法的线程的阻塞状态。该方法只能在同步方法或同步块内部调用。如果当前线程不是锁的持有者，该方法抛出一个IllegalMonitorStateException异常。</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">notifyAll</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">wait、notify和notifyAll方法是Object类的final native方法。所以这些方法不能被子类重写，Object类是所有类的超类，因此在程序中有以下三种形式调用wait等方法。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">wait();//方式1：</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">this.wait();//方式2：</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">super.wait();//方式3</span></span><br><span class="line"><span class="comment">**/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//将使当前线程进入等待状态，直到过了一段指定时间，或者直到另一个线程对当前线程的Thread对象调用了Thread.interrupt()，从而中断了线程。</span></span><br><span class="line"><span class="comment">//当过了指定时间后，线程又将变成可运行的，并且回到调度程序的可运行线程队列中。</span></span><br><span class="line"><span class="comment">//如果线程是由对 Thread.interrupt() 的调用而中断的，那么休眠的线程会抛出InterruptedException，这样线程就知道它是由中断唤醒的，就不必查看计时器是否过期。</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sleep</span><span class="params">(<span class="keyword">long</span> millis)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sleep</span><span class="params">(<span class="keyword">long</span> millis, <span class="keyword">int</span> nanos)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//中断发起调用的线程。</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">interrupt</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//就像sleep() 一样，但它并不引起休眠，而只是暂停当前线程片刻，这样其它线程就可以运行了。</span></span><br><span class="line"><span class="comment">//在大多数实现中，当较高优先级的线程调用Thread.yield() 时，较低优先级的线程就不会运行。</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">yield</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//指明某个线程是守护程序线程。</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">setDaemon</span> <span class="params">(<span class="keyword">boolean</span> on)</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="comment">//启动线程</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">start</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//结束线程</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">stop</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure></p>
<h2 id="关于守护线程"><a href="#关于守护线程" class="headerlink" title="关于守护线程"></a>关于守护线程</h2><p>大概是受到操作系统中守护进程的设计思路，在设计java线程的时候也同样的也有守护线程机制。</p>
<p>java的线程分为两类：User Thread(用户线程)、Daemon Thread(守护线程)，其实User Thread线程和Daemon Thread守护线程本质上来说去没啥区别的，唯一的区别之处就在虚拟机的离开：如果User Thread全部撤离，那么Daemon Thread也就没啥线程好服务的了，所以虚拟机也就退出了。</p>
<p>Java语言机制是构建在JVM的基础之上的，java内部的守护线程也存在与JVM中，比如GC线程。</p>
<p>守护线程并非虚拟机内部可以提供，用户也可以自行的设定守护线程，方法：public final void setDaemon(boolean on) ；但是有几点需要注意：</p>
<ol>
<li><p>thread.setDaemon(true)必须在thread.start()之前设置，否则会跑出一个IllegalThreadStateException异常。你不能把正在运行的常规线程设置为守护线程。  （备注：这点与守护进程有着明显的区别，守护进程是创建后，让进程摆脱原会话的控制+让进程摆脱原进程组的控制+让进程摆脱原控制终端的控制；所以说寄托于虚拟机的语言机制跟系统级语言有着本质上面的区别）</p>
</li>
<li><p>在Daemon线程中产生的新线程也是Daemon的。   （这一点又是有着本质的区别了：守护进程fork()出来的子进程不再是守护进程，尽管它把父进程的进程相关信息复制过去了，但是子进程的进程的父进程不是init进程，所谓的守护进程本质上说就是“父进程挂掉，init收养，然后文件0,1,2都是/dev/null，当前目录到/”）</p>
</li>
<li><p>不是所有的应用都可以分配给Daemon线程来进行服务，比如读写操作或者计算逻辑。因为在Daemon Thread还没来的及进行操作时，虚拟机可能已经退出了。</p>
</li>
</ol>
<p><strong>例子：</strong><br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.*;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TestRunnable</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            Thread.sleep(<span class="number">1000</span>);<span class="comment">//守护线程阻塞1秒后运行</span></span><br><span class="line">            File f=<span class="keyword">new</span> File(<span class="string">"daemon.txt"</span>);</span><br><span class="line">            FileOutputStream os=<span class="keyword">new</span> FileOutputStream(f,<span class="keyword">true</span>);</span><br><span class="line">            os.write(<span class="string">"daemon"</span>.getBytes());</span><br><span class="line">        &#125;<span class="keyword">catch</span>(IOException e1)&#123;</span><br><span class="line">            e1.printStackTrace();</span><br><span class="line">        &#125;<span class="keyword">catch</span>(InterruptedException e2)&#123;</span><br><span class="line">            e2.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestDemo2</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException</span>&#123;</span><br><span class="line">        Runnable tr=<span class="keyword">new</span> TestRunnable();</span><br><span class="line">        Thread thread=<span class="keyword">new</span> Thread(tr);</span><br><span class="line">        <span class="comment">//thread.setDaemon(true);</span></span><br><span class="line">        thread.setDaemon(<span class="keyword">true</span>); <span class="comment">//设置守护线程</span></span><br><span class="line">        thread.start(); <span class="comment">//开始执行分进程</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>运行结果：文件daemon.txt中没有”daemon”字符串。</p>
<p>但是如果把thread.setDaemon(true); 注释掉，文件daemon.txt是可以被写入daemon字符串的。</p>
<p>JVM判断程序是否执行结束的标准是所有的前台执线程行完毕了，而不管后台线程（守护线程）的状态，因此，在使用守护线程的时候一定要注意这个问题。</p>
<p>举个例子，web服务器中的Servlet容器启动时后台初始化一个服务线程，即调度线程，负责处理http请求，然后每个请求过来调度线程从线程池中取出一个工作者线程来处理该请求，从而实现并发控制的目的。</p>
<h2 id="同步的问题"><a href="#同步的问题" class="headerlink" title="同步的问题"></a>同步的问题</h2><p>为了确保可以在线程之间以受控方式共享数据，Java语言提供了两个关键字：synchronized 和 volatile。</p>
<p>Volatile 只适合于控制对基本变量（整数、布尔变量等）的单个实例的访问。当一个变量被声明成volatile，任何对该变量的写操作都会绕过高速缓存，直接写入主内存，而任何对该变量的读取也都绕过高速缓存，直接取自主内存。这表示所有线程在任何时候看到的 volatile 变量值都相同，这保证了变量的一致性，但是如果要保护比较大的代码段还需要用Synchronized。</p>
<p>Synchronized 同步：</p>
<p>同步使用监控器（monitor）或锁的概念，以协调对特定代码块的访问。</p>
<p>每个 Java 对象都有一个相关的锁。同一时间只能有一个线程持有 Java 锁。当线程进入synchronized代码块时，线程会阻塞并等待，直到锁可用，当它可用时，就会获得这个锁，然后执行代码块。当控制退出受保护的代码块时，即到达了代码块末尾或者抛出了没有在 synchronized 块中捕获的异常时，它就会释放该锁。</p>
<p>这样，每次只有一个线程可以执行受给定监控器保护的代码块。从其它线程的角度看，该代码块可以看作是原子的，它要么全部执行，要么根本不执行。</p>
<p><strong>例子：</strong><br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SyncExample</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> lockObject = <span class="keyword">new</span> Object();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Thread1</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (lockObject) &#123;</span><br><span class="line">                x = <span class="number">0</span>;</span><br><span class="line">                y = <span class="number">0</span>;</span><br><span class="line">                System.out.println(x);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Thread2</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (lockObject) &#123;</span><br><span class="line">                x = <span class="number">1</span>;</span><br><span class="line">                y = <span class="number">1</span>;</span><br><span class="line">                System.out.println(y);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">new</span> Thread1().run();</span><br><span class="line">        <span class="keyword">new</span> Thread2().run();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>使用 synchronized 块可以让您将一组相关更新作为一个集合来执行，而不必担心其它线程中断或看到计算的中间结果。以下示例代码将打印“10”或“01”。如果没有同步，它还会打印“1 1” 或“0 0”。</p>
<p>以上是synchronized 块的原理，除此之外还可以同步一个方法：<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Point</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> x;<span class="keyword">private</span> y;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">setXY</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.x = x;</span><br><span class="line">    <span class="keyword">this</span>.y = y;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>对于普通的 synchronized 方法，这个锁是一个对象，将针对它调用方法。对于静态 synchronized方法，这个锁是本对象，在该对象中声明了方法。仅仅因为 setXY() 被声明成 synchronized 并不表示两个不同的线程不能同时执行 setXY()，只要<br>它们调用不同的 Point 实例的 setXY() 就可同时执行。对于一个 Point 实例，一次只能有一个线程执行 setXY()。</p>
<p><strong>示例：简单的线程安全的高速缓存：</strong><br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SimpleCache</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Map cache = <span class="keyword">new</span> HashMap();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">load</span><span class="params">(String objectName)</span></span>&#123;</span><br><span class="line">    <span class="comment">// load the object somehow</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">clearCache</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (cache)&#123;</span><br><span class="line">        cache.clear();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">getObject</span><span class="params">(String objectName)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (cache)&#123;</span><br><span class="line">            Object o = cache.get(objectName);</span><br><span class="line">            <span class="keyword">if</span> (o == <span class="keyword">null</span>)&#123;</span><br><span class="line">                o = load(objectName);</span><br><span class="line">                cache.put(objectName, o);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="keyword">return</span> o;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><strong><em>以上代码，使用 HashMap 为对象装入器提供了一个简单的高速缓存。load()方法知道怎样按对象的键装入对象。在一次装入对象之后，该对象就被存储到高速缓存中，这样以后的访问就会从高速缓存中检索它，而不是每次都全部地装入它。对共享高速缓存的每个访问都受到synchronized 块保护。由于它被正确同步，所以多个线程可以同时调用 getObject 和<br>clearCache 方法，而没有数据损坏的风险。</em></strong></p>
<h2 id="同步？不同步？"><a href="#同步？不同步？" class="headerlink" title="同步？不同步？"></a>同步？不同步？</h2><p>什么时候必须同步？</p>
<ul>
<li>需要保证在多线程中，一部分数据是一致的即用于一致性的同步</li>
<li>递增共享计数器（多线程共用一个计数器类或方法），本质还是一致性</li>
<li>final字段是线程友好的，不必担心同步问题</li>
</ul>
<p>什么时候不需要同步？</p>
<ul>
<li>由静态初始化器（在静态字段上或 static{} 块中的初始化器）初始化数据时，JVM隐性的帮我们同步了</li>
<li>访问final变量时</li>
<li>死锁</li>
<li>性能考虑</li>
</ul>
<p>同步准则？</p>
<ul>
<li>使代码块保持简短。Synchronized块应该简短,在保证相关数据操作的完整性的同时，<br>尽量简短。把不随线程变化的预处理和后处理移出 synchronized 块</li>
<li>不要阻塞。不要在 synchronized块或方法中调用可能引起阻塞的方法，如InputStream.read()</li>
<li>在持有锁的时候，不要对其它对象调用方法。这听起来可能有些极端，但它消除了最常见的死锁源头。</li>
</ul>
<h1 id="其他一些案例"><a href="#其他一些案例" class="headerlink" title="其他一些案例"></a>其他一些案例</h1><h2 id="使用java-util-TimerTask解决计数器的问题"><a href="#使用java-util-TimerTask解决计数器的问题" class="headerlink" title="使用java.util.TimerTask解决计数器的问题"></a>使用java.util.TimerTask解决计数器的问题</h2><p>这是上文的案例，我们可以不让主线程休眠，方法如下：<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 一个线程案例： （计时功能）</span></span><br><span class="line"><span class="comment">* 主线程开启一个打印素数的线程之后，主线程自己休息10秒，</span></span><br><span class="line"><span class="comment">* 10秒之后通过改变finished状态值，break新线程。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CalculatePrimes</span> <span class="keyword">extends</span> <span class="title">Thread</span></span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MAX_PRIMES = <span class="number">1000000</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> TEN_SECONDS = <span class="number">10000</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">volatile</span> <span class="keyword">boolean</span> finished = <span class="keyword">false</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] primes = <span class="keyword">new</span> <span class="keyword">int</span>[MAX_PRIMES];</span><br><span class="line">        <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">2</span>; count&lt;MAX_PRIMES; i++)&#123;</span><br><span class="line">            <span class="comment">// Check to see if the timer has expired</span></span><br><span class="line">            <span class="keyword">if</span> (finished) &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">boolean</span> prime = <span class="keyword">true</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j=<span class="number">0</span>; j&lt;count; j++)&#123;</span><br><span class="line">                <span class="keyword">if</span> (i % primes[j] == <span class="number">0</span>)&#123;</span><br><span class="line">                    prime = <span class="keyword">false</span>;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (prime)&#123;</span><br><span class="line">                primes[count++] = i;</span><br><span class="line">                System.out.println(<span class="string">"Found prime: "</span> + i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        Timer timer = <span class="keyword">new</span> Timer();</span><br><span class="line">        <span class="keyword">final</span> CalculatePrimes calculator = <span class="keyword">new</span> CalculatePrimes();</span><br><span class="line">        calculator.start();</span><br><span class="line">        timer.schedule(</span><br><span class="line">            <span class="keyword">new</span> TimerTask() &#123;</span><br><span class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;</span><br><span class="line">                    calculator.finished = <span class="keyword">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;, TEN_SECONDS);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="servlet-和-JavaServer-Pages-技术"><a href="#servlet-和-JavaServer-Pages-技术" class="headerlink" title="servlet 和 JavaServer Pages 技术"></a>servlet 和 JavaServer Pages 技术</h2><h2 id="实现-RMI-对象"><a href="#实现-RMI-对象" class="headerlink" title="实现 RMI 对象"></a>实现 RMI 对象</h2>]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>线程</tag>
        <tag>同步</tag>
      </tags>
  </entry>
  <entry>
    <title>Lambda表达式和匿名内部类</title>
    <url>/2021/04/15/2021_04_16_lambda/</url>
    <content><![CDATA[<p>Java Lambda表达式的一个重要用法是简化某些匿名内部类（<code>Anonymous Classes</code>）的写法。实际上Lambda表达式并不仅仅是匿名内部类的语法糖，JVM内部是通过<code>invokedynamic</code>指令来实现Lambda表达式的。具体原理之后会讲解。本节我们首先感受一下使用Lambda表达式带来的便利之处。<br><a id="more"></a></p>
<h1 id="一、Lambda表达式和匿名内部类I"><a href="#一、Lambda表达式和匿名内部类I" class="headerlink" title="一、Lambda表达式和匿名内部类I"></a>一、Lambda表达式和匿名内部类I</h1><h3 id="取代某些匿名内部类"><a href="#取代某些匿名内部类" class="headerlink" title="取代某些匿名内部类"></a>取代某些匿名内部类</h3><p>本节将介绍如何使用Lambda表达式简化匿名内部类的书写，但Lambda表达式并不能取代所有的匿名内部类，只能用来取代<strong>函数接口（Functional Interface）</strong>的简写。先别在乎细节，看几个例子再说。</p>
<h4 id="例子1：无参函数的简写"><a href="#例子1：无参函数的简写" class="headerlink" title="例子1：无参函数的简写"></a>例子1：无参函数的简写</h4><p>如果需要新建一个线程，一种常见的写法是这样：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// JDK7 匿名内部类写法</span></span><br><span class="line"><span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable()&#123;<span class="comment">// 接口名</span></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;<span class="comment">// 方法名</span></span><br><span class="line">		System.out.println(<span class="string">"Thread run()"</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;).start();</span><br></pre></td></tr></table></figure>
<p>上述代码给<code>Tread</code>类传递了一个匿名的<code>Runnable</code>对象，重载<code>Runnable</code>接口的<code>run()</code>方法来实现相应逻辑。这是JDK7以及之前的常见写法。匿名内部类省去了为类起名字的烦恼，但还是不够简化，在Java 8中可以简化为如下形式：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// JDK8 Lambda表达式写法</span></span><br><span class="line"><span class="keyword">new</span> Thread(</span><br><span class="line">		() -&gt; System.out.println(<span class="string">"Thread run()"</span>)<span class="comment">// 省略接口名和方法名</span></span><br><span class="line">).start();</span><br></pre></td></tr></table></figure>
<p>上述代码跟匿名内部类的作用是一样的，但比匿名内部类更进一步。这里连<strong>接口名和函数名都一同省掉</strong>了，写起来更加神清气爽。如果函数体有多行，可以用大括号括起来，就像这样：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// JDK8 Lambda表达式代码块写法</span></span><br><span class="line"><span class="keyword">new</span> Thread(</span><br><span class="line">        () -&gt; &#123;</span><br><span class="line">            System.out.print(<span class="string">"Hello"</span>);</span><br><span class="line">            System.out.println(<span class="string">" Hoolee"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">).start();</span><br></pre></td></tr></table></figure>
<h4 id="例子2：带参函数的简写"><a href="#例子2：带参函数的简写" class="headerlink" title="例子2：带参函数的简写"></a>例子2：带参函数的简写</h4><p>如果要给一个字符串列表通过自定义比较器，按照字符串长度进行排序，Java 7的书写形式如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// JDK7 匿名内部类写法</span></span><br><span class="line">List&lt;String&gt; list = Arrays.asList(<span class="string">"I"</span>, <span class="string">"love"</span>, <span class="string">"you"</span>, <span class="string">"too"</span>);</span><br><span class="line">Collections.sort(list, <span class="keyword">new</span> Comparator&lt;String&gt;()&#123;<span class="comment">// 接口名</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compare</span><span class="params">(String s1, String s2)</span></span>&#123;<span class="comment">// 方法名</span></span><br><span class="line">        <span class="keyword">if</span>(s1 == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(s2 == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">return</span> s1.length()-s2.length();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>上述代码通过内部类重载了<code>Comparator</code>接口的<code>compare()</code>方法，实现比较逻辑。采用Lambda表达式可简写如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// JDK8 Lambda表达式写法</span></span><br><span class="line">List&lt;String&gt; list = Arrays.asList(<span class="string">"I"</span>, <span class="string">"love"</span>, <span class="string">"you"</span>, <span class="string">"too"</span>);</span><br><span class="line">Collections.sort(list, (s1, s2) -&gt;&#123;<span class="comment">// 省略参数表的类型</span></span><br><span class="line">    <span class="keyword">if</span>(s1 == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(s2 == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> s1.length()-s2.length();</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>上述代码跟匿名内部类的作用是一样的。除了省略了接口名和方法名，代码中把参数表的类型也省略了。这得益于<code>javac</code>的<strong>类型推断</strong>机制，编译器能够根据上下文信息推断出参数的类型，当然也有推断失败的时候，这时就需要手动指明参数类型了。注意，Java是强类型语言，每个变量和对象都必需有明确的类型。</p>
<h1 id="简写的依据"><a href="#简写的依据" class="headerlink" title="简写的依据"></a>简写的依据</h1><p>也许你已经想到了，<strong>能够使用Lambda的依据是必须有相应的函数接口</strong>（函数接口，是指内部只有一个抽象方法的接口）。这一点跟Java是强类型语言吻合，也就是说你并不能在代码的任何地方任性的写Lambda表达式。实际上<em>Lambda的类型就是对应函数接口的类型</em>。<strong>Lambda表达式另一个依据是类型推断机制</strong>，在上下文信息足够的情况下，编译器可以推断出参数表的类型，而不需要显式指名。Lambda表达更多合法的书写形式如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Lambda表达式的书写形式</span></span><br><span class="line">Runnable run = () -&gt; System.out.println(<span class="string">"Hello World"</span>);<span class="comment">// 1</span></span><br><span class="line">ActionListener listener = event -&gt; System.out.println(<span class="string">"button clicked"</span>);<span class="comment">// 2</span></span><br><span class="line">Runnable multiLine = () -&gt; &#123;<span class="comment">// 3 代码块</span></span><br><span class="line">    System.out.print(<span class="string">"Hello"</span>);</span><br><span class="line">    System.out.println(<span class="string">" Hoolee"</span>);</span><br><span class="line">&#125;;</span><br><span class="line">BinaryOperator&lt;Long&gt; add = (Long x, Long y) -&gt; x + y;<span class="comment">// 4</span></span><br><span class="line">BinaryOperator&lt;Long&gt; addImplicit = (x, y) -&gt; x + y;<span class="comment">// 5 类型推断</span></span><br></pre></td></tr></table></figure>
<p>上述代码中，1展示了无参函数的简写；2处展示了有参函数的简写，以及类型推断机制；3是代码块的写法；4和5再次展示了类型推断机制。</p>
<h1 id="自定义函数接口"><a href="#自定义函数接口" class="headerlink" title="自定义函数接口"></a>自定义函数接口</h1><p>自定义函数接口很容易，只需要编写一个只有一个抽象方法的接口即可。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 自定义函数接口</span></span><br><span class="line"><span class="meta">@FunctionalInterface</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">ConsumerInterface</span>&lt;<span class="title">T</span>&gt;</span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">accept</span><span class="params">(T t)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面代码中的@FunctionalInterface是可选的，但加上该标注编译器会帮你检查接口是否符合函数接口规范。就像加入@Override标注会检查是否重载了函数一样。</p>
<p>有了上述接口定义，就可以写出类似如下的代码：</p>
<p><code>ConsumerInterface&lt;String&gt; consumer = str -&gt; System.out.println(str);</code></p>
<p>进一步的，还可以这样使用：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyStream</span>&lt;<span class="title">T</span>&gt;</span>&#123;</span><br><span class="line">	<span class="keyword">private</span> List&lt;T&gt; list;</span><br><span class="line">    ...</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">myForEach</span><span class="params">(ConsumerInterface&lt;T&gt; consumer)</span></span>&#123;<span class="comment">// 1</span></span><br><span class="line">		<span class="keyword">for</span>(T t : list)&#123;</span><br><span class="line">			consumer.accept(t);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line">MyStream&lt;String&gt; stream = <span class="keyword">new</span> MyStream&lt;String&gt;();</span><br><span class="line">stream.myForEach(str -&gt; System.out.println(str));<span class="comment">// 使用自定义函数接口书写Lambda表达式</span></span><br></pre></td></tr></table></figure>
<h1 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h1><ol>
<li><a href="https://docs.oracle.com/javase/specs/jls/se8/html/index.html" target="_blank" rel="noopener">The Java® Language Specification</a></li>
<li><a href="http://viralpatel.net/blogs/lambda-expressions-java-tutorial/" target="_blank" rel="noopener">http://viralpatel.net/blogs/lambda-expressions-java-tutorial/</a></li>
<li><a href="https://www.amazon.cn/Java-8%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8B-%E8%8B%B1-%E6%B2%83%E4%BC%AF%E9%A1%BF/dp/B00VDSW7AE" target="_blank" rel="noopener">《Java 8函数式编程 [英]沃伯顿》</a></li>
</ol>
<h1 id="Lambda-and-Anonymous-Classes-II"><a href="#Lambda-and-Anonymous-Classes-II" class="headerlink" title="Lambda and Anonymous Classes(II)"></a>Lambda and Anonymous Classes(II)</h1><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>读过上一篇之后，相信对Lambda表达式的语法以及基本原理有了一定了解。对于编写代码，有这些知识已经够用。本文将<strong>进一步区分Lambda表达式和匿名内部类在JVM层面的区别，如果对这一部分不感兴趣，可以跳过</strong>。</p>
<h1 id="不是匿名内部类的简写"><a href="#不是匿名内部类的简写" class="headerlink" title="不是匿名内部类的简写"></a>不是匿名内部类的简写</h1><p>经过第一篇的的介绍，我们看到Lambda表达式似乎只是为了简化匿名内部类书写，这看起来仅仅通过语法糖在编译阶段把所有的Lambda表达式替换成匿名内部类就可以了。但实时并非如此。在JVM层面，Lambda表达式和匿名内部类有着明显的差别。</p>
<h2 id="匿名内部类实现"><a href="#匿名内部类实现" class="headerlink" title="匿名内部类实现"></a>匿名内部类实现</h2><p><strong>匿名内部类仍然是一个类，只是不需要程序员显示指定类名，编译器会自动为该类取名</strong>。因此如果有如下形式的代码，编译之后将会产生两个class文件：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MainAnonymousClass</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable()&#123;</span><br><span class="line">			<span class="meta">@Override</span></span><br><span class="line">			<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;</span><br><span class="line">				System.out.println(<span class="string">"Anonymous Class Thread run()"</span>);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;).start();;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>编译之后文件分布如下，两个class文件分别是主类和匿名内部类产生的：</p>
<p><img src="./Figures/2-AnonymousClass.png" alt="2-AnonymousClass.png"></p>
<p>进一步分析主类MainAnonymousClass.class的字节码，可发现其创建了匿名内部类的对象：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// javap -c MainAnonymousClass.class</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MainAnonymousClass</span> </span>&#123;</span><br><span class="line">  ...</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(java.lang.String[])</span></span>;</span><br><span class="line">    Code:</span><br><span class="line">       0: new           #2                  // class java/lang/Thread</span><br><span class="line">       <span class="number">3</span>: dup</span><br><span class="line">       4: new           #3                  // class MainAnonymousClass$1 /*创建内部类对象*/</span><br><span class="line">       <span class="number">7</span>: dup</span><br><span class="line">       8: invokespecial #4                  // Method MainAnonymousClass$1."&lt;init&gt;":()V</span><br><span class="line">      11: invokespecial #5                  // Method java/lang/Thread."&lt;init&gt;":(Ljava/lang/Runnable;)V</span><br><span class="line">      14: invokevirtual #6                  // Method java/lang/Thread.start:()V</span><br><span class="line">      <span class="number">17</span>: <span class="keyword">return</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="Lambda表达式实现"><a href="#Lambda表达式实现" class="headerlink" title="Lambda表达式实现"></a>Lambda表达式实现</h2><p><strong>Lambda表达式通过<em>invokedynamic</em>指令实现，书写Lambda表达式不会产生新的类</strong>。如果有如下代码，编译之后只有一个class文件：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MainLambda</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">new</span> Thread(</span><br><span class="line">				() -&gt; System.out.println(<span class="string">"Lambda Thread run()"</span>)</span><br><span class="line">			).start();;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>编译之后的结果：</p>
<p><img src="./Figures/2-Lambda.png" alt="2-Lambda"></p>
<p>通过javap反编译命名，我们更能看出Lambda表达式内部表示的不同：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// javap -c -p MainLambda.class</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MainLambda</span> </span>&#123;</span><br><span class="line">  ...</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(java.lang.String[])</span></span>;</span><br><span class="line">    Code:</span><br><span class="line">       0: new           #2                  // class java/lang/Thread</span><br><span class="line">       <span class="number">3</span>: dup</span><br><span class="line">       4: invokedynamic #3,  0              // InvokeDynamic #0:run:()Ljava/lang/Runnable; /*使用invokedynamic指令调用*/</span><br><span class="line">       9: invokespecial #4                  // Method java/lang/Thread."&lt;init&gt;":(Ljava/lang/Runnable;)V</span><br><span class="line">      12: invokevirtual #5                  // Method java/lang/Thread.start:()V</span><br><span class="line">      <span class="number">15</span>: <span class="keyword">return</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> lambda$main$<span class="number">0</span>();  <span class="comment">/*Lambda表达式被封装成主类的私有方法*/</span></span><br><span class="line">    Code:</span><br><span class="line">       0: getstatic     #6                  // Field java/lang/System.out:Ljava/io/PrintStream;</span><br><span class="line">       3: ldc           #7                  // String Lambda Thread run()</span><br><span class="line">       5: invokevirtual #8                  // Method java/io/PrintStream.println:(Ljava/lang/String;)V</span><br><span class="line">       <span class="number">8</span>: <span class="keyword">return</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>反编译之后我们发现Lambda表达式被封装成了主类的一个私有方法，并通过<em>invokedynamic</em>指令进行调用。</p>
<h2 id="推论，this引用的意义"><a href="#推论，this引用的意义" class="headerlink" title="推论，this引用的意义"></a>推论，this引用的意义</h2><p>既然Lambda表达式不是内部类的简写，那么Lambda内部的<code>this</code>引用也就跟内部类对象没什么关系了。在Lambda表达式中<code>this</code>的意义跟在表达式外部完全一样。因此下列代码将输出两遍<code>Hello Hoolee</code>，而不是两个引用地址。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Hello</span> </span>&#123;</span><br><span class="line">	Runnable r1 = () -&gt; &#123; System.out.println(<span class="keyword">this</span>); &#125;;</span><br><span class="line">	Runnable r2 = () -&gt; &#123; System.out.println(toString()); &#125;;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">new</span> Hello().r1.run();</span><br><span class="line">		<span class="keyword">new</span> Hello().r2.run();</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> <span class="string">"Hello Hoolee"</span>; &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="参考文献-1"><a href="#参考文献-1" class="headerlink" title="参考文献"></a>参考文献</h2><p><a href="http://cr.openjdk.java.net/~briangoetz/lambda/lambda-state-final.html" target="_blank" rel="noopener">http://cr.openjdk.java.net/~briangoetz/lambda/lambda-state-final.html</a></p>
<h1 id="Lambda-and-Collections"><a href="#Lambda-and-Collections" class="headerlink" title="Lambda and Collections"></a>Lambda and Collections</h1><p>[TOC]</p>
<h2 id="前言-1"><a href="#前言-1" class="headerlink" title="前言"></a>前言</h2><p>我们先从最熟悉的<em>Java集合框架(Java Collections Framework, JCF)</em>开始说起。</p>
<p>为引入Lambda表达式，Java8新增了<code>java.util.function</code>包，里面包含常用的<strong>函数接口</strong>，这是Lambda表达式的基础，Java集合框架也新增部分接口，以便与Lambda表达式对接。</p>
<p>首先回顾一下Java集合框架的接口继承结构：</p>
<p><img src="./Figures/JCF_Collection_Interfaces.png" alt="JCF_Collection_Interfaces"></p>
<p>上图中绿色标注的接口类，表示在Java8中加入了新的接口方法，当然由于继承关系，他们相应的子类也都会继承这些新方法。下表详细列举了这些方法。</p>
<table>
<thead>
<tr>
<th>接口名</th>
<th>Java8新加入的方法</th>
</tr>
</thead>
<tbody>
<tr>
<td>Collection</td>
<td>removeIf() spliterator() stream() parallelStream() forEach()</td>
</tr>
<tr>
<td>List</td>
<td>replaceAll() sort()</td>
</tr>
<tr>
<td>Map</td>
<td>getOrDefault() forEach() replaceAll() putIfAbsent() remove() replace() computeIfAbsent() computeIfPresent() compute() merge()</td>
</tr>
</tbody>
</table>
<p>这些新加入的方法大部分要用到<code>java.util.function</code>包下的接口，这意味着这些方法大部分都跟Lambda表达式相关。我们将逐一学习这些方法。</p>
<h2 id="Collection中的新方法"><a href="#Collection中的新方法" class="headerlink" title="Collection中的新方法"></a>Collection中的新方法</h2><p>如上所示，接口<code>Collection</code>和<code>List</code>新加入了一些方法，我们以是<code>List</code>的子类<code>ArrayList</code>为例来说明。了解<a href="https://github.com/CarpenterLee/JCFInternals/blob/master/markdown/2-ArrayList.md" target="_blank" rel="noopener">Java7<code>ArrayList</code>实现原理</a>，将有助于理解下文。</p>
<h3 id="forEach"><a href="#forEach" class="headerlink" title="forEach()"></a>forEach()</h3><p>该方法的签名为<code>void forEach(Consumer&lt;? super E&gt; action)</code>，作用是对容器中的每个元素执行<code>action</code>指定的动作，其中<code>Consumer</code>是个函数接口，里面只有一个待实现方法<code>void accept(T t)</code>（后面我们会看到，这个方法叫什么根本不重要，你甚至不需要记忆它的名字）。</p>
<p>需求：<em>假设有一个字符串列表，需要打印出其中所有长度大于3的字符串.</em></p>
<p>Java7及以前我们可以用增强的for循环实现：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 使用曾强for循环迭代</span></span><br><span class="line">ArrayList&lt;String&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;(Arrays.asList(<span class="string">"I"</span>, <span class="string">"love"</span>, <span class="string">"you"</span>, <span class="string">"too"</span>));</span><br><span class="line"><span class="keyword">for</span>(String str : list)&#123;</span><br><span class="line">    <span class="keyword">if</span>(str.length()&gt;<span class="number">3</span>)</span><br><span class="line">        System.out.println(str);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>现在使用<code>forEach()</code>方法结合匿名内部类，可以这样实现：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 使用forEach()结合匿名内部类迭代</span></span><br><span class="line">ArrayList&lt;String&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;(Arrays.asList(<span class="string">"I"</span>, <span class="string">"love"</span>, <span class="string">"you"</span>, <span class="string">"too"</span>));</span><br><span class="line">list.forEach(<span class="keyword">new</span> Consumer&lt;String&gt;()&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">accept</span><span class="params">(String str)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(str.length()&gt;<span class="number">3</span>)</span><br><span class="line">            System.out.println(str);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>上述代码调用<code>forEach()</code>方法，并使用匿名内部类实现<code>Comsumer</code>接口。到目前为止我们没看到这种设计有什么好处，但是不要忘记Lambda表达式，使用Lambda表达式实现如下：<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 使用forEach()结合Lambda表达式迭代</span></span><br><span class="line">ArrayList&lt;String&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;(Arrays.asList(<span class="string">"I"</span>, <span class="string">"love"</span>, <span class="string">"you"</span>, <span class="string">"too"</span>));</span><br><span class="line">list.forEach( str -&gt; &#123;</span><br><span class="line">        <span class="keyword">if</span>(str.length()&gt;<span class="number">3</span>)</span><br><span class="line">            System.out.println(str);</span><br><span class="line">    &#125;);</span><br></pre></td></tr></table></figure></p>
<p>上述代码给<code>forEach()</code>方法传入一个Lambda表达式，我们不需要知道<code>accept()</code>方法，也不需要知道<code>Consumer</code>接口，类型推导帮我们做了一切。</p>
<h3 id="removeIf"><a href="#removeIf" class="headerlink" title="removeIf()"></a>removeIf()</h3><p>该方法签名为<code>boolean removeIf(Predicate&lt;? super E&gt; filter)</code>，作用是<strong>删除容器中所有满足<code>filter</code>指定条件的元素</strong>，其中<code>Predicate</code>是一个函数接口，里面只有一个待实现方法<code>boolean test(T t)</code>，同样的这个方法的名字根本不重要，因为用的时候不需要书写这个名字。</p>
<p>需求：<em>假设有一个字符串列表，需要删除其中所有长度大于3的字符串。</em></p>
<p>我们知道如果需要在迭代过程冲对容器进行删除操作必须使用迭代器，否则会抛出<code>ConcurrentModificationException</code>，所以上述任务传统的写法是：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 使用迭代器删除列表元素</span></span><br><span class="line">ArrayList&lt;String&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;(Arrays.asList(<span class="string">"I"</span>, <span class="string">"love"</span>, <span class="string">"you"</span>, <span class="string">"too"</span>));</span><br><span class="line">Iterator&lt;String&gt; it = list.iterator();</span><br><span class="line"><span class="keyword">while</span>(it.hasNext())&#123;</span><br><span class="line">    <span class="keyword">if</span>(it.next().length()&gt;<span class="number">3</span>) <span class="comment">// 删除长度大于3的元素</span></span><br><span class="line">        it.remove();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>现在使用<code>removeIf()</code>方法结合匿名内部类，我们可是这样实现：<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 使用removeIf()结合匿名名内部类实现</span></span><br><span class="line">ArrayList&lt;String&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;(Arrays.asList(<span class="string">"I"</span>, <span class="string">"love"</span>, <span class="string">"you"</span>, <span class="string">"too"</span>));</span><br><span class="line">list.removeIf(<span class="keyword">new</span> Predicate&lt;String&gt;()&#123; <span class="comment">// 删除长度大于3的元素</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">test</span><span class="params">(String str)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> str.length()&gt;<span class="number">3</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p>
<p>上述代码使用<code>removeIf()</code>方法，并使用匿名内部类实现<code>Precicate</code>接口。相信你已经想到用Lambda表达式该怎么写了：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 使用removeIf()结合Lambda表达式实现</span></span><br><span class="line">ArrayList&lt;String&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;(Arrays.asList(<span class="string">"I"</span>, <span class="string">"love"</span>, <span class="string">"you"</span>, <span class="string">"too"</span>));</span><br><span class="line">list.removeIf(str -&gt; str.length()&gt;<span class="number">3</span>); <span class="comment">// 删除长度大于3的元素</span></span><br></pre></td></tr></table></figure>
<p>使用Lambda表达式不需要记忆<code>Predicate</code>接口名，也不需要记忆<code>test()</code>方法名，只需要知道此处需要一个返回布尔类型的Lambda表达式就行了。</p>
<h3 id="replaceAll"><a href="#replaceAll" class="headerlink" title="replaceAll()"></a>replaceAll()</h3><p>该方法签名为<code>void replaceAll(UnaryOperator&lt;E&gt; operator)</code>，作用是<strong>对每个元素执行<code>operator</code>指定的操作，并用操作结果来替换原来的元素</strong>。其中<code>UnaryOperator</code>是一个函数接口，里面只有一个待实现函数<code>T apply(T t)</code>。</p>
<p>需求：<em>假设有一个字符串列表，将其中所有长度大于3的元素转换成大写，其余元素不变。</em></p>
<p>Java7及之前似乎没有优雅的办法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 使用下标实现元素替换</span></span><br><span class="line">ArrayList&lt;String&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;(Arrays.asList(<span class="string">"I"</span>, <span class="string">"love"</span>, <span class="string">"you"</span>, <span class="string">"too"</span>));</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;list.size(); i++)&#123;</span><br><span class="line">    String str = list.get(i);</span><br><span class="line">    <span class="keyword">if</span>(str.length()&gt;<span class="number">3</span>)</span><br><span class="line">        list.set(i, str.toUpperCase());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>使用<code>replaceAll()</code>方法结合匿名内部类可以实现如下：<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 使用匿名内部类实现</span></span><br><span class="line">ArrayList&lt;String&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;(Arrays.asList(<span class="string">"I"</span>, <span class="string">"love"</span>, <span class="string">"you"</span>, <span class="string">"too"</span>));</span><br><span class="line">list.replaceAll(<span class="keyword">new</span> UnaryOperator&lt;String&gt;()&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">apply</span><span class="params">(String str)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(str.length()&gt;<span class="number">3</span>)</span><br><span class="line">            <span class="keyword">return</span> str.toUpperCase();</span><br><span class="line">        <span class="keyword">return</span> str;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p>
<p>上述代码调用<code>replaceAll()</code>方法，并使用匿名内部类实现<code>UnaryOperator</code>接口。我们知道可以用更为简洁的Lambda表达式实现：<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 使用Lambda表达式实现</span></span><br><span class="line">ArrayList&lt;String&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;(Arrays.asList(<span class="string">"I"</span>, <span class="string">"love"</span>, <span class="string">"you"</span>, <span class="string">"too"</span>));</span><br><span class="line">list.replaceAll(str -&gt; &#123;</span><br><span class="line">    <span class="keyword">if</span>(str.length()&gt;<span class="number">3</span>)</span><br><span class="line">        <span class="keyword">return</span> str.toUpperCase();</span><br><span class="line">    <span class="keyword">return</span> str;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p>
<h3 id="sort"><a href="#sort" class="headerlink" title="sort()"></a>sort()</h3><p>该方法定义在<code>List</code>接口中，方法签名为<code>void sort(Comparator&lt;? super E&gt; c)</code>，该方法<strong>根据<code>c</code>指定的比较规则对容器元素进行排序</strong>。<code>Comparator</code>接口我们并不陌生，其中有一个方法<code>int compare(T o1, T o2)</code>需要实现，显然该接口是个函数接口。</p>
<p>需求：<em>假设有一个字符串列表，按照字符串长度增序对元素排序。</em></p>
<p>由于Java7以及之前<code>sort()</code>方法在<code>Collections</code>工具类中，所以代码要这样写：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Collections.sort()方法</span></span><br><span class="line">ArrayList&lt;String&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;(Arrays.asList(<span class="string">"I"</span>, <span class="string">"love"</span>, <span class="string">"you"</span>, <span class="string">"too"</span>));</span><br><span class="line">Collections.sort(list, <span class="keyword">new</span> Comparator&lt;String&gt;()&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compare</span><span class="params">(String str1, String str2)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> str1.length()-str2.length();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>现在可以直接使用<code>List.sort()方法</code>，结合Lambda表达式，可以这样写：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// List.sort()方法结合Lambda表达式</span></span><br><span class="line">ArrayList&lt;String&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;(Arrays.asList(<span class="string">"I"</span>, <span class="string">"love"</span>, <span class="string">"you"</span>, <span class="string">"too"</span>));</span><br><span class="line">list.sort((str1, str2) -&gt; str1.length()-str2.length());</span><br></pre></td></tr></table></figure>
<h3 id="spliterator"><a href="#spliterator" class="headerlink" title="spliterator()"></a>spliterator()</h3><p>方法签名为<code>Spliterator&lt;E&gt; spliterator()</code>，该方法返回容器的<strong>可拆分迭代器</strong>。从名字来看该方法跟<code>iterator()</code>方法有点像，我们知道<code>Iterator</code>是用来迭代容器的，<code>Spliterator</code>也有类似作用，但二者有如下不同：</p>
<ol>
<li><code>Spliterator</code>既可以像<code>Iterator</code>那样逐个迭代，也可以批量迭代。批量迭代可以降低迭代的开销。</li>
<li><code>Spliterator</code>是可拆分的，一个<code>Spliterator</code>可以通过调用<code>Spliterator&lt;T&gt; trySplit()</code>方法来尝试分成两个。一个是<code>this</code>，另一个是新返回的那个，这两个迭代器代表的元素没有重叠。</li>
</ol>
<p>可通过（多次）调用<code>Spliterator.trySplit()</code>方法来分解负载，以便多线程处理。</p>
<h3 id="stream-和parallelStream"><a href="#stream-和parallelStream" class="headerlink" title="stream()和parallelStream()"></a>stream()和parallelStream()</h3><p><code>stream()</code>和<code>parallelStream()</code>分别<strong>返回该容器的<code>Stream</code>视图表示</strong>，不同之处在于<code>parallelStream()</code>返回并行的<code>Stream</code>。<strong><code>Stream</code>是Java函数式编程的核心类</strong>，我们会在后面章节中学习。</p>
<h2 id="Map中的新方法"><a href="#Map中的新方法" class="headerlink" title="Map中的新方法"></a>Map中的新方法</h2><p>相比<code>Collection</code>，<code>Map</code>中加入了更多的方法，我们以<code>HashMap</code>为例来逐一探秘。了解<a href="https://github.com/CarpenterLee/JCFInternals/blob/master/markdown/6-HashSet%20and%20HashMap.md" target="_blank" rel="noopener">Java7<code>HashMap</code>实现原理</a>，将有助于理解下文。</p>
<h3 id="forEach-1"><a href="#forEach-1" class="headerlink" title="forEach()"></a>forEach()</h3><p>该方法签名为<code>void forEach(BiConsumer&lt;? super K,? super V&gt; action)</code>，作用是<strong>对<code>Map</code>中的每个映射执行<code>action</code>指定的操作</strong>，其中<code>BiConsumer</code>是一个函数接口，里面有一个待实现方法<code>void accept(T t, U u)</code>。<code>BinConsumer</code>接口名字和<code>accept()</code>方法名字都不重要，请不要记忆他们。</p>
<p>需求：<em>假设有一个数字到对应英文单词的Map，请输出Map中的所有映射关系．</em></p>
<p>Java7以及之前经典的代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Java7以及之前迭代Map</span></span><br><span class="line">HashMap&lt;Integer, String&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">map.put(<span class="number">1</span>, <span class="string">"one"</span>);</span><br><span class="line">map.put(<span class="number">2</span>, <span class="string">"two"</span>);</span><br><span class="line">map.put(<span class="number">3</span>, <span class="string">"three"</span>);</span><br><span class="line"><span class="keyword">for</span>(Map.Entry&lt;Integer, String&gt; entry : map.entrySet())&#123;</span><br><span class="line">    System.out.println(entry.getKey() + <span class="string">"="</span> + entry.getValue());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>使用<code>Map.forEach()</code>方法，结合匿名内部类，代码如下：<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 使用forEach()结合匿名内部类迭代Map</span></span><br><span class="line">HashMap&lt;Integer, String&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">map.put(<span class="number">1</span>, <span class="string">"one"</span>);</span><br><span class="line">map.put(<span class="number">2</span>, <span class="string">"two"</span>);</span><br><span class="line">map.put(<span class="number">3</span>, <span class="string">"three"</span>);</span><br><span class="line">map.forEach(<span class="keyword">new</span> BiConsumer&lt;Integer, String&gt;()&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">accept</span><span class="params">(Integer k, String v)</span></span>&#123;</span><br><span class="line">        System.out.println(k + <span class="string">"="</span> + v);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p>
<p>上述代码调用<code>forEach()</code>方法，并使用匿名内部类实现<code>BiConsumer</code>接口。当然，实际场景中没人使用匿名内部类写法，因为有Lambda表达式：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 使用forEach()结合Lambda表达式迭代Map</span></span><br><span class="line">HashMap&lt;Integer, String&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">map.put(<span class="number">1</span>, <span class="string">"one"</span>);</span><br><span class="line">map.put(<span class="number">2</span>, <span class="string">"two"</span>);</span><br><span class="line">map.put(<span class="number">3</span>, <span class="string">"three"</span>);</span><br><span class="line">map.forEach((k, v) -&gt; System.out.println(k + <span class="string">"="</span> + v));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="getOrDefault"><a href="#getOrDefault" class="headerlink" title="getOrDefault()"></a>getOrDefault()</h3><p>该方法跟Lambda表达式没关系，但是很有用。方法签名为<code>V getOrDefault(Object key, V defaultValue)</code>，作用是<strong>按照给定的<code>key</code>查询<code>Map</code>中对应的<code>value</code>，如果没有找到则返回<code>defaultValue</code></strong>。使用该方法程序员可以省去查询指定键值是否存在的麻烦．</p>
<p>需求；<em>假设有一个数字到对应英文单词的Map，输出4对应的英文单词，如果不存在则输出NoValue</em></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 查询Map中指定的值，不存在时使用默认值</span></span><br><span class="line">HashMap&lt;Integer, String&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">map.put(<span class="number">1</span>, <span class="string">"one"</span>);</span><br><span class="line">map.put(<span class="number">2</span>, <span class="string">"two"</span>);</span><br><span class="line">map.put(<span class="number">3</span>, <span class="string">"three"</span>);</span><br><span class="line"><span class="comment">// Java7以及之前做法</span></span><br><span class="line"><span class="keyword">if</span>(map.containsKey(<span class="number">4</span>))&#123; <span class="comment">// 1</span></span><br><span class="line">    System.out.println(map.get(<span class="number">4</span>));</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">    System.out.println(<span class="string">"NoValue"</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// Java8使用Map.getOrDefault()</span></span><br><span class="line">System.out.println(map.getOrDefault(<span class="number">4</span>, <span class="string">"NoValue"</span>)); <span class="comment">// 2</span></span><br></pre></td></tr></table></figure>
<h3 id="putIfAbsent"><a href="#putIfAbsent" class="headerlink" title="putIfAbsent()"></a>putIfAbsent()</h3><p>该方法跟Lambda表达式没关系，但是很有用。方法签名为<code>V putIfAbsent(K key, V value)</code>，作用是只有在<strong>不存在<code>key</code>值的映射或映射值为<code>null</code>时</strong>，才将<code>value</code>指定的值放入到<code>Map</code>中，否则不对<code>Map</code>做更改．该方法将条件判断和赋值合二为一，使用起来更加方便．</p>
<h3 id="remove"><a href="#remove" class="headerlink" title="remove()"></a>remove()</h3><p>我们都知道<code>Map</code>中有一个<code>remove(Object key)</code>方法，来根据指定<code>key</code>值删除<code>Map</code>中的映射关系；Java8新增了<code>remove(Object key, Object value)</code>方法，只有在当前<code>Map</code>中<strong><code>key</code>正好映射到<code>value</code>时</strong>才删除该映射，否则什么也不做．</p>
<h3 id="replace"><a href="#replace" class="headerlink" title="replace()"></a>replace()</h3><p>在Java7及以前，要想替换<code>Map</code>中的映射关系可通过<code>put(K key, V value)</code>方法实现，该方法总是会用新值替换原来的值．为了更精确的控制替换行为，Java8在<code>Map</code>中加入了两个<code>replace()</code>方法，分别如下：</p>
<ul>
<li><code>replace(K key, V value)</code>，只有在当前<code>Map</code>中<strong><code>key</code>的映射存在时</strong>才用<code>value</code>去替换原来的值，否则什么也不做．</li>
<li><code>replace(K key, V oldValue, V newValue)</code>，只有在当前<code>Map</code>中<strong><code>key</code>的映射存在且等于<code>oldValue</code>时</strong>才用<code>newValue</code>去替换原来的值，否则什么也不做．</li>
</ul>
<h3 id="replaceAll-1"><a href="#replaceAll-1" class="headerlink" title="replaceAll()"></a>replaceAll()</h3><p>该方法签名为<code>replaceAll(BiFunction&lt;? super K,? super V,? extends V&gt; function)</code>，作用是对<code>Map</code>中的每个映射执行<code>function</code>指定的操作，并用<code>function</code>的执行结果替换原来的<code>value</code>，其中<code>BiFunction</code>是一个函数接口，里面有一个待实现方法<code>R apply(T t, U u)</code>．不要被如此多的函数接口吓到，因为使用的时候根本不需要知道他们的名字．</p>
<p>需求：<em>假设有一个数字到对应英文单词的Map，请将原来映射关系中的单词都转换成大写．</em></p>
<p>Java7以及之前经典的代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Java7以及之前替换所有Map中所有映射关系</span></span><br><span class="line">HashMap&lt;Integer, String&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">map.put(<span class="number">1</span>, <span class="string">"one"</span>);</span><br><span class="line">map.put(<span class="number">2</span>, <span class="string">"two"</span>);</span><br><span class="line">map.put(<span class="number">3</span>, <span class="string">"three"</span>);</span><br><span class="line"><span class="keyword">for</span>(Map.Entry&lt;Integer, String&gt; entry : map.entrySet())&#123;</span><br><span class="line">    entry.setValue(entry.getValue().toUpperCase());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>使用<code>replaceAll()</code>方法结合匿名内部类，实现如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 使用replaceAll()结合匿名内部类实现</span></span><br><span class="line">HashMap&lt;Integer, String&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">map.put(<span class="number">1</span>, <span class="string">"one"</span>);</span><br><span class="line">map.put(<span class="number">2</span>, <span class="string">"two"</span>);</span><br><span class="line">map.put(<span class="number">3</span>, <span class="string">"three"</span>);</span><br><span class="line">map.replaceAll(<span class="keyword">new</span> BiFunction&lt;Integer, String, String&gt;()&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">apply</span><span class="params">(Integer k, String v)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> v.toUpperCase();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>上述代码调用<code>replaceAll()</code>方法，并使用匿名内部类实现<code>BiFunction</code>接口。更进一步的，使用Lambda表达式实现如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 使用replaceAll()结合Lambda表达式实现</span></span><br><span class="line">HashMap&lt;Integer, String&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">map.put(<span class="number">1</span>, <span class="string">"one"</span>);</span><br><span class="line">map.put(<span class="number">2</span>, <span class="string">"two"</span>);</span><br><span class="line">map.put(<span class="number">3</span>, <span class="string">"three"</span>);</span><br><span class="line">map.replaceAll((k, v) -&gt; v.toUpperCase());</span><br></pre></td></tr></table></figure>
<p>简洁到让人难以置信．</p>
<h3 id="merge"><a href="#merge" class="headerlink" title="merge()"></a>merge()</h3><p>该方法签名为<code>merge(K key, V value, BiFunction&lt;? super V,? super V,? extends V&gt; remappingFunction)</code>，作用是：</p>
<ol>
<li>如果<code>Map</code>中<code>key</code>对应的映射不存在或者为<code>null</code>，则将<code>value</code>（不能是<code>null</code>）关联到<code>key</code>上；</li>
<li>否则执行<code>remappingFunction</code>，如果执行结果非<code>null</code>则用该结果跟<code>key</code>关联，否则在<code>Map</code>中删除<code>key</code>的映射．</li>
</ol>
<p>参数中<code>BiFunction</code>函数接口前面已经介绍过，里面有一个待实现方法<code>R apply(T t, U u)</code>．</p>
<p><code>merge()</code>方法虽然语义有些复杂，但该方法的用方式很明确，一个比较常见的场景是将新的错误信息拼接到原来的信息上，比如：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">map.merge(key, newMsg, (v1, v2) -&gt; v1+v2);</span><br></pre></td></tr></table></figure>
<h3 id="compute"><a href="#compute" class="headerlink" title="compute()"></a>compute()</h3><p>该方法签名为<code>compute(K key, BiFunction&lt;? super K,? super V,? extends V&gt; remappingFunction)</code>，作用是把<code>remappingFunction</code>的计算结果关联到<code>key</code>上，如果计算结果为<code>null</code>，则在<code>Map</code>中删除<code>key</code>的映射．</p>
<p>要实现上述<code>merge()</code>方法中错误信息拼接的例子，使用<code>compute()</code>代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">map.compute(key, (k,v) -&gt; v==<span class="keyword">null</span> ? newMsg : v.concat(newMsg));</span><br></pre></td></tr></table></figure>
<h3 id="computeIfAbsent"><a href="#computeIfAbsent" class="headerlink" title="computeIfAbsent()"></a>computeIfAbsent()</h3><p>该方法签名为<code>V computeIfAbsent(K key, Function&lt;? super K,? extends V&gt; mappingFunction)</code>，作用是：只有在当前<code>Map</code>中<strong>不存在<code>key</code>值的映射或映射值为<code>null</code>时</strong>，才调用<code>mappingFunction</code>，并在<code>mappingFunction</code>执行结果非<code>null</code>时，将结果跟<code>key</code>关联．</p>
<p><code>Function</code>是一个函数接口，里面有一个待实现方法<code>R apply(T t)</code>．</p>
<p><code>computeIfAbsent()</code>常用来对<code>Map</code>的某个<code>key</code>值建立初始化映射．比如我们要实现一个多值映射，<code>Map</code>的定义可能是<code>Map&lt;K,Set&lt;V&gt;&gt;</code>，要向<code>Map</code>中放入新值，可通过如下代码实现：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Map&lt;Integer, Set&lt;String&gt;&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line"><span class="comment">// Java7及以前的实现方式</span></span><br><span class="line"><span class="keyword">if</span>(map.containsKey(<span class="number">1</span>))&#123;</span><br><span class="line">    map.get(<span class="number">1</span>).add(<span class="string">"one"</span>);</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">    Set&lt;String&gt; valueSet = <span class="keyword">new</span> HashSet&lt;String&gt;();</span><br><span class="line">    valueSet.add(<span class="string">"one"</span>);</span><br><span class="line">    map.put(<span class="number">1</span>, valueSet);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// Java8的实现方式</span></span><br><span class="line">map.computeIfAbsent(<span class="number">1</span>, v -&gt; <span class="keyword">new</span> HashSet&lt;String&gt;()).add(<span class="string">"yi"</span>);</span><br></pre></td></tr></table></figure>
<p>使用<code>computeIfAbsent()</code>将条件判断和添加操作合二为一，使代码更加简洁．</p>
<h3 id="computeIfPresent"><a href="#computeIfPresent" class="headerlink" title="computeIfPresent()"></a>computeIfPresent()</h3><p>该方法签名为<code>V computeIfPresent(K key, BiFunction&lt;? super K,? super V,? extends V&gt; remappingFunction)</code>，作用跟<code>computeIfAbsent()</code>相反，即，只有在当前<code>Map</code>中<strong>存在<code>key</code>值的映射且非<code>null</code>时</strong>，才调用<code>remappingFunction</code>，如果<code>remappingFunction</code>执行结果为<code>null</code>，则删除<code>key</code>的映射，否则使用该结果替换<code>key</code>原来的映射．</p>
<p>这个函数的功能跟如下代码是等效的：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Java7及以前跟computeIfPresent()等效的代码</span></span><br><span class="line"><span class="keyword">if</span> (map.get(key) != <span class="keyword">null</span>) &#123;</span><br><span class="line">    V oldValue = map.get(key);</span><br><span class="line">    V newValue = remappingFunction.apply(key, oldValue);</span><br><span class="line">    <span class="keyword">if</span> (newValue != <span class="keyword">null</span>)</span><br><span class="line">        map.put(key, newValue);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        map.remove(key);</span><br><span class="line">    <span class="keyword">return</span> newValue;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">null</span>;</span><br></pre></td></tr></table></figure>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ol>
<li>Java8为容器新增一些有用的方法，这些方法有些是为<strong>完善原有功能</strong>，有些是为<strong>引入函数式编程</strong>，学习和使用这些方法有助于我们写出更加简洁有效的代码．</li>
<li><strong>函数接口</strong>虽然很多，但绝大多数时候我们根本不需要知道它们的名字，书写Lambda表达式时类型推断帮我们做了一切．</li>
</ol>
<h1 id="Lambda-and-Collections-1"><a href="#Lambda-and-Collections-1" class="headerlink" title="Lambda and Collections"></a>Lambda and Collections</h1><p>[TOC]</p>
<h2 id="前言-2"><a href="#前言-2" class="headerlink" title="前言"></a>前言</h2><p>我们先从最熟悉的<em>Java集合框架(Java Collections Framework, JCF)</em>开始说起。</p>
<p>为引入Lambda表达式，Java8新增了<code>java.util.function</code>包，里面包含常用的<strong>函数接口</strong>，这是Lambda表达式的基础，Java集合框架也新增部分接口，以便与Lambda表达式对接。</p>
<p>首先回顾一下Java集合框架的接口继承结构：</p>
<p><img src="./Figures/JCF_Collection_Interfaces.png" alt="JCF_Collection_Interfaces"></p>
<p>上图中绿色标注的接口类，表示在Java8中加入了新的接口方法，当然由于继承关系，他们相应的子类也都会继承这些新方法。下表详细列举了这些方法。</p>
<table>
<thead>
<tr>
<th>接口名</th>
<th>Java8新加入的方法</th>
</tr>
</thead>
<tbody>
<tr>
<td>Collection</td>
<td>removeIf() spliterator() stream() parallelStream() forEach()</td>
</tr>
<tr>
<td>List</td>
<td>replaceAll() sort()</td>
</tr>
<tr>
<td>Map</td>
<td>getOrDefault() forEach() replaceAll() putIfAbsent() remove() replace() computeIfAbsent() computeIfPresent() compute() merge()</td>
</tr>
</tbody>
</table>
<p>这些新加入的方法大部分要用到<code>java.util.function</code>包下的接口，这意味着这些方法大部分都跟Lambda表达式相关。我们将逐一学习这些方法。</p>
<h2 id="Collection中的新方法-1"><a href="#Collection中的新方法-1" class="headerlink" title="Collection中的新方法"></a>Collection中的新方法</h2><p>如上所示，接口<code>Collection</code>和<code>List</code>新加入了一些方法，我们以是<code>List</code>的子类<code>ArrayList</code>为例来说明。了解<a href="https://github.com/CarpenterLee/JCFInternals/blob/master/markdown/2-ArrayList.md" target="_blank" rel="noopener">Java7<code>ArrayList</code>实现原理</a>，将有助于理解下文。</p>
<h3 id="forEach-2"><a href="#forEach-2" class="headerlink" title="forEach()"></a>forEach()</h3><p>该方法的签名为<code>void forEach(Consumer&lt;? super E&gt; action)</code>，作用是对容器中的每个元素执行<code>action</code>指定的动作，其中<code>Consumer</code>是个函数接口，里面只有一个待实现方法<code>void accept(T t)</code>（后面我们会看到，这个方法叫什么根本不重要，你甚至不需要记忆它的名字）。</p>
<p>需求：<em>假设有一个字符串列表，需要打印出其中所有长度大于3的字符串.</em></p>
<p>Java7及以前我们可以用增强的for循环实现：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 使用曾强for循环迭代</span></span><br><span class="line">ArrayList&lt;String&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;(Arrays.asList(<span class="string">"I"</span>, <span class="string">"love"</span>, <span class="string">"you"</span>, <span class="string">"too"</span>));</span><br><span class="line"><span class="keyword">for</span>(String str : list)&#123;</span><br><span class="line">    <span class="keyword">if</span>(str.length()&gt;<span class="number">3</span>)</span><br><span class="line">        System.out.println(str);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>现在使用<code>forEach()</code>方法结合匿名内部类，可以这样实现：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 使用forEach()结合匿名内部类迭代</span></span><br><span class="line">ArrayList&lt;String&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;(Arrays.asList(<span class="string">"I"</span>, <span class="string">"love"</span>, <span class="string">"you"</span>, <span class="string">"too"</span>));</span><br><span class="line">list.forEach(<span class="keyword">new</span> Consumer&lt;String&gt;()&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">accept</span><span class="params">(String str)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(str.length()&gt;<span class="number">3</span>)</span><br><span class="line">            System.out.println(str);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>上述代码调用<code>forEach()</code>方法，并使用匿名内部类实现<code>Comsumer</code>接口。到目前为止我们没看到这种设计有什么好处，但是不要忘记Lambda表达式，使用Lambda表达式实现如下：<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 使用forEach()结合Lambda表达式迭代</span></span><br><span class="line">ArrayList&lt;String&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;(Arrays.asList(<span class="string">"I"</span>, <span class="string">"love"</span>, <span class="string">"you"</span>, <span class="string">"too"</span>));</span><br><span class="line">list.forEach( str -&gt; &#123;</span><br><span class="line">        <span class="keyword">if</span>(str.length()&gt;<span class="number">3</span>)</span><br><span class="line">            System.out.println(str);</span><br><span class="line">    &#125;);</span><br></pre></td></tr></table></figure></p>
<p>上述代码给<code>forEach()</code>方法传入一个Lambda表达式，我们不需要知道<code>accept()</code>方法，也不需要知道<code>Consumer</code>接口，类型推导帮我们做了一切。</p>
<h3 id="removeIf-1"><a href="#removeIf-1" class="headerlink" title="removeIf()"></a>removeIf()</h3><p>该方法签名为<code>boolean removeIf(Predicate&lt;? super E&gt; filter)</code>，作用是<strong>删除容器中所有满足<code>filter</code>指定条件的元素</strong>，其中<code>Predicate</code>是一个函数接口，里面只有一个待实现方法<code>boolean test(T t)</code>，同样的这个方法的名字根本不重要，因为用的时候不需要书写这个名字。</p>
<p>需求：<em>假设有一个字符串列表，需要删除其中所有长度大于3的字符串。</em></p>
<p>我们知道如果需要在迭代过程冲对容器进行删除操作必须使用迭代器，否则会抛出<code>ConcurrentModificationException</code>，所以上述任务传统的写法是：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 使用迭代器删除列表元素</span></span><br><span class="line">ArrayList&lt;String&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;(Arrays.asList(<span class="string">"I"</span>, <span class="string">"love"</span>, <span class="string">"you"</span>, <span class="string">"too"</span>));</span><br><span class="line">Iterator&lt;String&gt; it = list.iterator();</span><br><span class="line"><span class="keyword">while</span>(it.hasNext())&#123;</span><br><span class="line">    <span class="keyword">if</span>(it.next().length()&gt;<span class="number">3</span>) <span class="comment">// 删除长度大于3的元素</span></span><br><span class="line">        it.remove();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>现在使用<code>removeIf()</code>方法结合匿名内部类，我们可是这样实现：<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 使用removeIf()结合匿名名内部类实现</span></span><br><span class="line">ArrayList&lt;String&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;(Arrays.asList(<span class="string">"I"</span>, <span class="string">"love"</span>, <span class="string">"you"</span>, <span class="string">"too"</span>));</span><br><span class="line">list.removeIf(<span class="keyword">new</span> Predicate&lt;String&gt;()&#123; <span class="comment">// 删除长度大于3的元素</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">test</span><span class="params">(String str)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> str.length()&gt;<span class="number">3</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p>
<p>上述代码使用<code>removeIf()</code>方法，并使用匿名内部类实现<code>Precicate</code>接口。相信你已经想到用Lambda表达式该怎么写了：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 使用removeIf()结合Lambda表达式实现</span></span><br><span class="line">ArrayList&lt;String&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;(Arrays.asList(<span class="string">"I"</span>, <span class="string">"love"</span>, <span class="string">"you"</span>, <span class="string">"too"</span>));</span><br><span class="line">list.removeIf(str -&gt; str.length()&gt;<span class="number">3</span>); <span class="comment">// 删除长度大于3的元素</span></span><br></pre></td></tr></table></figure>
<p>使用Lambda表达式不需要记忆<code>Predicate</code>接口名，也不需要记忆<code>test()</code>方法名，只需要知道此处需要一个返回布尔类型的Lambda表达式就行了。</p>
<h3 id="replaceAll-2"><a href="#replaceAll-2" class="headerlink" title="replaceAll()"></a>replaceAll()</h3><p>该方法签名为<code>void replaceAll(UnaryOperator&lt;E&gt; operator)</code>，作用是<strong>对每个元素执行<code>operator</code>指定的操作，并用操作结果来替换原来的元素</strong>。其中<code>UnaryOperator</code>是一个函数接口，里面只有一个待实现函数<code>T apply(T t)</code>。</p>
<p>需求：<em>假设有一个字符串列表，将其中所有长度大于3的元素转换成大写，其余元素不变。</em></p>
<p>Java7及之前似乎没有优雅的办法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 使用下标实现元素替换</span></span><br><span class="line">ArrayList&lt;String&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;(Arrays.asList(<span class="string">"I"</span>, <span class="string">"love"</span>, <span class="string">"you"</span>, <span class="string">"too"</span>));</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;list.size(); i++)&#123;</span><br><span class="line">    String str = list.get(i);</span><br><span class="line">    <span class="keyword">if</span>(str.length()&gt;<span class="number">3</span>)</span><br><span class="line">        list.set(i, str.toUpperCase());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>使用<code>replaceAll()</code>方法结合匿名内部类可以实现如下：<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 使用匿名内部类实现</span></span><br><span class="line">ArrayList&lt;String&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;(Arrays.asList(<span class="string">"I"</span>, <span class="string">"love"</span>, <span class="string">"you"</span>, <span class="string">"too"</span>));</span><br><span class="line">list.replaceAll(<span class="keyword">new</span> UnaryOperator&lt;String&gt;()&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">apply</span><span class="params">(String str)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(str.length()&gt;<span class="number">3</span>)</span><br><span class="line">            <span class="keyword">return</span> str.toUpperCase();</span><br><span class="line">        <span class="keyword">return</span> str;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p>
<p>上述代码调用<code>replaceAll()</code>方法，并使用匿名内部类实现<code>UnaryOperator</code>接口。我们知道可以用更为简洁的Lambda表达式实现：<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 使用Lambda表达式实现</span></span><br><span class="line">ArrayList&lt;String&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;(Arrays.asList(<span class="string">"I"</span>, <span class="string">"love"</span>, <span class="string">"you"</span>, <span class="string">"too"</span>));</span><br><span class="line">list.replaceAll(str -&gt; &#123;</span><br><span class="line">    <span class="keyword">if</span>(str.length()&gt;<span class="number">3</span>)</span><br><span class="line">        <span class="keyword">return</span> str.toUpperCase();</span><br><span class="line">    <span class="keyword">return</span> str;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p>
<h3 id="sort-1"><a href="#sort-1" class="headerlink" title="sort()"></a>sort()</h3><p>该方法定义在<code>List</code>接口中，方法签名为<code>void sort(Comparator&lt;? super E&gt; c)</code>，该方法<strong>根据<code>c</code>指定的比较规则对容器元素进行排序</strong>。<code>Comparator</code>接口我们并不陌生，其中有一个方法<code>int compare(T o1, T o2)</code>需要实现，显然该接口是个函数接口。</p>
<p>需求：<em>假设有一个字符串列表，按照字符串长度增序对元素排序。</em></p>
<p>由于Java7以及之前<code>sort()</code>方法在<code>Collections</code>工具类中，所以代码要这样写：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Collections.sort()方法</span></span><br><span class="line">ArrayList&lt;String&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;(Arrays.asList(<span class="string">"I"</span>, <span class="string">"love"</span>, <span class="string">"you"</span>, <span class="string">"too"</span>));</span><br><span class="line">Collections.sort(list, <span class="keyword">new</span> Comparator&lt;String&gt;()&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compare</span><span class="params">(String str1, String str2)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> str1.length()-str2.length();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>现在可以直接使用<code>List.sort()方法</code>，结合Lambda表达式，可以这样写：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// List.sort()方法结合Lambda表达式</span></span><br><span class="line">ArrayList&lt;String&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;(Arrays.asList(<span class="string">"I"</span>, <span class="string">"love"</span>, <span class="string">"you"</span>, <span class="string">"too"</span>));</span><br><span class="line">list.sort((str1, str2) -&gt; str1.length()-str2.length());</span><br></pre></td></tr></table></figure>
<h3 id="spliterator-1"><a href="#spliterator-1" class="headerlink" title="spliterator()"></a>spliterator()</h3><p>方法签名为<code>Spliterator&lt;E&gt; spliterator()</code>，该方法返回容器的<strong>可拆分迭代器</strong>。从名字来看该方法跟<code>iterator()</code>方法有点像，我们知道<code>Iterator</code>是用来迭代容器的，<code>Spliterator</code>也有类似作用，但二者有如下不同：</p>
<ol>
<li><code>Spliterator</code>既可以像<code>Iterator</code>那样逐个迭代，也可以批量迭代。批量迭代可以降低迭代的开销。</li>
<li><code>Spliterator</code>是可拆分的，一个<code>Spliterator</code>可以通过调用<code>Spliterator&lt;T&gt; trySplit()</code>方法来尝试分成两个。一个是<code>this</code>，另一个是新返回的那个，这两个迭代器代表的元素没有重叠。</li>
</ol>
<p>可通过（多次）调用<code>Spliterator.trySplit()</code>方法来分解负载，以便多线程处理。</p>
<h3 id="stream-和parallelStream-1"><a href="#stream-和parallelStream-1" class="headerlink" title="stream()和parallelStream()"></a>stream()和parallelStream()</h3><p><code>stream()</code>和<code>parallelStream()</code>分别<strong>返回该容器的<code>Stream</code>视图表示</strong>，不同之处在于<code>parallelStream()</code>返回并行的<code>Stream</code>。<strong><code>Stream</code>是Java函数式编程的核心类</strong>，我们会在后面章节中学习。</p>
<h2 id="Map中的新方法-1"><a href="#Map中的新方法-1" class="headerlink" title="Map中的新方法"></a>Map中的新方法</h2><p>相比<code>Collection</code>，<code>Map</code>中加入了更多的方法，我们以<code>HashMap</code>为例来逐一探秘。了解<a href="https://github.com/CarpenterLee/JCFInternals/blob/master/markdown/6-HashSet%20and%20HashMap.md" target="_blank" rel="noopener">Java7<code>HashMap</code>实现原理</a>，将有助于理解下文。</p>
<h3 id="forEach-3"><a href="#forEach-3" class="headerlink" title="forEach()"></a>forEach()</h3><p>该方法签名为<code>void forEach(BiConsumer&lt;? super K,? super V&gt; action)</code>，作用是<strong>对<code>Map</code>中的每个映射执行<code>action</code>指定的操作</strong>，其中<code>BiConsumer</code>是一个函数接口，里面有一个待实现方法<code>void accept(T t, U u)</code>。<code>BinConsumer</code>接口名字和<code>accept()</code>方法名字都不重要，请不要记忆他们。</p>
<p>需求：<em>假设有一个数字到对应英文单词的Map，请输出Map中的所有映射关系．</em></p>
<p>Java7以及之前经典的代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Java7以及之前迭代Map</span></span><br><span class="line">HashMap&lt;Integer, String&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">map.put(<span class="number">1</span>, <span class="string">"one"</span>);</span><br><span class="line">map.put(<span class="number">2</span>, <span class="string">"two"</span>);</span><br><span class="line">map.put(<span class="number">3</span>, <span class="string">"three"</span>);</span><br><span class="line"><span class="keyword">for</span>(Map.Entry&lt;Integer, String&gt; entry : map.entrySet())&#123;</span><br><span class="line">    System.out.println(entry.getKey() + <span class="string">"="</span> + entry.getValue());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>使用<code>Map.forEach()</code>方法，结合匿名内部类，代码如下：<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 使用forEach()结合匿名内部类迭代Map</span></span><br><span class="line">HashMap&lt;Integer, String&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">map.put(<span class="number">1</span>, <span class="string">"one"</span>);</span><br><span class="line">map.put(<span class="number">2</span>, <span class="string">"two"</span>);</span><br><span class="line">map.put(<span class="number">3</span>, <span class="string">"three"</span>);</span><br><span class="line">map.forEach(<span class="keyword">new</span> BiConsumer&lt;Integer, String&gt;()&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">accept</span><span class="params">(Integer k, String v)</span></span>&#123;</span><br><span class="line">        System.out.println(k + <span class="string">"="</span> + v);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p>
<p>上述代码调用<code>forEach()</code>方法，并使用匿名内部类实现<code>BiConsumer</code>接口。当然，实际场景中没人使用匿名内部类写法，因为有Lambda表达式：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 使用forEach()结合Lambda表达式迭代Map</span></span><br><span class="line">HashMap&lt;Integer, String&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">map.put(<span class="number">1</span>, <span class="string">"one"</span>);</span><br><span class="line">map.put(<span class="number">2</span>, <span class="string">"two"</span>);</span><br><span class="line">map.put(<span class="number">3</span>, <span class="string">"three"</span>);</span><br><span class="line">map.forEach((k, v) -&gt; System.out.println(k + <span class="string">"="</span> + v));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="getOrDefault-1"><a href="#getOrDefault-1" class="headerlink" title="getOrDefault()"></a>getOrDefault()</h3><p>该方法跟Lambda表达式没关系，但是很有用。方法签名为<code>V getOrDefault(Object key, V defaultValue)</code>，作用是<strong>按照给定的<code>key</code>查询<code>Map</code>中对应的<code>value</code>，如果没有找到则返回<code>defaultValue</code></strong>。使用该方法程序员可以省去查询指定键值是否存在的麻烦．</p>
<p>需求；<em>假设有一个数字到对应英文单词的Map，输出4对应的英文单词，如果不存在则输出NoValue</em></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 查询Map中指定的值，不存在时使用默认值</span></span><br><span class="line">HashMap&lt;Integer, String&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">map.put(<span class="number">1</span>, <span class="string">"one"</span>);</span><br><span class="line">map.put(<span class="number">2</span>, <span class="string">"two"</span>);</span><br><span class="line">map.put(<span class="number">3</span>, <span class="string">"three"</span>);</span><br><span class="line"><span class="comment">// Java7以及之前做法</span></span><br><span class="line"><span class="keyword">if</span>(map.containsKey(<span class="number">4</span>))&#123; <span class="comment">// 1</span></span><br><span class="line">    System.out.println(map.get(<span class="number">4</span>));</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">    System.out.println(<span class="string">"NoValue"</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// Java8使用Map.getOrDefault()</span></span><br><span class="line">System.out.println(map.getOrDefault(<span class="number">4</span>, <span class="string">"NoValue"</span>)); <span class="comment">// 2</span></span><br></pre></td></tr></table></figure>
<h3 id="putIfAbsent-1"><a href="#putIfAbsent-1" class="headerlink" title="putIfAbsent()"></a>putIfAbsent()</h3><p>该方法跟Lambda表达式没关系，但是很有用。方法签名为<code>V putIfAbsent(K key, V value)</code>，作用是只有在<strong>不存在<code>key</code>值的映射或映射值为<code>null</code>时</strong>，才将<code>value</code>指定的值放入到<code>Map</code>中，否则不对<code>Map</code>做更改．该方法将条件判断和赋值合二为一，使用起来更加方便．</p>
<h3 id="remove-1"><a href="#remove-1" class="headerlink" title="remove()"></a>remove()</h3><p>我们都知道<code>Map</code>中有一个<code>remove(Object key)</code>方法，来根据指定<code>key</code>值删除<code>Map</code>中的映射关系；Java8新增了<code>remove(Object key, Object value)</code>方法，只有在当前<code>Map</code>中<strong><code>key</code>正好映射到<code>value</code>时</strong>才删除该映射，否则什么也不做．</p>
<h3 id="replace-1"><a href="#replace-1" class="headerlink" title="replace()"></a>replace()</h3><p>在Java7及以前，要想替换<code>Map</code>中的映射关系可通过<code>put(K key, V value)</code>方法实现，该方法总是会用新值替换原来的值．为了更精确的控制替换行为，Java8在<code>Map</code>中加入了两个<code>replace()</code>方法，分别如下：</p>
<ul>
<li><code>replace(K key, V value)</code>，只有在当前<code>Map</code>中<strong><code>key</code>的映射存在时</strong>才用<code>value</code>去替换原来的值，否则什么也不做．</li>
<li><code>replace(K key, V oldValue, V newValue)</code>，只有在当前<code>Map</code>中<strong><code>key</code>的映射存在且等于<code>oldValue</code>时</strong>才用<code>newValue</code>去替换原来的值，否则什么也不做．</li>
</ul>
<h3 id="replaceAll-3"><a href="#replaceAll-3" class="headerlink" title="replaceAll()"></a>replaceAll()</h3><p>该方法签名为<code>replaceAll(BiFunction&lt;? super K,? super V,? extends V&gt; function)</code>，作用是对<code>Map</code>中的每个映射执行<code>function</code>指定的操作，并用<code>function</code>的执行结果替换原来的<code>value</code>，其中<code>BiFunction</code>是一个函数接口，里面有一个待实现方法<code>R apply(T t, U u)</code>．不要被如此多的函数接口吓到，因为使用的时候根本不需要知道他们的名字．</p>
<p>需求：<em>假设有一个数字到对应英文单词的Map，请将原来映射关系中的单词都转换成大写．</em></p>
<p>Java7以及之前经典的代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Java7以及之前替换所有Map中所有映射关系</span></span><br><span class="line">HashMap&lt;Integer, String&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">map.put(<span class="number">1</span>, <span class="string">"one"</span>);</span><br><span class="line">map.put(<span class="number">2</span>, <span class="string">"two"</span>);</span><br><span class="line">map.put(<span class="number">3</span>, <span class="string">"three"</span>);</span><br><span class="line"><span class="keyword">for</span>(Map.Entry&lt;Integer, String&gt; entry : map.entrySet())&#123;</span><br><span class="line">    entry.setValue(entry.getValue().toUpperCase());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>使用<code>replaceAll()</code>方法结合匿名内部类，实现如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 使用replaceAll()结合匿名内部类实现</span></span><br><span class="line">HashMap&lt;Integer, String&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">map.put(<span class="number">1</span>, <span class="string">"one"</span>);</span><br><span class="line">map.put(<span class="number">2</span>, <span class="string">"two"</span>);</span><br><span class="line">map.put(<span class="number">3</span>, <span class="string">"three"</span>);</span><br><span class="line">map.replaceAll(<span class="keyword">new</span> BiFunction&lt;Integer, String, String&gt;()&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">apply</span><span class="params">(Integer k, String v)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> v.toUpperCase();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>上述代码调用<code>replaceAll()</code>方法，并使用匿名内部类实现<code>BiFunction</code>接口。更进一步的，使用Lambda表达式实现如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 使用replaceAll()结合Lambda表达式实现</span></span><br><span class="line">HashMap&lt;Integer, String&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">map.put(<span class="number">1</span>, <span class="string">"one"</span>);</span><br><span class="line">map.put(<span class="number">2</span>, <span class="string">"two"</span>);</span><br><span class="line">map.put(<span class="number">3</span>, <span class="string">"three"</span>);</span><br><span class="line">map.replaceAll((k, v) -&gt; v.toUpperCase());</span><br></pre></td></tr></table></figure>
<p>简洁到让人难以置信．</p>
<h3 id="merge-1"><a href="#merge-1" class="headerlink" title="merge()"></a>merge()</h3><p>该方法签名为<code>merge(K key, V value, BiFunction&lt;? super V,? super V,? extends V&gt; remappingFunction)</code>，作用是：</p>
<ol>
<li>如果<code>Map</code>中<code>key</code>对应的映射不存在或者为<code>null</code>，则将<code>value</code>（不能是<code>null</code>）关联到<code>key</code>上；</li>
<li>否则执行<code>remappingFunction</code>，如果执行结果非<code>null</code>则用该结果跟<code>key</code>关联，否则在<code>Map</code>中删除<code>key</code>的映射．</li>
</ol>
<p>参数中<code>BiFunction</code>函数接口前面已经介绍过，里面有一个待实现方法<code>R apply(T t, U u)</code>．</p>
<p><code>merge()</code>方法虽然语义有些复杂，但该方法的用方式很明确，一个比较常见的场景是将新的错误信息拼接到原来的信息上，比如：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">map.merge(key, newMsg, (v1, v2) -&gt; v1+v2);</span><br></pre></td></tr></table></figure>
<h3 id="compute-1"><a href="#compute-1" class="headerlink" title="compute()"></a>compute()</h3><p>该方法签名为<code>compute(K key, BiFunction&lt;? super K,? super V,? extends V&gt; remappingFunction)</code>，作用是把<code>remappingFunction</code>的计算结果关联到<code>key</code>上，如果计算结果为<code>null</code>，则在<code>Map</code>中删除<code>key</code>的映射．</p>
<p>要实现上述<code>merge()</code>方法中错误信息拼接的例子，使用<code>compute()</code>代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">map.compute(key, (k,v) -&gt; v==<span class="keyword">null</span> ? newMsg : v.concat(newMsg));</span><br></pre></td></tr></table></figure>
<h3 id="computeIfAbsent-1"><a href="#computeIfAbsent-1" class="headerlink" title="computeIfAbsent()"></a>computeIfAbsent()</h3><p>该方法签名为<code>V computeIfAbsent(K key, Function&lt;? super K,? extends V&gt; mappingFunction)</code>，作用是：只有在当前<code>Map</code>中<strong>不存在<code>key</code>值的映射或映射值为<code>null</code>时</strong>，才调用<code>mappingFunction</code>，并在<code>mappingFunction</code>执行结果非<code>null</code>时，将结果跟<code>key</code>关联．</p>
<p><code>Function</code>是一个函数接口，里面有一个待实现方法<code>R apply(T t)</code>．</p>
<p><code>computeIfAbsent()</code>常用来对<code>Map</code>的某个<code>key</code>值建立初始化映射．比如我们要实现一个多值映射，<code>Map</code>的定义可能是<code>Map&lt;K,Set&lt;V&gt;&gt;</code>，要向<code>Map</code>中放入新值，可通过如下代码实现：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Map&lt;Integer, Set&lt;String&gt;&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line"><span class="comment">// Java7及以前的实现方式</span></span><br><span class="line"><span class="keyword">if</span>(map.containsKey(<span class="number">1</span>))&#123;</span><br><span class="line">    map.get(<span class="number">1</span>).add(<span class="string">"one"</span>);</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">    Set&lt;String&gt; valueSet = <span class="keyword">new</span> HashSet&lt;String&gt;();</span><br><span class="line">    valueSet.add(<span class="string">"one"</span>);</span><br><span class="line">    map.put(<span class="number">1</span>, valueSet);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// Java8的实现方式</span></span><br><span class="line">map.computeIfAbsent(<span class="number">1</span>, v -&gt; <span class="keyword">new</span> HashSet&lt;String&gt;()).add(<span class="string">"yi"</span>);</span><br></pre></td></tr></table></figure>
<p>使用<code>computeIfAbsent()</code>将条件判断和添加操作合二为一，使代码更加简洁．</p>
<h3 id="computeIfPresent-1"><a href="#computeIfPresent-1" class="headerlink" title="computeIfPresent()"></a>computeIfPresent()</h3><p>该方法签名为<code>V computeIfPresent(K key, BiFunction&lt;? super K,? super V,? extends V&gt; remappingFunction)</code>，作用跟<code>computeIfAbsent()</code>相反，即，只有在当前<code>Map</code>中<strong>存在<code>key</code>值的映射且非<code>null</code>时</strong>，才调用<code>remappingFunction</code>，如果<code>remappingFunction</code>执行结果为<code>null</code>，则删除<code>key</code>的映射，否则使用该结果替换<code>key</code>原来的映射．</p>
<p>这个函数的功能跟如下代码是等效的：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Java7及以前跟computeIfPresent()等效的代码</span></span><br><span class="line"><span class="keyword">if</span> (map.get(key) != <span class="keyword">null</span>) &#123;</span><br><span class="line">    V oldValue = map.get(key);</span><br><span class="line">    V newValue = remappingFunction.apply(key, oldValue);</span><br><span class="line">    <span class="keyword">if</span> (newValue != <span class="keyword">null</span>)</span><br><span class="line">        map.put(key, newValue);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        map.remove(key);</span><br><span class="line">    <span class="keyword">return</span> newValue;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">null</span>;</span><br></pre></td></tr></table></figure>
<h2 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h2><ol>
<li>Java8为容器新增一些有用的方法，这些方法有些是为<strong>完善原有功能</strong>，有些是为<strong>引入函数式编程</strong>，学习和使用这些方法有助于我们写出更加简洁有效的代码．</li>
<li><strong>函数接口</strong>虽然很多，但绝大多数时候我们根本不需要知道它们的名字，书写Lambda表达式时类型推断帮我们做了一切．</li>
</ol>
<h1 id="Streams-API-I"><a href="#Streams-API-I" class="headerlink" title="Streams API(I)"></a>Streams API(I)</h1><p>你可能没意识到Java对函数式编程的重视程度，看看Java 8加入函数式编程扩充多少功能就清楚了。Java 8之所以费这么大功夫引入函数式编程，原因有二：</p>
<ol>
<li><strong>代码简洁</strong>函数式编程写出的代码简洁且意图明确，使用<em>stream</em>接口让你从此告别<em>for</em>循环。</li>
<li><strong>多核友好</strong>，Java函数式编程使得编写并行程序从未如此简单，你需要的全部就是调用一下<code>parallel()</code>方法。</li>
</ol>
<p>这一节我们学习<em>stream</em>，也就是Java函数式编程的主角。对于Java 7来说<em>stream</em>完全是个陌生东西，<em>stream</em>并不是某种数据结构，它只是数据源的一种视图。这里的数据源可以是一个数组，Java容器或I/O channel等。正因如此要得到一个<em>stream</em>通常不会手动创建，而是调用对应的工具方法，比如：</p>
<ul>
<li>调用<code>Collection.stream()</code>或者<code>Collection.parallelStream()</code>方法</li>
<li>调用<code>Arrays.stream(T[] array)</code>方法</li>
</ul>
<p>常见的<em>stream</em>接口继承关系如图：</p>
<p><img src="./Figures/Java_stream_Interfaces.png" width="500px" align="left" alt="Java_stream_Interfaces"></p>
<p>图中4种<em>stream</em>接口继承自<code>BaseStream</code>，其中<code>IntStream, LongStream, DoubleStream</code>对应三种基本类型（<code>int, long, double</code>，注意不是包装类型），<code>Stream</code>对应所有剩余类型的<em>stream</em>视图。为不同数据类型设置不同<em>stream</em>接口，可以1.提高性能，2.增加特定接口函数。</p>
<p><br></p>
<p><img src="./Figures/WRONG_Java_stream_Interfaces.png" width="400px" align="right" alt="WRONG_Java_stream_Interfaces"></p>
<p>你可能会奇怪为什么不把<code>IntStream</code>等设计成<code>Stream</code>的子接口？毕竟这接口中的方法名大部分是一样的。答案是这些方法的名字虽然相同，但是返回类型不同，如果设计成父子接口关系，这些方法将不能共存，因为Java不允许只有返回类型不同的方法重载。</p>
<p>虽然大部分情况下<em>stream</em>是容器调用<code>Collection.stream()</code>方法得到的，但<em>stream</em>和<em>collections</em>有以下不同：</p>
<ul>
<li><strong>无存储</strong>。<em>stream</em>不是一种数据结构，它只是某种数据源的一个视图，数据源可以是一个数组，Java容器或I/O channel等。</li>
<li><strong>为函数式编程而生</strong>。对<em>stream</em>的任何修改都不会修改背后的数据源，比如对<em>stream</em>执行过滤操作并不会删除被过滤的元素，而是会产生一个不包含被过滤元素的新<em>stream</em>。</li>
<li><strong>惰式执行</strong>。<em>stream</em>上的操作并不会立即执行，只有等到用户真正需要结果的时候才会执行。</li>
<li><strong>可消费性</strong>。<em>stream</em>只能被“消费”一次，一旦遍历过就会失效，就像容器的迭代器那样，想要再次遍历必须重新生成。</li>
</ul>
<p>对<em>stream</em>的操作分为为两类，<strong>中间操作(<em>intermediate operations</em>)和结束操作(<em>terminal operations</em>)</strong>，二者特点是：</p>
<ol>
<li><strong>中间操作总是会惰式执行</strong>，调用中间操作只会生成一个标记了该操作的新<em>stream</em>，仅此而已。</li>
<li><strong>结束操作会触发实际计算</strong>，计算发生时会把所有中间操作积攒的操作以<em>pipeline</em>的方式执行，这样可以减少迭代次数。计算完成之后<em>stream</em>就会失效。</li>
</ol>
<p>如果你熟悉Apache Spark RDD，对<em>stream</em>的这个特点应该不陌生。</p>
<p>下表汇总了<code>Stream</code>接口的部分常见方法：</p>
<table>
<thead>
<tr>
<th>操作类型</th>
<th>接口方法</th>
</tr>
</thead>
<tbody>
<tr>
<td>中间操作</td>
<td>concat() distinct() filter() flatMap() limit() map() peek() <br> skip() sorted() parallel() sequential() unordered()</td>
</tr>
<tr>
<td>结束操作</td>
<td>allMatch() anyMatch() collect() count() findAny() findFirst() <br> forEach() forEachOrdered() max() min() noneMatch() reduce() toArray()</td>
</tr>
</tbody>
</table>
<p>区分中间操作和结束操作最简单的方法，就是看方法的返回值，返回值为<em>stream</em>的大都是中间操作，否则是结束操作。</p>
<h2 id="stream方法使用"><a href="#stream方法使用" class="headerlink" title="stream方法使用"></a>stream方法使用</h2><p><em>stream</em>跟函数接口关系非常紧密，没有函数接口<em>stream</em>就无法工作。回顾一下：<strong>函数接口是指内部只有一个抽象方法的接口</strong>。通常函数接口出现的地方都可以使用Lambda表达式，所以不必记忆函数接口的名字。</p>
<h3 id="forEach-4"><a href="#forEach-4" class="headerlink" title="forEach()"></a>forEach()</h3><p>我们对<code>forEach()</code>方法并不陌生，在<code>Collection</code>中我们已经见过。方法签名为<code>void forEach(Consumer&lt;? super E&gt; action)</code>，作用是对容器中的每个元素执行<code>action</code>指定的动作，也就是对元素进行遍历。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 使用Stream.forEach()迭代</span></span><br><span class="line">Stream&lt;String&gt; stream = Stream.of(<span class="string">"I"</span>, <span class="string">"love"</span>, <span class="string">"you"</span>, <span class="string">"too"</span>);</span><br><span class="line">stream.forEach(str -&gt; System.out.println(str));</span><br></pre></td></tr></table></figure>
<p>由于<code>forEach()</code>是结束方法，上述代码会立即执行，输出所有字符串。</p>
<h3 id="filter"><a href="#filter" class="headerlink" title="filter()"></a>filter()</h3><p><img src="./Figures/Stream.filter.png" width="250px" align="right" hspace="10px" alt="Stream filter"></p>
<p>函数原型为<code>Stream&lt;T&gt; filter(Predicate&lt;? super T&gt; predicate)</code>，作用是返回一个只包含满足<code>predicate</code>条件元素的<code>Stream</code>。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 保留长度等于3的字符串</span></span><br><span class="line">Stream&lt;String&gt; stream= Stream.of(<span class="string">"I"</span>, <span class="string">"love"</span>, <span class="string">"you"</span>, <span class="string">"too"</span>);</span><br><span class="line">stream.filter(str -&gt; str.length()==<span class="number">3</span>)</span><br><span class="line">    .forEach(str -&gt; System.out.println(str));</span><br></pre></td></tr></table></figure>
<p>上述代码将输出为长度等于3的字符串<code>you</code>和<code>too</code>。注意，由于<code>filter()</code>是个中间操作，如果只调用<code>filter()</code>不会有实际计算，因此也不会输出任何信息。</p>
<h3 id="distinct"><a href="#distinct" class="headerlink" title="distinct()"></a>distinct()</h3><p><img src="./Figures/Stream.distinct.png" width="200px" align="left" hspace="10px" alt="Stream distinct"></p>
<p>函数原型为<code>Stream&lt;T&gt; distinct()</code>，作用是返回一个去除重复元素之后的<code>Stream</code>。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Stream&lt;String&gt; stream= Stream.of(<span class="string">"I"</span>, <span class="string">"love"</span>, <span class="string">"you"</span>, <span class="string">"too"</span>, <span class="string">"too"</span>);</span><br><span class="line">stream.distinct()</span><br><span class="line">    .forEach(str -&gt; System.out.println(str));</span><br></pre></td></tr></table></figure>
<p>上述代码会输出去掉一个<code>too</code>之后的其余字符串。</p>
<p><br><br></p>
<h3 id="sorted"><a href="#sorted" class="headerlink" title="sorted()"></a>sorted()</h3><p>排序函数有两个，一个是用自然顺序排序，一个是使用自定义比较器排序，函数原型分别为<code>Stream&lt;T&gt;　sorted()</code>和<code>Stream&lt;T&gt;　sorted(Comparator&lt;? super T&gt; comparator)</code>。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Stream&lt;String&gt; stream= Stream.of(<span class="string">"I"</span>, <span class="string">"love"</span>, <span class="string">"you"</span>, <span class="string">"too"</span>);</span><br><span class="line">stream.sorted((str1, str2) -&gt; str1.length()-str2.length())</span><br><span class="line">    .forEach(str -&gt; System.out.println(str));</span><br></pre></td></tr></table></figure>
<p>上述代码将输出按照长度升序排序后的字符串，结果完全在预料之中。</p>
<h3 id="map"><a href="#map" class="headerlink" title="map()"></a>map()</h3><p><img src="./Figures/Stream.map.png" width="250px" align="right" hspace="10px" alt="Stream map"></p>
<p>函数原型为<code>&lt;R&gt; Stream&lt;R&gt; map(Function&lt;? super T,? extends R&gt; mapper)</code>，作用是返回一个对当前所有元素执行执行<code>mapper</code>之后的结果组成的<code>Stream</code>。直观的说，就是对每个元素按照某种操作进行转换，转换前后<code>Stream</code>中元素的个数不会改变，但元素的类型取决于转换之后的类型。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Stream&lt;String&gt; stream　= Stream.of(<span class="string">"I"</span>, <span class="string">"love"</span>, <span class="string">"you"</span>, <span class="string">"too"</span>);</span><br><span class="line">stream.map(str -&gt; str.toUpperCase())</span><br><span class="line">    .forEach(str -&gt; System.out.println(str));</span><br></pre></td></tr></table></figure>
<p>上述代码将输出原字符串的大写形式。</p>
<h3 id="flatMap"><a href="#flatMap" class="headerlink" title="flatMap()"></a>flatMap()</h3><p><img src="./Figures/Stream.flatMap.png" width="300px" align="left" hspace="10px" alt="Stream flatMap"></p>
<p>函数原型为<code>&lt;R&gt; Stream&lt;R&gt; flatMap(Function&lt;? super T,? extends Stream&lt;? extends R&gt;&gt; mapper)</code>，作用是对每个元素执行<code>mapper</code>指定的操作，并用所有<code>mapper</code>返回的<code>Stream</code>中的元素组成一个新的<code>Stream</code>作为最终返回结果。说起来太拗口，通俗的讲<code>flatMap()</code>的作用就相当于把原<em>stream</em>中的所有元素都”摊平”之后组成的<code>Stream</code>，转换前后元素的个数和类型都可能会改变。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Stream&lt;List&lt;Integer&gt;&gt; stream = Stream.of(Arrays.asList(<span class="number">1</span>,<span class="number">2</span>), Arrays.asList(<span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>));</span><br><span class="line">stream.flatMap(list -&gt; list.stream())</span><br><span class="line">    .forEach(i -&gt; System.out.println(i));</span><br></pre></td></tr></table></figure>
<p>上述代码中，原来的<code>stream</code>中有两个元素，分别是两个<code>List&lt;Integer&gt;</code>，执行<code>flatMap()</code>之后，将每个<code>List</code>都“摊平”成了一个个的数字，所以会新产生一个由5个数字组成的<code>Stream</code>。所以最终将输出1~5这5个数字。</p>
<h2 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h2><p>截止到目前我们感觉良好，已介绍<code>Stream</code>接口函数理解起来并不费劲儿。如果你就此以为函数式编程不过如此，恐怕是高兴地太早了。下一节对<code>Stream</code>规约操作的介绍将刷新你现在的认识。</p>
]]></content>
      <categories>
        <category>文档资料</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>lambda</tag>
        <tag>java8</tag>
      </tags>
  </entry>
</search>
