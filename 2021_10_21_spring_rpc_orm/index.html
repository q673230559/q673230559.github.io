<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
    <meta name="keywords" content="Hexo Theme Keep">
    <meta name="description" content="零落成泥碾作尘，只有香如故！">
    <meta name="author" content="形而上">
    
    <title>
        
            Spring、rpc、orm常用框架总结 |
        
        Hanxd&#39;s Notes
    </title>
    
<link rel="stylesheet" href="/css/style.css">

    <link rel="shortcut icon" href="/pic/head.png">
    
<link rel="stylesheet" href="/css/font-awesome.min.css">

    <script id="hexo-configurations">
    let KEEP = window.KEEP || {};
    KEEP.hexo_config = {"hostname":"yoursite.com","root":"/","language":"zh-CN","path":"search.json"};
    KEEP.theme_config = {"toc":{"enable":true,"number":false,"expand_all":false,"init_open":true},"style":{"primary_color":"#FF7F00","avatar":"/pic/head.png","favicon":"/pic/head.png","article_img_align":"left","left_side_width":"260px","content_max_width":"920px","hover":{"shadow":false,"scale":false},"first_screen":{"enable":true,"background_img":"/images/bg.svg","description":"Still waters run deep."},"scroll":{"progress_bar":{"enable":false},"percent":{"enable":true}}},"local_search":{"enable":true,"preload":true},"code_copy":{"enable":true,"style":"default"},"pjax":{"enable":false},"lazyload":{"enable":false},"version":"3.4.3"};
    KEEP.language_ago = {"second":"%s 秒前","minute":"%s 分钟前","hour":"%s 小时前","day":"%s 天前","week":"%s 周前","month":"%s 月前","year":"%s 年前"};
  </script>
<meta name="generator" content="Hexo 5.4.2"></head>


<body>
<div class="progress-bar-container">
    

    
</div>


<main class="page-container">

    

    <div class="page-main-content">

        <div class="page-main-content-top">
            <header class="header-wrapper">

    <div class="header-content">
        <div class="left">
            
            <a class="logo-title" href="/">
                Hanxd&#39;s Notes
            </a>
        </div>

        <div class="right">
            <div class="pc">
                <ul class="menu-list">
                    
                        <li class="menu-item">
                            <a class=""
                               href="/"
                            >
                                首页
                            </a>
                        </li>
                    
                        <li class="menu-item">
                            <a class=""
                               href="/books"
                            >
                                书单
                            </a>
                        </li>
                    
                        <li class="menu-item">
                            <a class=""
                               href="/categories"
                            >
                                分类
                            </a>
                        </li>
                    
                        <li class="menu-item">
                            <a class=""
                               href="/archives"
                            >
                                归档
                            </a>
                        </li>
                    
                        <li class="menu-item">
                            <a class=""
                               href="/tags"
                            >
                                标签
                            </a>
                        </li>
                    
                    
                        <li class="menu-item search search-popup-trigger">
                            <i class="fas fa-search"></i>
                        </li>
                    
                </ul>
            </div>
            <div class="mobile">
                
                    <div class="icon-item search search-popup-trigger"><i class="fas fa-search"></i></div>
                
                <div class="icon-item menu-bar">
                    <div class="menu-bar-middle"></div>
                </div>
            </div>
        </div>
    </div>

    <div class="header-drawer">
        <ul class="drawer-menu-list">
            
                <li class="drawer-menu-item flex-center">
                    <a class=""
                       href="/">首页</a>
                </li>
            
                <li class="drawer-menu-item flex-center">
                    <a class=""
                       href="/books">书单</a>
                </li>
            
                <li class="drawer-menu-item flex-center">
                    <a class=""
                       href="/categories">分类</a>
                </li>
            
                <li class="drawer-menu-item flex-center">
                    <a class=""
                       href="/archives">归档</a>
                </li>
            
                <li class="drawer-menu-item flex-center">
                    <a class=""
                       href="/tags">标签</a>
                </li>
            
        </ul>
    </div>

    <div class="window-mask"></div>

</header>


        </div>

        <div class="page-main-content-middle">

            <div class="main-content">

                
                    <div class="fade-in-down-animation">
    <div class="article-content-container">

        <div class="article-title">
            <span class="title-hover-animation">Spring、rpc、orm常用框架总结</span>
        </div>

        
            <div class="article-header">
                <div class="avatar">
                    <img src="/pic/head.png">
                </div>
                <div class="info">
                    <div class="author">
                        <span class="name">形而上</span>
                        
                            <span class="author-label">Lv4</span>
                        
                    </div>
                    <div class="meta-info">
                        <div class="article-meta-info">
    <span class="article-date article-meta-item">
        <i class="fas fa-edit"></i>&nbsp;2021-10-21
    </span>
    
        <span class="article-categories article-meta-item">
            <i class="fas fa-folder"></i>&nbsp;
            <ul>
                
                    <li>
                        <a href="/categories/%E6%8A%80%E6%9C%AF%E6%96%87%E6%A1%A3/">技术文档</a>&nbsp;
                    </li>
                
            </ul>
        </span>
    
    
        <span class="article-tags article-meta-item">
            <i class="fas fa-tags"></i>&nbsp;
            <ul>
                
                    <li>
                        <a href="/tags/spring/">spring</a>&nbsp;
                    </li>
                
                    <li>
                        | <a href="/tags/sringboot/">sringboot</a>&nbsp;
                    </li>
                
                    <li>
                        | <a href="/tags/mybatis/">mybatis</a>&nbsp;
                    </li>
                
                    <li>
                        | <a href="/tags/orm/">orm</a>&nbsp;
                    </li>
                
                    <li>
                        | <a href="/tags/rpc/">rpc</a>&nbsp;
                    </li>
                
                    <li>
                        | <a href="/tags/netty/">netty</a>&nbsp;
                    </li>
                
            </ul>
        </span>
    

    
    
        <span class="article-wordcount article-meta-item">
            <i class="fas fa-file-word"></i>&nbsp;<span>8.5k 字</span>
        </span>
    
    
        <span class="article-min2read article-meta-item">
            <i class="fas fa-clock"></i>&nbsp;<span>30 分钟</span>
        </span>
    
    
</div>

                    </div>
                </div>
            </div>
        

        <div class="article-content markdown-body">
            <p>本文主要介绍 Java 中常用的应用框架，重点讲解如下三部分内容。</p>
<ol>
<li>Spring 框架中的主要知识点；</li>
<li>NIO 框架 Netty 以及基于 Netty 实现的主流 RPC 框架 Motan、Dubbo 和 gRPC；</li>
<li>ORM 框架 MyBatis。</li>
</ol>
<h1 id="常用框架汇总"><a href="#常用框架汇总" class="headerlink" title="常用框架汇总"></a>常用框架汇总</h1><p>先来看常用框架的知识点汇总，如下图所示。</p>
<p style="white-space: normal; text-align: justify; text-indent: 0em; line-height: 1.75em;"><img src="http://s0.lgstatic.com/i/image2/M01/8A/C6/CgoB5l14puyAas0oAABAOzPMKjQ128.png"></p>

<p>如上图所示，左上方是 Spring 系列。很多研发人员把 Spring 看作心目中最好的 Java 项目，没有之一。Spring 系列包含非常多的项目，可以满足 Java 开发中的方方面面。那么来看几个常用的 Spring 框架。</p>
<h2 id="Spring"><a href="#Spring" class="headerlink" title="Spring"></a>Spring</h2><p>Spring Framework，也就是我们常说的 Spring 框架，包括了 IoC 依赖注入，Context 上下文、 Bean 管理、SpringMVC 等众多功能模块，其他 Spring 项目比如 Spring Boot 也会依赖 Spring 框架。</p>
<p>Spring Boot 的目标是简化 Spring 应用和服务的创建、开发与部署，简化了配置文件，使用嵌入式 Web 服务器，含有诸多开箱即用的微服务功能，可以和 Spring Cloud 联合部署。Spring Boot 的核心思想是约定大于配置，应用只需要很少的配置即可，简化了应用开发模式。</p>
<p>Spring Data 是一个数据访问及操作的工具集，封装了多种数据源的操作能力，包括：JDBC、Redis、MongoDB 等。</p>
<p>Spring Cloud 是一套完整的微服务解决方案，是一系列不同功能的微服务框架的集合。Spring Cloud 基于 Spring Boot，简化了分布式系统的开发，集成了服务发现、配置管理、消息总线、负载均衡、断路器、数据监控等各种服务治理能力。比如sleuth提供了全链路追踪能力，Netflix套件提供了hystrix熔断器、zuul网关等众多的治理组件。config 组件提供了动态配置能力，bus组件支持使用 RabbitMQ、Kafka、ActiveMQ 等消息队列，实现分布式服务之间的事件通信。</p>
<p>Spring Security 用于快速构建安全的应用程序和服务，在 Spring Boot 和 Spring Security OAuth2 的基础上，可以快速实现常见安全模型，如单点登录，令牌中继和令牌交换。这里可以了解一下 OAuth2 授权机制和 JWT 认证方式。OAuth2 是一种授权机制，规定了完备的授权、认证流程。JWT 全称是 JSON Web Token，是一种把认证信息包含在 token 中的认证实现，OAuth2 授权机制中就可以应用 JWT 来作为认证的具体实现方法。</p>
<h2 id="Struts"><a href="#Struts" class="headerlink" title="Struts"></a>Struts</h2><p>Struts 是曾经非常火爆的 Web 组合 SSH 中的控制层。我们知道 Web 服务一般都采用 MVC 分层模型构建，就是 Model 层负责内部数据模型，Controller 负责请求的分发控制，View 层负责返回给用户展示的视图。Struts 实现的就是其中控制层的角色。</p>
<p>Struts 采用 Filter 实现，针对类进行拦截，每次请求就会创建一个 Action。不过使用 Struts 的 SSH 组合已经逐渐被使用 SpringMVC 的 SSM 组合代替，也就是 SpringMVC+Spring+MyBatis的组合，一方面原因是由于 Struts 对几次安全漏洞的处理，让大家对 Struts 的信心受到影响；另一方面，SpringMVC 更加灵活，不需要额外配置，不存在和 Spring 整合等问题，使用更加方便。所以建议以 SSM 框架的学习为主。</p>
<h2 id="ORM"><a href="#ORM" class="headerlink" title="ORM"></a>ORM</h2><p>ORM 就是对象关系匹配，解决面向对象与关系数据库存在的互不匹配的问题。简单来说，就是把关系数据库中的数据转换成面向对象程序中的对象。常用的 ORM 框架有 Hibernate 和 MyBatis，也就是 SSH 组合和 SSM 组合中的 H 与 M。</p>
<p>来看一下 Hibernate 和 MyBatis 的特点和区别。</p>
<ul>
<li>Hibernate 对数据库结构提供了完整的封装，实现了 POJO 对象与数据库表之间的映射，能够自动生成并执行 SQL 语句。只要定义了 POJO 到数据库表的映射关系，就可以通过 Hibernate 提供的方法完成数据库操作。Hibernate 符合 JPA 规范，就是 Java 持久层 API。</li>
<li>MyBatis 通过映射配置文件，将 SQL 所需的参数和返回的结果字段映射到指定对象，MyBatis 不会自动生成 SQL，需要自己定义 SQL 语句，不过更方便对 SQL 语句进行优化。</li>
</ul>
<p>总结起来，Hibernate 配置要比 MyBatis 复杂的多，学习成本也比 MyBatis 高。MyBatis，简单、高效、灵活，但是需要自己维护 SQL；Hibernate 功能强大、全自动、适配不同数据库，但是非常复杂，灵活性稍差。</p>
<h2 id="Netty"><a href="#Netty" class="headerlink" title="Netty"></a>Netty</h2><p>Netty 是一个高性能的异步事件驱动的网络通信框架，Netty 对 JDK 原生 NIO 进行封装，简化了网络服务的开发。</p>
<p>另外，同类型的框架还有 MINA、Grizzly，不过目前使用得相对较少，一般不会在面试题目中出现，可以作为兴趣简单了解。</p>
<h2 id="RPC"><a href="#RPC" class="headerlink" title="RPC"></a>RPC</h2><p>RPC 服务，Motan、Dubbo、gRPC 都是比较常用的高性能 RPC 框架，可以提供完善的服务治理能力，Java 版本的通信层都是基于前面提到的 Netty 实现。</p>
<h2 id="其他框架"><a href="#其他框架" class="headerlink" title="其他框架"></a>其他框架</h2><p>此外，Jersy 和 RESTEasy 都是可以快速开发 RESTful 服务的框架。与 SpringMVC 相比，这两个框架都是基于 JAX-RS 标准，而 SpringMVC 基于 Servlet，使用自己构建的 API，是两个不同的标准。</p>
<p>Shiro 框架是一个与 Spring Security 类似的开源的权限管理框架，用于访问授权、认证、加密及会话管理。能够支持单机与分布式 session 管理。相比 Security，Shiro更加简单易用</p>
<h1 id="详解-Spring-框架"><a href="#详解-Spring-框架" class="headerlink" title="详解 Spring 框架"></a>详解 Spring 框架</h1><p>对于 Spring 框架，讲解中涉及的流程与实现默认都是基于最新的 5.x 版本。先来看 Spring 中的几个重要概念。</p>
<h2 id="IoC"><a href="#IoC" class="headerlink" title="IoC"></a>IoC</h2><p>IoC，也就是控制反转，如下图，拿公司招聘岗位来举例。假设一个公司有产品、研发、测试等岗位。如果是公司根据岗位要求，逐个安排人选，如图中向下的箭头，这是正向流程。如果反过来，不用公司来安排候选人，而是由第三方猎头来匹配岗位和候选人，然后进行推荐，如图中向上的箭头，这就是控制反转。</p>
<p style="white-space: normal; text-align: justify; text-indent: 0em; line-height: 1.75em;"><img src="http://s0.lgstatic.com/i/image2/M01/8A/E6/CgotOV14puyAODLyAAAnwOuTkEk368.png"></p>

<p>在 Spring 中，对象的属性是由对象自己创建的，就是正向流程；如果属性不是对象创建，而是由 Spring 来自动进行装配，就是控制反转。这里的 DI 也就是依赖注入，就是实现控制反转的方式。正向流程导致了对象于对象之间的高耦合，IoC 可以解决对象耦合的问题，有利于功能的复用，能够使程序的结构变得非常灵活</p>
<h2 id="Context-和-Bean"><a href="#Context-和-Bean" class="headerlink" title="Context 和 Bean"></a>Context 和 Bean</h2><p>Spring 进行 IoC 实现时使用的两个概念：Context 上下文和 Bean。如下图所示，所有被 Spring 管理的、由 Spring 创建的、用于依赖注入的对象，就叫作一个 Bean。Spring 创建并完成依赖注入后，所有 Bean 统一放在一个叫作 Context 的上下文中进行管理。</p>
<p style="white-space: normal; text-align: justify; text-indent: 0em; line-height: 1.75em;"><img src="http://s0.lgstatic.com/i/image2/M01/8A/C6/CgoB5l14puyAWtEwAAA9kZ-6cDw595.png"></p>

<h2 id="AOP"><a href="#AOP" class="headerlink" title="AOP"></a>AOP</h2><p>AOP，就是面向切面编程。如下图所示，一般我们的程序执行流程是从 Controller 层调用 Service 层、然后 Service 层调用 DAO 层访问数据，最后在逐层返回结果。这个是图中向下箭头所示的按程序执行顺序的纵向处理。</p>
<p style="white-space: normal; text-align: justify; text-indent: 0em; line-height: 1.75em;"><img src="http://s0.lgstatic.com/i/image2/M01/8A/E6/CgotOV14puyAUnRTAAAlyBIiwZM437.png"></p>

<p>但是，我们思考这样一个问题，一个系统中会有多个不同的服务，例如用户服务、商品信息服务等等，每个服务的Controller层都需要验证参数，都需要处理异常，如果按照图中红色的部分，对不同服务的纵向处理流程进行横切，在每个切面上完成通用的功能，例如身份认证、验证参数、处理异常等等、这样就不用在每个服务中都写相同的逻辑了，这就是 AOP 思想解决的问题。AOP 以功能进行划分，对服务顺序执行流程中的不同位置进行横切，完成各服务共同需要实现的功能</p>
<h2 id="组件"><a href="#组件" class="headerlink" title="组件"></a>组件</h2><p>再来看到 Spring 框架，下图中列出了 Spring 框架主要包含的组件。这张图来自 Spring4.x 的文档。目前最新的 5.x 版本中右面的 Portlet 组件已经被废弃掉，同时增加了用于异步响应式处理的 WebFlux 组件。这里不需要对所有的组件都详细了解，只需要重点了解最常用的几个组件实现，以及知道每个组件用来实现哪一类功能就可以了。</p>
<p style="white-space: normal; text-align: justify; text-indent: 0em; line-height: 1.75em;"><img src="http://s0.lgstatic.com/i/image2/M01/8A/C6/CgoB5l14puyAXsN8AAB-CNBQpnQ843.png"></p>

<p>图中红框框住的是比较重要的组件，Core 组件是 Spring 所有组件的核心；Bean 组件和 Context 组件我刚才提到了，是实现 IoC 和依赖注入的基础；AOP 组件用来实现面向切面编程；Web 组件包括 SpringMVC，是 Web 服务的控制层实现</p>
<h2 id="动态代理和静态代理"><a href="#动态代理和静态代理" class="headerlink" title="动态代理和静态代理"></a>动态代理和静态代理</h2><p>接下来是 Spring 中机制和概念相关的知识点，如下图所示。</p>
<p style="white-space: normal; text-align: justify; text-indent: 0em; line-height: 1.75em;"><img src="http://s0.lgstatic.com/i/image2/M01/8A/E6/CgotOV14puyAZTSdAAGNifGMENk298.png"></p>

<p>AOP 的实现是通过代理模式，在调用对象的某个方法时，执行插入的切面逻辑。实现的方式有动态代理，也叫运行时增强，比如 JDK 代理、CGLIB；静态代理是在编译时进行织入或类加载时进行织入，比如 AspectJ。关于 AOP 还需要了解一下对应的 Aspect、pointcut、advice 等注解和具体使用方式。</p>
<h2 id="PlaceHolder-动态替换"><a href="#PlaceHolder-动态替换" class="headerlink" title="PlaceHolder 动态替换"></a>PlaceHolder 动态替换</h2><p>PlaceHolder 动态替换主要需要了解替换发生的时间，是在 Bean Definition 创建完成后，Bean 初始化之前，是通过 BeanFactoryPostProcessor 接口实现的。主要实现方式有 PropertyPlaceholderConfigurer 和 PropertySourcesPlaceholderConfigurer。这两个类实现逻辑不一样，Spring Boot 使用 PropertySourcesPlaceholderConfigurer 实现。</p>
<h2 id="事务"><a href="#事务" class="headerlink" title="事务"></a>事务</h2><p>事务，需要了解 Spring 中对事务规定的隔离类型和事务传播类型。这里要知道事务的隔离级别是由具体的数据库来实现的，在数据库部分会作详细介绍。事务的传播类型，可以重点了解最常用的 REQUIRED 和 SUPPORTS类型</p>
<h2 id="核心接口-x2F-类"><a href="#核心接口-x2F-类" class="headerlink" title="核心接口&#x2F;类"></a>核心接口&#x2F;类</h2><p>再来看图右上方需要重点掌握的核心类。</p>
<ul>
<li>ApplicationContext 保存了 IoC 的整个应用上下文，可以通过其中的 BeanFactory 获取到任意到 Bean；</li>
<li>BeanFactory 主要的作用是根据 Bean Definition 来创建具体的 Bean；</li>
<li>BeanWrapper 是对 Bean 的包装，一般情况下是在 Spring IoC 内部使用，提供了访问 Bean 的属性值、属性编辑器注册、类型转换等功能，方便 IoC 容器用统一的方式来访问 Bean 的属性；</li>
<li>FactoryBean 通过 getObject 方法返回实际的 Bean 对象，例如 Motan 框架中 referer 对 service 的动态代理就是通过 FactoryBean 来实现的。</li>
</ul>
<h2 id="Scope"><a href="#Scope" class="headerlink" title="Scope"></a>Scope</h2><p>Bean 的 Scope 是指 Bean 的作用域，默认情况下是单例模式，这也是使用最多的一种方式；多例模式，即每次从 BeanFactory 中获取 Bean 都会创建一个新的 Bean。Request、Session、Global-session 是在 Web 服务中使用的 Scope。</p>
<ul>
<li>Request 每次请求都创建一个实例；</li>
<li>Session 是在一个会话周期内保证只有一个实例；</li>
<li>Global-session 在 5.x 版本中已经不再使用，同时增加了 Application 和 Websocket 两种Scope，分别保证在一个 ServletContext 与一个 WebSocket 中只创建一个实例。</li>
</ul>
<p>还可以了解一下 Spring 的事件机制，知道 Spring 定义的五种标准事件，了解如何自定义事件和实现对应的 ApplicationListener 来处理自定义事件。</p>
<h2 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h2><p>下面来看 Spring 应用相关的知识点，如下图所示。</p>
<p style="white-space: normal; text-align: justify; text-indent: 0em; line-height: 1.75em;"><img src="http://s0.lgstatic.com/i/image2/M01/8A/C6/CgoB5l14puyAK0COAAGd_8jLTtQ986.png"></p>

<p>首先要熟练掌握常用注解的使用。</p>
<ol>
<li><p>类型类的注解，包括 Controller、Service 等，可以重点了解一下 Component 和 Bean 注解的区别：</p>
<ol>
<li>@Component 注解在类上使用表明这个类是个组件类，需要 Spring 为这个类创建 Bean</li>
<li>@Bean 注解使用在方法上，告诉 Spring 这个方法将会返回一个 Bean 对象，需要把返回的对象注册到 Spring 的应用上下文中。</li>
</ol>
</li>
<li><p>设置类注解可以重点了解 @Autowire 和 @Qualifier 以及 byType、byName 等不同的自动装配机制</p>
</li>
<li><p>Web 类主要以了解为主，关注 @RequestMapping、@GetMapping、@PostMapping 等路径匹配注解，以及 @PathVariable、@RequestParam 等参数获取注解。</p>
</li>
<li><p>功能类的注解，包括 @ImportResource 引用配置、@ComponentScan 注解自动扫描、@Transactional 事务注解等等，这里不一一介绍了。</p>
</li>
</ol>
<p>如上图右边所示，Spring 应用部分，还需要了解配置 Spring 的几种方式：XML 文件配置、注解配置和使用 API 进行配置。</p>
<p>自动装配机制需要了解按类型匹配进行自动装配，按 Bean 名称进行自动装配，构造器中的自动装配和自动检测等主要的四种方式。</p>
<p>最后还可以了解一下 List、Set、Map 等集合类属性的配置方式以及内部 Bean 的使用。</p>
<h2 id="Context-初始化流程"><a href="#Context-初始化流程" class="headerlink" title="Context 初始化流程"></a>Context 初始化流程</h2><p>如下图所示，左侧是三种类型的 Context：</p>
<ul>
<li>XML 配置方式的 Context；</li>
<li>Spring Boot 的 Context；</li>
<li>Web 服务的 Context。</li>
</ul>
<p style="white-space: normal; text-align: justify; text-indent: 0em; line-height: 1.75em;"><img src="http://s0.lgstatic.com/i/image2/M01/8A/E6/CgotOV14puyAX4lxAACLbBAfsE8470.png"></p>


<p>不论哪种 Context，创建后都会调用到 AbstractApplicationContext 类的 refresh 方法，流程如下。</p>
<ol>
<li>首先对刷新进行准备，包括设置开始时间、设置激活状态、初始化 Context 环境中的占位符，这个动作根据子类的需求由子类来执行，然后验证是否缺失必要的 properties。</li>
<li>刷新并获得内部的 Bean Factory</li>
<li>对 BeanFactory 进行准备工作，比如设置类加载器和后置处理器、配置不进行自动装配的类型、注册默认的环境 Bean。</li>
<li>为 Context 的子类提供后置处理 BeanFactory 的扩展能力。如果子类想在 Bean 定义加载完成后，开始初始化上下文之前做一些特殊逻辑，可以复写这个方法。</li>
<li>执行 Context 中注册的 Bean Factory 后缀处理器。这里有两种后置处理器，一种是可以注册 Bean 的后缀处理器，另一种是针对 BeanFactory 进行处理的后置处理器。执行的顺序是，先按优先级执行可注册 Bean 的处理器，在按优先级执行针对 BeanFactory的处理器。对 Spring Boot 来说，这一步会进行注解 Bean Definition 的解析。流程如图右侧所示，由 ConfigurationClassPostProcessor 触发、由 ClassPathBeanDefinitionScanner 解析并注册到 BeanFactory。</li>
<li>按优先级顺序在 BeanFactory 中注册 Bean的后缀处理器，Bean 后置处理器可以在 Bean 初始化前、后执行处理。</li>
<li>初始化消息源，消息源用来支持消息的国际化</li>
<li>初始化应用事件广播器。事件广播器用来向 ApplicationListener 通知各种应用产生的事件，是一个标准的观察者模式</li>
<li>是留给子类的扩展步骤，用来让特定的 Context 子类初始化其他的 Bean。</li>
<li>把实现了 ApplicationListener 的 Bean 注册到事件广播器，并对广播器中的早期未广播事件进行通知。</li>
<li>冻结所有 Bean 描述信息的修改，实例化非延迟加载的单例 Bean。</li>
<li>完成上下文的刷新工作，调用 LifecycleProcessor 的 onFresh() 方法以及发布 ContextRefreshedEvent 事件</li>
<li>在 finally 中，执行第十三步，重置公共的缓存，比如 ReflectionUtils 中的缓存、 AnnotationUtils 中的缓存等等；</li>
</ol>
<p>至此，Spring 的 Context 初始化完成。由于篇幅和时间的关系，这里介绍了最主要的主流程，建议课后阅读源码来复习这个知识点，补全细节。</p>
<h2 id="Bean-生命周期"><a href="#Bean-生命周期" class="headerlink" title="Bean 生命周期"></a>Bean 生命周期</h2><p>面试中经常问到 Bean 的生命周期，如下图，我们先看绿色的部分，Bean 的创建过程。</p>
<p style="white-space: normal; text-align: justify; text-indent: 0em; line-height: 1.75em;"><img src="http://s0.lgstatic.com/i/image2/M01/8A/C6/CgoB5l14puyAAa1gAABPP0lufvQ678.png"></p>

<ol>
<li>调用 Bean 的构造方法创建 Bean；</li>
<li>通过反射调用 setter 方法进行属性的依赖注入</li>
<li>如果实现 BeanNameAware 接口的话，会设置 Bean 的 name；</li>
<li>如果实现了 BeanFactoryAware，会把 BeanFactory 设置给 Bean</li>
<li>如果实现了 ApplicationContextAware，会给 Bean 设置 ApplictionContext；</li>
<li>如果实现了 BeanPostProcessor 接口，则执行前置处理方法；</li>
<li>实现了 InitializingBean 接口的话，执行 afterPropertiesSet 方法；</li>
<li>执行自定义的 init 方法；</li>
<li>执行 BeanPostProcessor 接口的后置处理方法。</li>
</ol>
<p>以上就完成了 Bean 的创建过程。而在使用完 Bean 需要销毁时，会先执行 DisposableBean 接口的 destroy 方法，然后在执行自定义的 destroy 方法。这部分也建议阅读源码加深理解</p>
<h2 id="扩展接口"><a href="#扩展接口" class="headerlink" title="扩展接口"></a>扩展接口</h2><p>在对 Spring 进行定制化功能扩展时，可以选择一些扩展点，如下图所示。</p>
<p style="white-space: normal; text-align: justify; text-indent: 0em; line-height: 1.75em;"><img src="http://s0.lgstatic.com/i/image2/M01/8A/E6/CgotOV14puyAOsrSAAB6eiNuRJY924.png"></p>

<ul>
<li>BeanFactoryPostProcessor 是 BeanFactory 后置处理器，支持在 BeanFactory 标准初始化完成后，对 BeanFactory 进行一些额外处理。讲 Context 初始化流程时介绍过，这时所有的 Bean 的描述信息已经加载完毕，但是还没有进行 Bean 初始化。例如前面提到的 PropertyPlaceholderConfigurer，就是在这个扩展点上对 Bean 属性中的占位符进行替换。</li>
<li>BeanDefinitionRegistryPostProcessor，它扩展自BeanFactoryPostProcessor，在执行 BeanFactoryPostProcessor 的功能前，提供了可以添加 Bean Definition 的能力，允许在初始化一般 Bean 前，注册额外的 Bean。例如可以在这里根据 Bean 的 Scope 创建一个新的代理 Bean。</li>
<li>BeanPostProcessor，提供了在 Bean 初始化之前和之后插入自定义逻辑的能力。与 BeanFactoryPostProcessor 的区别是处理的对象不同，BeanFactoryPostProcessor 是对 BeanFactory 进行处理，BeanPostProcessor 是对 Bean 进行处理。</li>
</ul>
<p>上面这三个扩展点，可以通过实现 Ordered 和PriorityOrdered 接口来指定执行顺序。实现 PriorityOrdered 接口的 processor 会先于实现 Ordered 接口的执行。</p>
<ul>
<li>ApplicationContextAware，可以获得 ApplicationContext 及其中的 Bean，当需要在代码中动态获取 Bean 时，可以通过实现这个接口来实现。</li>
<li>InitializingBean，可以在 Bean 初始化完成，所有属性设置完成后执行特定逻辑，例如对自动装配对属性进行验证等。</li>
<li>DisposableBean，用于在 Bean 被销毁前执行特定的逻辑，例如做一些回收工作等。</li>
<li>ApplicationListener，用来监听 Spring 的标准应用事件或者自定义事件。</li>
</ul>
<h1 id="Spring-Boot"><a href="#Spring-Boot" class="headerlink" title="Spring Boot"></a>Spring Boot</h1><p>下面来看 Spring Boot 相关的知识点，如下图所示。</p>
<p style="white-space: normal; text-align: justify; text-indent: 0em; line-height: 1.75em;"><img src="http://s0.lgstatic.com/i/image2/M01/8A/C6/CgoB5l14puyAX-52AAFrldgEgbY662.png"></p>

<p>首先是 Spring Boot 启动流程的主要步骤：</p>
<ol>
<li>要配置 Environment。</li>
<li>准备 Context 上下文，包括执行 ApplicationContext 的后置处理、初始化 Initializer、通知Listener 处理 ContextPrepared 和 ContextLoaded 事件</li>
<li>执行 refreshContext，也就是前面介绍过的 AbstractApplicationContext 类的 refresh 方法。</li>
</ol>
<p>然后要知道在 Spring Boot 中有两种上下文，一种是 bootstrap, 另外一种是 application。其中，bootstrap 是应用程序的父上下文，会先于 applicaton 加载。bootstrap 主要用于从额外的资源来加载配置信息，还可以在本地外部配置文件中解密属性。bootstrap 里面的属性会优先加载，默认也不能被本地相同配置覆盖。</p>
<p>再来看 Spring Boot 的注解。</p>
<p>需要知道 @SpringBootApplication 包含了 @ComponentScan、@EnableAutoConfiguration、@SpringBootConfiguration 三个注解，而 @SpringBootConfiguration 注解包含了 @Configuration 注解。也就是 Spring Boot 的自动配置功能。@Conditional 注解就是控制自动配置的生效条件的注解，例如 Bean 或 Class 存在、不存在时进行配置，当满足条件时进行配置等。</p>
<p>最后，了解一下 Spring Boot 的几个特色模块。</p>
<ul>
<li>Starter 是 Spring Boot 提供的无缝集成功能的一种方式，使用某个功能时开发者不需要关注各种依赖库的处理，不需要具体的配置信息，由 Spring Boot 自动配置进行 Bean的创建。例如需要使用 Web 功能时，只需要在依赖中引入 Spring-boot-starter-web 即可。</li>
<li>Actuator 是用来对应用程序进行监视和管理，通过 RESTful API 请求来监管、审计、收集应用的运行情况。</li>
<li>DevTools 提供了一系列开发工具的支持，来提高开发效率。例如热部署能力等。</li>
<li>CLI 就是命令行接口，是一个命令行工具，支持使用 Groovy 脚本，可以快速搭建 Spring 原型项目。</li>
</ul>
<h1 id="详解-Netty"><a href="#详解-Netty" class="headerlink" title="详解 Netty"></a>详解 Netty</h1><p>下面我们来看 Netty 相关的知识点，如下图所示。</p>
<p style="white-space: normal; text-align: justify; line-height: 1.75em; text-indent: 0em;"><img src="http://s0.lgstatic.com/i/image2/M01/8A/C8/CgoB5l14qRCAXHEcAAF5eJmBAIE201.png"></p>

<h2 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h2><p>如上图左侧所示，首先了解 Netty 的特点。</p>
<ul>
<li>Netty 是一个高性能的异步事件驱动的 NIO 框架，它对消息的处理采用串行无锁化设计，提供了对 TCP、UDP 和文件传输的支持。</li>
<li>Netty 内置了多种 encoder 和 decoder 实现来解决 TCP 粘包问题。</li>
<li>Netty 处理消息时使用了池化的缓冲池 ByteBufs，提高性能。</li>
<li>结合内存零 copy 机制，减少了对象的创建，降低了 GC 的压力。</li>
</ul>
<h2 id="主要概念"><a href="#主要概念" class="headerlink" title="主要概念"></a>主要概念</h2><p>需要掌握 Netty 中的一些对象概念，比如将 Socket 封装成 Channel 对象，在 Channel 读写消息时，使用 ChannelHandler 对消息进行处理，一组 Handler 顺序链接组成 ChannelPipeline 的责任链模式。一个 Channel 产生的所有事件交给一个单线程的 EventLoop 事件处理器来进行串行处理。而 Bootstrap 对象的主要作用是配置整个 Netty 程序串联起各个组件，是一个 Netty 应用的起点。</p>
<h3 id="零内存复制"><a href="#零内存复制" class="headerlink" title="零内存复制"></a>零内存复制</h3><p>要了解 Netty 的内存零 copy 技术。包括使用堆外内存来避免在 Socket 读写时缓冲数据在堆外与堆内进行频繁复制；使用 CompositeByteBuf 来减少多个小的 buffer 合并时产生的内存复制；使用 FileRegion 实现文件传输的零拷贝等。</p>
<h3 id="粘包与半包"><a href="#粘包与半包" class="headerlink" title="粘包与半包"></a>粘包与半包</h3><p>要了解 TCP 协议下粘包与半包等产生原因，知道 Netty 提供的多个 decoder 是用什么方式解决这个问题的。例如 FixedLengthFrameDecoder 用来解决固定大小数据包的粘包问题、LineBasedFrameDecoder 适合对文本进行按行分包、DelimiterBasedFrameDecoder 适合按特殊字符作为分包标记的场景、LengthFieldBasedFrameDecoder 可以支持复杂的自定义协议分包等等。</p>
<h3 id="Netty3-和-Netty4"><a href="#Netty3-和-Netty4" class="headerlink" title="Netty3 和 Netty4"></a>Netty3 和 Netty4</h3><p>简单了解一下 Netty3 和 Netty4 的区别，其中主要的就是两个版本的线程处理模型完全不同， Netty4 处理得更加优雅。其他的以 Netty4 的特点为主即可。</p>
<h3 id="线程模型"><a href="#线程模型" class="headerlink" title="线程模型"></a>线程模型</h3><p>Netty 线程模型采用“服务端监听线程”和“IO 线程”分离的方式，如下图，左侧 Boss 线程组负责监听事件，创建 Socket 并绑定到 Worker 线程组。</p>
<p style="white-space: normal; text-align: justify; line-height: 1.75em; text-indent: 0em;"><img src="http://s0.lgstatic.com/i/image2/M01/8A/E8/CgotOV14qRCAOMXfAACEn9bOiF8679.png"></p>


<p>Worker 线程组负责 IO 处理。线程组由 EventLoopGroup 实现，其中包含了多个 EventLoop 事件处理器，每个 EventLoop 包含一个处理线程。通常情况下在 NIO 非阻塞模式下，Netty 为每个 Channel 分配一个 EventLoop，并且它的整个生命周期中的事件都由这个 EventLoop 来处理。一个 EventLoop 可以绑定多个 Channel。</p>
<p>如上图右侧所示，EventLoop 的处理模型，Netty4 中 Channel 的读写事件都是由 Worker 线程来处理。请求处理中最主要的就是 ChannelPipeline，其中包含了一组 ChannelHandler。这些 Handler 组成了责任链模式，依次对 Channel 中的消息进行处理。一般接收消息时，Pipeline 处理完成会把消息提交到业务线程池进行处理，当业务线程处理完成时，会封装成 Task，提交回 Channel 对应的 EventLoop 来写回返回值。</p>
<h1 id="详解-RPC"><a href="#详解-RPC" class="headerlink" title="详解 RPC"></a>详解 RPC</h1><p>RPC 是远程过程调用的简写，RPC 与 HTTP 一样都可以实现远程服务的调用，但是使用方式上有很大的区别。它能够像使用本地方法一样调用远程的方法。</p>
<h2 id="交互流程"><a href="#交互流程" class="headerlink" title="交互流程"></a>交互流程</h2><p>如下图所示，来看 RPC 的交互流程。图中绿色的模块是 RPC 中最主要的三个角色。左边的是 Client 端，就是请求的发起方，也可以叫作 Consumer 或者 Referer。右边的模块是 Server 端，就是提供服务实现的一方，也叫作 Provider。</p>
<p style="white-space: normal; text-align: justify; line-height: 1.75em; text-indent: 0em;"><img src="http://s0.lgstatic.com/i/image2/M01/8A/C8/CgoB5l14qRCAD22_AAAwyeZIb9A096.png"></p>

<p>为了保持较高的性能，Client 端一般都是直接请求远端的 Server 节点。因此，RPC 框架需要自动的服务注册与发现的能力，上方的绿色的注册中心就是用来动态维护可用服务节点信息的模块。</p>
<p>图中的箭头代表交互流程。当 Server 提供服务时，向注册中心注册服务信息，告诉注册中心可以提供哪些服务。同时与注册中心保持心跳或者维持长链接，来维持 Server 可用状态，具体方式与注册中心的实现有关，例如 ZK 使用长链接推送方式而 Consul 使用心跳方式。</p>
<p>如上图所示，当 Client 需要使用服务时，会先向注册中心订阅服务，获得可用的 Server 节点，并保存在 Client 本地。当 Server 节点发生变更时会通知 Client 更新本地 Server 节点信息。Client 按某种负载均衡策略直接请求 Server 使用服务。注意：注册中心只参与服务节点的注册与变更通知，并不会参与具体请求的处理。</p>
<p>另外一般的 RPC 框架都提供了完整的服务治理能力，因此会有额外的管理模块和信息采集模块来监控、管理服务。如图中灰色的模块所示。</p>
<h2 id="开源框架"><a href="#开源框架" class="headerlink" title="开源框架"></a>开源框架</h2><p>来看三款比较有特色的主流 RPC 框架，如下图所示。</p>
<p style="white-space: normal; text-align: justify; line-height: 1.75em; text-indent: 0em;"><img src="http://s0.lgstatic.com/i/image2/M01/8A/E8/CgotOV14qRGALP4IAACKCkAICAg250.png"></p>

<p>Dubbo 是阿里开源的 RPC 框架，提供完善的服务治理能力，可以快速为 Java 服务提供 RPC 能力。Dubbo 提供了随机、轮询、最少调用优先等多种负载均衡策略，提供对 ZK 等多种注册中心等支持，能够自动完成服务的注册与发现。Dubbo 提供可视化的管理后台，方便对服务状态进行监控和管理。Dubbo 的数据通信默认使用我 Netty 来实现，拥有非常不错的性能。</p>
<p>微博开源的轻量级服务治理框架 Motan。Motan 的特点是轻量级，提供强大灵活的扩展能力，Motan 提供了多语言支持，目前支持 Java、PHP、Lua、Golang 等多语言交互，目前 Python 和 C++ 的客户端也在研发中。Motan 通过 Agent 代理方式，实现了的跨语言 ServiceMesh 的支持。ServiceMesh 被誉为下一代微服务，在课时 10 还会重点介绍。Motan Java 版本的通信层也是通过 Netty 来实现的，基于 TCP 的私有协议进行通信</p>
<p>Google 开源的 gRPC。gRPC 默认使用 Protobuf 进行消息序列化，非常适合多语言服务之间进行交互。虽然 gRPC 本身支持的服务治理能力并不强，但拥有非常灵活的插件扩展能力，可以方便的实现自定义的服务治理能力。gRPC 基于 HTTP2 协议，能够支持链接复用，并且提供了流式调用能力，也支持从服务端进行推送消息的能力。</p>
<h1 id="详解-MyBatis"><a href="#详解-MyBatis" class="headerlink" title="详解 MyBatis"></a>详解 MyBatis</h1><h2 id="特点-1"><a href="#特点-1" class="headerlink" title="特点"></a>特点</h2><p>下面我们来看 ORM 框架 MyBatis，它的知识结构图如下所示。首先要了解它的特点，可以和 Hibernate 来对比进行理解。</p>
<p style="white-space: normal; text-align: justify; line-height: 1.75em; text-indent: 0em;"><img src="http://s0.lgstatic.com/i/image2/M01/8A/C8/CgoB5l14qRGATSOHAAF3bP90vkw672.png"></p>

<p>MyBatis 的优点：</p>
<ol>
<li>MyBatis 是原生SQL，不像 Hibernate 的 HQL 需要额外的学习成本；</li>
<li>MyBatis 的 SQL 语句与代码进行了解耦合，这与 Hibernate 是一致的；</li>
<li>MyBatis 功能简单，学习成本比较低，使用的门槛也非常低，可以快速上手；</li>
<li>MyBatis SQL调优比较灵活，而 Hibernate，SQL 语句是自动生成的，当有复杂语句需要进行优化时就比较难处理。</li>
</ol>
<p>MyBatis 的缺点：</p>
<ol>
<li>相比 Hibernate 这样的全自动 ORM 框架，不能自动生成 SQL 语句，编写 SQL 的工作量比较大，尤其是字段多、关联表多的情况下</li>
<li>另外一个缺点就是 SQL 语句依赖于具体数据库，导致数据库迁移性差，而 Hibernate 则拥有良好的数据库可移植性。</li>
</ol>
<h2 id="缓存"><a href="#缓存" class="headerlink" title="缓存"></a>缓存</h2><p>MyBatis 提供了两级缓存。MyBatis 的一级缓存的存储作用域是 Session，会对同一个 Session 中执行语句的结果进行缓存，来提高再次执行时的效率。MyBatis 内部通过 HashMap 实现存储缓存，一级缓存是默认开启的。</p>
<p>MyBatis 的二级缓存的作用域是一个 Mapper 的 namespace，在同一个 namespace 中查询 SQL 时可以从缓存中获取数据。二级缓存能够跨 SqlSession 生效，并且可自定义存储源，比如 Ehcache。MyBatis 的二级缓存可以设置剔除策略、刷新间隔、缓存数量等参数来进行优化。</p>
<h2 id="应用-1"><a href="#应用-1" class="headerlink" title="应用"></a>应用</h2><ul>
<li>MyBatis 提供 #{} 的变量占位符，来支持 SQL 预编译，防止 SQL 注入。</li>
<li>获取自增主键的 id 可以通过 keyProperty 配置和使用 selectKey 两种方式来实现。</li>
<li>要记住动态 SQL 常用的几个标签，例如 foreach、where、if、choose、trim 等等。</li>
</ul>
<h2 id="主要对象"><a href="#主要对象" class="headerlink" title="主要对象"></a>主要对象</h2><p>需要理解 MyBatis 的主要对象有哪些，它们的作用是什么，举例如下。</p>
<ul>
<li>SqlSessionFactory 是用来创建 SqlSession 的工厂类，一个 SqlSessionFactory 对应配置文件中的一个环境，也就是一个数据库配置。</li>
<li>对数据库的操作必须在 SqlSession 中进行，SqlSession 非线程安全，每一次操作完数据库后都要调用 Close 对其进行关闭。</li>
<li>SqlSession 通过内部的 Executor 来执行增删改查操作。</li>
<li>StatementHandler 用来处理 SQL 语句预编译，设置参数等。</li>
<li>ParameterHandler 用来设置预编译参数。</li>
<li>ResultSetHandler 用来处理结果集。</li>
<li>TypeHandler 进行数据库类型和 JavaBean 类型的互相映射。</li>
</ul>
<h2 id="插件机制"><a href="#插件机制" class="headerlink" title="插件机制"></a>插件机制</h2><p>MyBatis 的插件机制是通过拦截器组成责任链来对 Executor、StatementHandler、ParameterHandler、ResultSetHandler 这四个作用点进行定制化处理。另外可以了解一下基于插件机制实现的 PageHelper 分页插件</p>
<h2 id="处理流程"><a href="#处理流程" class="headerlink" title="处理流程"></a>处理流程</h2><p>如下图所示，MyBatis 的处理流程。</p>
<p style="white-space: normal; text-align: justify; line-height: 1.75em; text-indent: 0em;"><img src="http://s0.lgstatic.com/i/image2/M01/8A/E8/CgotOV14qRGANGszAABEHrKX1zU413.png"></p>

<p>在执行 SQL 时，首先会从 SqlSessionFactory 中创建一个新的 SqlSession。</p>
<p>SQL 语句是通过 SqlSession 中的 Executor 来执行，Executor 根据 SqlSession 传递的参数执行 query() 方法，然后创建一个 StatementHandler 对象，将必要的参数传递给 StatementHandler，由 StatementHandler 来完成对数据库的查询。</p>
<p>StatementHandler 调用 ParameterHandler 的 setParameters 方法，把用户传递的参数转换成 JDBC Statement 所需要的参数， 调用原生 JDBC 来执行语句。</p>
<p>最后由 ResultSetHandler 的 handleResultSets 方法将 JDBC 返回的 ResultSet 结果集转换成对象集，并逐级返回结果，完成一次 SQL 语句执行。</p>
<h1 id="考察点"><a href="#考察点" class="headerlink" title="考察点"></a>考察点</h1><p>下面是需要注意的面试考察点。</p>
<ol>
<li>首先要掌握 Spring 的核心概念 IoC、AOP 以及具体的实现方式。</li>
<li>要重点掌握 SpringContext 的初始化流程、Bean 的生命周期。</li>
<li>以应用为主，了解常用注解的作用和使用方式。</li>
<li>要了解一下 Spring Boot 相关的知识点，目前使用 Spring Boot 的项目越来越多，建议根据前面列出的知识点来学习。</li>
<li>要理解 Netty 的线程模型和消息处理的pipeline机制。</li>
<li>要理解 RPC 的交互流程及常用 RPC 框架的特点。</li>
<li>要了解 MyBatis 或者 Hibernate 这样的 ORM 框架解决了什么问题，了解框架的实现原理。</li>
</ol>
<p>这一节课的内容比较多，前面提到的核心机制、核心流程，建议阅读源码加深理解。提供一个小技巧，在学习时可以通过断点调试的方式，结合给出的流程图来阅读源码。</p>
<h2 id="加分项"><a href="#加分项" class="headerlink" title="加分项"></a>加分项</h2><ol>
<li>本课时涉及考察点大多是以应用能力为主的，但是如果你阅读过源码，能突出对底层实现细节的掌握能力，一定会另面试官刮目相看。</li>
<li>除了应用之外，最好能理解框架的理念，例如理解 Spring 的控制反转与 AOP 思想。</li>
<li>能够知道框架最新版本的实现和发展方向，保持对新技术的兴趣和敏感。例如了解 Spring 的 Web Flux 响应式编程的实现与应用，关注 Spring Cloud 的应用等等。</li>
<li>如果能在应用的基础上有调优的经验，会让你在面试时更加突出。例如你有 Netty 的调优经验，知道要尽量减少 IO 线程占用，把可以后置的处理放到业务线程池中进行。</li>
</ol>
<h2 id="真题汇总"><a href="#真题汇总" class="headerlink" title="真题汇总"></a>真题汇总</h2><p>最后汇总一些相关的面试真题作为参考，以及需要注意的地方，如下所示。</p>
<p style="white-space: normal; text-align: justify; line-height: 1.75em; text-indent: 0em;"><img src="http://s0.lgstatic.com/i/image2/M01/8A/C8/CgoB5l14qRGAfS0KAABYryfVTDc376.png"></p>

<p>第 1 题，除了说出 SSH 框架是 Struct+Spring+Hibernate，SSM 是指的 Spring MVC+Spring+MyBatis，另外要重点说一下 SpringMVC 和 Struts 的区别，以及 MyBatis 和 Hibernate 的区别。</p>
<p>第 4 题，要答出是通过 BeanFactoryPostProcessor 后置处理器进行的占位符替换，如果自定义处理，可以扩展 PropertyPlaceholderConfigurer 或 PropertySourcesPlaceholderConfigurer 来实现。</p>
<p>第 5 题，大致可以分为：从 HandlerMapping 中查找 Handler、执行 Handler、执行完成给适配器返回 ModelAndView、视图解析、返回视图，这些步骤。建议通过调试来阅读源码，补充细节、增加理解</p>
<p>第 6 题，可以从构造器循环依赖和 setter 循环依赖两部分来回答，构造器循环通过使用创建中 Bean 标示池，来判断是否产生了循环创建；setter 循环依赖通过引入 ObjectFactory 来解决。</p>
<p style="white-space: normal; text-align: justify; line-height: 1.75em; text-indent: 0em;"><img src="http://s0.lgstatic.com/i/image2/M01/8A/E8/CgotOV14qRGAavpoAABhTu0HeK8332.png"></p>

<p>第 7 题，题目给出的就是执行顺序。</p>
<p>第 8 题，可以从 Channel、Socket、EventLoop、ChannelPipeline 等对象展开介绍。</p>
<p>第 9 题，可以从下面几方面回答：</p>
<ul style=" white-space: normal;">
 <li><p style="text-align: justify; line-height: 1.75em; text-indent: 0em;"><span style="font-family: 微软雅黑, &quot;Microsoft YaHei&quot;; color: rgb(63, 63, 63);">使用方式，HTTP 使用 Client 方式进行远程调用，RPC 使用动态代理的方式实现远程调用；</span></p></li>
 <li><p style="text-align: justify; line-height: 1.75em; text-indent: 0em;"><span style="font-family: 微软雅黑, &quot;Microsoft YaHei&quot;; color: rgb(63, 63, 63);">请求模型，HTTP 一般会经过 DNS 解析、4−7 层代理等中间环节，而 RPC 一般是点对点直连；</span></p></li>
 <li><p style="text-align: justify; line-height: 1.75em; text-indent: 0em;"><span style="font-family: 微软雅黑, &quot;Microsoft YaHei&quot;; color: rgb(63, 63, 63);">服务治理能力，RPC 提供更加丰富的服务治理功能，例如熔断、负载均衡等；</span></p></li>
 <li><p style="text-align: justify; line-height: 1.75em; text-indent: 0em;"><span style="font-family: 微软雅黑, &quot;Microsoft YaHei&quot;; color: rgb(63, 63, 63);">语言友好性，HTTP 对跨语言服务之间交互更加友好。</span></p></li>
</ul>
        </div>

        
            <div class="post-copyright-info">
                <div class="article-copyright-info-container">
    <ul>
        <li>本文标题：Spring、rpc、orm常用框架总结</li>
        <li>本文作者：形而上</li>
        <li>创建时间：2021-10-21 00:00:00</li>
        <li>
            本文链接：https://deepter.gitee.io/2021_10_21_spring_rpc_orm/
        </li>
        <li>
            版权声明：本博客所有文章除特别声明外，均采用 <a class="license" target="_blank" rel="noopener" href="https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh">BY-NC-SA</a> 许可协议。转载请注明出处！
        </li>
    </ul>
</div>

            </div>
        

        
            <div class="article-nav">
                
                    <div class="article-prev">
                        <a class="prev"
                           rel="prev"
                           href="/2021_10_22_cache/"
                        >
                            <span class="left arrow-icon flex-center">
                              <i class="fas fa-chevron-left"></i>
                            </span>
                            <span class="title flex-center">
                                <span class="post-nav-title-item">缓存中间件总结</span>
                                <span class="post-nav-item">上一篇</span>
                            </span>
                        </a>
                    </div>
                
                
                    <div class="article-next">
                        <a class="next"
                           rel="next"
                           href="/2021_10_20_tools/"
                        >
                            <span class="title flex-center">
                                <span class="post-nav-title-item">研发排障常用工具总结</span>
                                <span class="post-nav-item">下一篇</span>
                            </span>
                            <span class="right arrow-icon flex-center">
                              <i class="fas fa-chevron-right"></i>
                            </span>
                        </a>
                    </div>
                
            </div>
        

        
    </div>
</div>


                
            </div>

        </div>

        <div class="page-main-content-bottom">
            <footer class="footer">
    <div class="info-container">
        <div class="copyright-info info-item">
            &copy;
            
              <span>2017</span>&nbsp;-&nbsp;
            
            2025&nbsp;<i class="fas fa-heart icon-animate"></i>&nbsp;<a href="/">形而上</a>
        </div>
        
            <script async  src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
            <div class="website-count info-item">
                
                    <span id="busuanzi_container_site_uv">
                        访问人数&nbsp;<span id="busuanzi_value_site_uv"></span>&ensp;
                    </span>
                
                
                    <span id="busuanzi_container_site_pv">
                        总访问量&nbsp;<span id="busuanzi_value_site_pv"></span>
                    </span>
                
            </div>
        
        <div class="theme-info info-item">
            由 <a target="_blank" href="https://hexo.io">Hexo</a> 驱动&nbsp;|&nbsp;主题&nbsp;<a class="theme-version" target="_blank" href="https://github.com/XPoet/hexo-theme-keep">Keep v3.4.3</a>
        </div>
        
    </div>
</footer>

        </div>
    </div>

    
        <div class="post-tools">
            <div class="post-tools-container">
    <ul class="tools-list">
        <!-- TOC aside toggle -->
        
            <li class="tools-item page-aside-toggle">
                <i class="fas fa-outdent"></i>
            </li>
        

        <!-- go comment -->
        
    </ul>
</div>

        </div>
    

    <div class="right-bottom-side-tools">
        <div class="side-tools-container">
    <ul class="side-tools-list">
        <li class="tools-item tool-font-adjust-plus flex-center">
            <i class="fas fa-search-plus"></i>
        </li>

        <li class="tools-item tool-font-adjust-minus flex-center">
            <i class="fas fa-search-minus"></i>
        </li>

        <li class="tools-item tool-expand-width flex-center">
            <i class="fas fa-arrows-alt-h"></i>
        </li>

        <li class="tools-item tool-dark-light-toggle flex-center">
            <i class="fas fa-moon"></i>
        </li>

        <!-- rss -->
        

        

        <li class="tools-item tool-scroll-to-bottom flex-center">
            <i class="fas fa-arrow-down"></i>
        </li>
    </ul>

    <ul class="exposed-tools-list">
        <li class="tools-item tool-toggle-show flex-center">
            <i class="fas fa-cog fa-spin"></i>
        </li>
        
            <li class="tools-item tool-scroll-to-top flex-center">
                <i class="arrow-up fas fa-arrow-up"></i>
                <span class="percent"></span>
            </li>
        
    </ul>
</div>

    </div>

    
        <aside class="page-aside">
            <div class="post-toc-wrap">
    <div class="post-toc">
        <ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%B8%B8%E7%94%A8%E6%A1%86%E6%9E%B6%E6%B1%87%E6%80%BB"><span class="nav-text">常用框架汇总</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#Spring"><span class="nav-text">Spring</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Struts"><span class="nav-text">Struts</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#ORM"><span class="nav-text">ORM</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Netty"><span class="nav-text">Netty</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#RPC"><span class="nav-text">RPC</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%85%B6%E4%BB%96%E6%A1%86%E6%9E%B6"><span class="nav-text">其他框架</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E8%AF%A6%E8%A7%A3-Spring-%E6%A1%86%E6%9E%B6"><span class="nav-text">详解 Spring 框架</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#IoC"><span class="nav-text">IoC</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Context-%E5%92%8C-Bean"><span class="nav-text">Context 和 Bean</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#AOP"><span class="nav-text">AOP</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%BB%84%E4%BB%B6"><span class="nav-text">组件</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86%E5%92%8C%E9%9D%99%E6%80%81%E4%BB%A3%E7%90%86"><span class="nav-text">动态代理和静态代理</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#PlaceHolder-%E5%8A%A8%E6%80%81%E6%9B%BF%E6%8D%A2"><span class="nav-text">PlaceHolder 动态替换</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BA%8B%E5%8A%A1"><span class="nav-text">事务</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%A0%B8%E5%BF%83%E6%8E%A5%E5%8F%A3-x2F-%E7%B1%BB"><span class="nav-text">核心接口&#x2F;类</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Scope"><span class="nav-text">Scope</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%BA%94%E7%94%A8"><span class="nav-text">应用</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Context-%E5%88%9D%E5%A7%8B%E5%8C%96%E6%B5%81%E7%A8%8B"><span class="nav-text">Context 初始化流程</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Bean-%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F"><span class="nav-text">Bean 生命周期</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%89%A9%E5%B1%95%E6%8E%A5%E5%8F%A3"><span class="nav-text">扩展接口</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Spring-Boot"><span class="nav-text">Spring Boot</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E8%AF%A6%E8%A7%A3-Netty"><span class="nav-text">详解 Netty</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%89%B9%E7%82%B9"><span class="nav-text">特点</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%B8%BB%E8%A6%81%E6%A6%82%E5%BF%B5"><span class="nav-text">主要概念</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%9B%B6%E5%86%85%E5%AD%98%E5%A4%8D%E5%88%B6"><span class="nav-text">零内存复制</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%B2%98%E5%8C%85%E4%B8%8E%E5%8D%8A%E5%8C%85"><span class="nav-text">粘包与半包</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Netty3-%E5%92%8C-Netty4"><span class="nav-text">Netty3 和 Netty4</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%BA%BF%E7%A8%8B%E6%A8%A1%E5%9E%8B"><span class="nav-text">线程模型</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E8%AF%A6%E8%A7%A3-RPC"><span class="nav-text">详解 RPC</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BA%A4%E4%BA%92%E6%B5%81%E7%A8%8B"><span class="nav-text">交互流程</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%BC%80%E6%BA%90%E6%A1%86%E6%9E%B6"><span class="nav-text">开源框架</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E8%AF%A6%E8%A7%A3-MyBatis"><span class="nav-text">详解 MyBatis</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%89%B9%E7%82%B9-1"><span class="nav-text">特点</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%BC%93%E5%AD%98"><span class="nav-text">缓存</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%BA%94%E7%94%A8-1"><span class="nav-text">应用</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%B8%BB%E8%A6%81%E5%AF%B9%E8%B1%A1"><span class="nav-text">主要对象</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%8F%92%E4%BB%B6%E6%9C%BA%E5%88%B6"><span class="nav-text">插件机制</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%A4%84%E7%90%86%E6%B5%81%E7%A8%8B"><span class="nav-text">处理流程</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E8%80%83%E5%AF%9F%E7%82%B9"><span class="nav-text">考察点</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%8A%A0%E5%88%86%E9%A1%B9"><span class="nav-text">加分项</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%9C%9F%E9%A2%98%E6%B1%87%E6%80%BB"><span class="nav-text">真题汇总</span></a></li></ol></li></ol>
    </div>
</div>
        </aside>
    

    <div class="image-viewer-container">
    <img src="">
</div>


    
        <div class="search-pop-overlay">
    <div class="popup search-popup">
        <div class="search-header">
          <span class="search-input-field-pre">
            <i class="fas fa-keyboard"></i>
          </span>
            <div class="search-input-container">
                <input autocomplete="off"
                       autocorrect="off"
                       autocapitalize="off"
                       placeholder="搜索..."
                       spellcheck="false"
                       type="search"
                       class="search-input"
                >
            </div>
            <span class="popup-btn-close">
                <i class="fas fa-times"></i>
            </span>
        </div>
        <div id="search-result">
            <div id="no-result">
                <i class="fas fa-spinner fa-pulse fa-5x fa-fw"></i>
            </div>
        </div>
    </div>
</div>

    

</main>




<script src="/js/utils.js"></script>

<script src="/js/main.js"></script>

<script src="/js/header-shrink.js"></script>

<script src="/js/back2top.js"></script>

<script src="/js/dark-light-toggle.js"></script>



    
<script src="/js/local-search.js"></script>




    
<script src="/js/code-copy.js"></script>





<div class="post-scripts">
    
        
<script src="/js/left-side-toggle.js"></script>

<script src="/js/libs/anime.min.js"></script>

<script src="/js/toc.js"></script>

    
</div>



</body>
</html>
