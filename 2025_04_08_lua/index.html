<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
    <meta name="keywords" content="Hexo Theme Keep">
    <meta name="description" content="零落成泥碾作尘，只有香如故！">
    <meta name="author" content="形而上">
    
    <title>
        
            《Lua编程》 第一篇：语言 |
        
        Hanxd&#39;s Notes
    </title>
    
<link rel="stylesheet" href="/css/style.css">

    <link rel="shortcut icon" href="/pic/head.png">
    
<link rel="stylesheet" href="/css/font-awesome.min.css">

    <script id="hexo-configurations">
    let KEEP = window.KEEP || {};
    KEEP.hexo_config = {"hostname":"yoursite.com","root":"/","language":"zh-CN","path":"search.json"};
    KEEP.theme_config = {"toc":{"enable":true,"number":false,"expand_all":false,"init_open":true},"style":{"primary_color":"#FF7F00","avatar":"/pic/head.png","favicon":"/pic/head.png","article_img_align":"left","left_side_width":"260px","content_max_width":"920px","hover":{"shadow":false,"scale":false},"first_screen":{"enable":true,"background_img":"/images/bg.svg","description":"Still waters run deep."},"scroll":{"progress_bar":{"enable":false},"percent":{"enable":true}}},"local_search":{"enable":true,"preload":true},"code_copy":{"enable":true,"style":"default"},"pjax":{"enable":false},"lazyload":{"enable":false},"version":"3.4.3"};
    KEEP.language_ago = {"second":"%s 秒前","minute":"%s 分钟前","hour":"%s 小时前","day":"%s 天前","week":"%s 周前","month":"%s 月前","year":"%s 年前"};
  </script>
<meta name="generator" content="Hexo 5.4.2"></head>


<body>
<div class="progress-bar-container">
    

    
</div>


<main class="page-container">

    

    <div class="page-main-content">

        <div class="page-main-content-top">
            <header class="header-wrapper">

    <div class="header-content">
        <div class="left">
            
            <a class="logo-title" href="/">
                Hanxd&#39;s Notes
            </a>
        </div>

        <div class="right">
            <div class="pc">
                <ul class="menu-list">
                    
                        <li class="menu-item">
                            <a class=""
                               href="/"
                            >
                                首页
                            </a>
                        </li>
                    
                        <li class="menu-item">
                            <a class=""
                               href="/books"
                            >
                                书单
                            </a>
                        </li>
                    
                        <li class="menu-item">
                            <a class=""
                               href="/categories"
                            >
                                分类
                            </a>
                        </li>
                    
                        <li class="menu-item">
                            <a class=""
                               href="/archives"
                            >
                                归档
                            </a>
                        </li>
                    
                        <li class="menu-item">
                            <a class=""
                               href="/tags"
                            >
                                标签
                            </a>
                        </li>
                    
                    
                        <li class="menu-item search search-popup-trigger">
                            <i class="fas fa-search"></i>
                        </li>
                    
                </ul>
            </div>
            <div class="mobile">
                
                    <div class="icon-item search search-popup-trigger"><i class="fas fa-search"></i></div>
                
                <div class="icon-item menu-bar">
                    <div class="menu-bar-middle"></div>
                </div>
            </div>
        </div>
    </div>

    <div class="header-drawer">
        <ul class="drawer-menu-list">
            
                <li class="drawer-menu-item flex-center">
                    <a class=""
                       href="/">首页</a>
                </li>
            
                <li class="drawer-menu-item flex-center">
                    <a class=""
                       href="/books">书单</a>
                </li>
            
                <li class="drawer-menu-item flex-center">
                    <a class=""
                       href="/categories">分类</a>
                </li>
            
                <li class="drawer-menu-item flex-center">
                    <a class=""
                       href="/archives">归档</a>
                </li>
            
                <li class="drawer-menu-item flex-center">
                    <a class=""
                       href="/tags">标签</a>
                </li>
            
        </ul>
    </div>

    <div class="window-mask"></div>

</header>


        </div>

        <div class="page-main-content-middle">

            <div class="main-content">

                
                    <div class="fade-in-down-animation">
    <div class="article-content-container">

        <div class="article-title">
            <span class="title-hover-animation">《Lua编程》 第一篇：语言</span>
        </div>

        
            <div class="article-header">
                <div class="avatar">
                    <img src="/pic/head.png">
                </div>
                <div class="info">
                    <div class="author">
                        <span class="name">形而上</span>
                        
                            <span class="author-label">Lv4</span>
                        
                    </div>
                    <div class="meta-info">
                        <div class="article-meta-info">
    <span class="article-date article-meta-item">
        <i class="fas fa-edit"></i>&nbsp;2025-04-08
    </span>
    
        <span class="article-categories article-meta-item">
            <i class="fas fa-folder"></i>&nbsp;
            <ul>
                
                    <li>
                        <a href="/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/">读书笔记</a>&nbsp;
                    </li>
                
            </ul>
        </span>
    
    
        <span class="article-tags article-meta-item">
            <i class="fas fa-tags"></i>&nbsp;
            <ul>
                
                    <li>
                        <a href="/tags/Lua/">Lua</a>&nbsp;
                    </li>
                
            </ul>
        </span>
    

    
    
        <span class="article-wordcount article-meta-item">
            <i class="fas fa-file-word"></i>&nbsp;<span>27.3k 字</span>
        </span>
    
    
        <span class="article-min2read article-meta-item">
            <i class="fas fa-clock"></i>&nbsp;<span>106 分钟</span>
        </span>
    
    
</div>

                    </div>
                </div>
            </div>
        

        <div class="article-content markdown-body">
            <p><img src="/%5C2025_04_08_lua%5C1.jpg"></p>
<p>Simple is beautiful</p>
<p>(本文使用pdf-craft开源工具和大模型生成整理)</p>
<h1 id="译序"><a href="#译序" class="headerlink" title="译序"></a>译序</h1><p>“袁承志知道若再谦逊,那就是瞧人不起,展开五行拳,发拳当胸打去。荣彩和旁观三人本来都以为他武功有独到之秘,哪知使出来的竟是武林中最寻常不过的五行拳。敌对三人登时意存轻视,温青脸上不自禁露出失望的神色。</p>
<p>“荣彩心中暗喜,双拳如风,连抢三下攻势,满拟自己的大力魔爪手江南独步,三四招之间就可破去对方五行拳,那知袁承志轻描淡写的一一化解。再拆数招,荣彩暗暗吃惊,原来对方所使虽是极寻常的拳术,但每一招均是含劲不吐,意在拳先,举手抬足之间隐含极浑厚的内力。”</p>
<p>——金庸 《碧血剑》</p>
<p>编程语言之于程序员,若武功招式之于习武之人,招式虽重要,但在于使用之人。胜者之道,武功只行于表,高手用剑,片草只叶亦威力无穷。</p>
<p>当今武林,派别林立,语言繁杂,林林总总不计其数。主流文化的C&#x2F;C++、Java、C#、VB；偏安一隅的Fortran；动态语言中的Perl、Tcl、Ruby、Forth、Python,以及本书介绍的Lua；····,等等等等。再加上世界上那些不知道躲在哪的晃的奇奇怪怪的hacker捣鼓出来的异想天开的语言,要想将各类语言囊入怀中,不异于痴人说梦。不信可欣赏一下BrainFuck语言’的Hello World程序,语言本身依如其名。</p>
<figure class="highlight brainfuck"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="literal">+++++++++</span><span class="title">[</span>&lt;<span class="literal">++++++++</span>&gt;<span class="literal">-</span><span class="title">]</span>&lt;<span class="string">.</span>&gt;<span class="literal">+++++++</span><span class="title">[</span>&lt;<span class="literal">++++</span>&gt;<span class="literal">-</span><span class="title">]</span>&lt;<span class="literal">+</span><span class="string">.</span><span class="literal">+++++++</span><span class="string">.</span><span class="string">.</span><span class="literal">+++</span><span class="string">.</span><span class="title">[</span><span class="literal">-</span><span class="title">]</span>&gt;<span class="literal">++++++++</span><span class="title">[</span>&lt;<span class="literal">++++</span>&gt;<span class="literal">-</span><span class="title">]</span>&lt;<span class="string">.</span><span class="comment">#</span>&gt;<span class="literal">+++++++++++</span><span class="title">[</span>&lt;<span class="literal">+++++</span>&gt;<span class="literal">-</span><span class="title">]</span>&lt;<span class="string">.</span>&gt;<span class="literal">++++++++</span><span class="title">[</span>&lt;<span class="literal">+</span></span><br><span class="line"> <span class="literal">++</span>&gt;<span class="literal">-</span><span class="title">]</span>&lt;<span class="string">.</span><span class="literal">+++</span><span class="string">.</span><span class="literal">------</span><span class="string">.</span><span class="literal">--------</span><span class="string">.</span><span class="title">[</span><span class="literal">-</span><span class="title">]</span>&gt;<span class="literal">++++++++</span><span class="title">[</span>&lt;<span class="literal">++++</span>&gt;<span class="literal">-</span><span class="title">]</span>&lt;<span class="literal">+</span><span class="string">.</span><span class="title">[</span><span class="literal">-</span><span class="title">]</span><span class="literal">+++++</span></span><br><span class="line"> <span class="literal">+++++</span><span class="string">.</span></span><br></pre></td></tr></table></figure>

<p>虽说语言的威力依使用者本身的修为高低而定,但不同语言本身的设计又有不同。若让用Java 写写操作系统内核、Perl 写写驱动程序、C&#x2F;C++写写web 应用,都无异于舍近求远,好刀只用上了刀背。</p>
<p>Lua 本身是以简单优雅为本,着眼于处理那些C不擅长的任务。借助C&#x2F;C++为其扩<br>展,Lua 可闪现无穷魅力。Lua 本身完全遵循 ANSIC而写成,只要有C 编译器的地方,Lua 便可发挥她的力量。Lua 不需要追求Python 那样的大而全的库,太多的累赘,反而会破坏她的优美。</p>
<p>语言的优美,来自于使用者自己的感悟。Lua 的优雅,也只有使用后才会明白。</p>
<p>扬起帆,让我们一同踏上Lua的学习之旅······</p>
<p>本书的翻译,是<a class="link"   target="_blank" rel="noopener" href="http://www.luachina.net中朋友们共同努力的结果./" >www.luachina.net中朋友们共同努力的结果。<i class="fas fa-external-link-alt"></i></a></p>
<p>注：校对工作在进行。</p>
<h1 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h1><p>第一篇 语言<br>第0章 序言<br>0.1序言<br>0.2 Lua的使用者<br>0.3 Lua的相关资源<br>0.4 本书的体例<br>0.5关于本书<br>0.6感谢<br>第1章 起点<br>1.1 Chunks<br>1.2 全局变量<br>1.3 词法约定<br>1.4 命令行方式<br>第2章 类型和值<br>2.1 Nil<br>2.2 Booleans<br>2.3 Numbers<br>2.4 Strings<br>2.5 Functions<br>2.6 Userdata and Threads<br>第3章 表达式<br>3.1 算术运算符<br>3.2 关系运算符<br>3.3 逻辑运算符<br>3.4 连接运算符<br>3.5优先级<br>3.6 表的构造<br>第4章 基本语法<br>4.1 赋值语句<br>4.2局部变量与代码块(block)<br>4.3 控制结构语句<br>4.4 break和return语句<br>第5章函数<br>5.1 返回多个结果值<br>5.2 可变参数<br>5.3命名参数<br>第6章 再论函数<br>6.1闭包<br>6.2非全局函数<br>6.3正确的尾调用(Proper TailCalls)<br>第7章 迭代器与泛型for<br>7.1 迭代器与闭包<br>7.2 范性for的语义<br>7.3无状态的迭代器<br>7.4 多状态的迭代器<br>7.5 真正的迭代器<br>第8章编译·运行·调试<br>8.1 require函数<br>8.2 C Packages<br>8.3 错误<br>8.4 异常和错误处理<br>8.5错误信息和回跟踪(Tracebacks)<br>第9章 协同程序<br>9.1 协同的基础<br>9.2管道和过滤器<br>9.3用作迭代器的协同<br>9.4 非抢占式多线程<br>第10章 完整示例<br>10.1 Lua作为数据描述语言使用<br>10.2 马尔可夫链算法</p>
<h1 id="第0章序言"><a href="#第0章序言" class="headerlink" title="第0章序言"></a>第0章序言</h1><p>本章包括作者的序言、文章的体例(convention)以及其它一些“每本书开头都会的内容”</p>
<h2 id="0-1序言"><a href="#0-1序言" class="headerlink" title="0.1序言"></a>0.1序言</h2><p>目前很多程序语言都专注于帮你编写成千上万行的代码,所以此类型的语言所提供的包、命名空间、复杂的类型系统及无数的结构,有上千页的文档需要操作者学习。</p>
<p>而Lua 并不帮你编写大量的代码的程序,相反的,Lua 仅让你用少量的代码解决关键问题。为实现这个目标,像其他语言一样Lua 依赖于其可扩展性。但是与其他语言不同的是,不仅用Lua 编写的软件易于扩展,而且用其他语言比如C&#x2F;C++编写的软件也很容易使用Lua扩展其功能。</p>
<p>一开始,Lua 就被设计成很容易和传统的C&#x2F;C++整合的语言。这种语言的二元性带来了极大的好处。Lua 是一个小巧而简单的语言,因为Lua 不致力于做C语言已经做得这些任务。Lua 所提供的机制是C不善于的：高级语言、动态结构、简洁、易于测试和调试等。正因为如此,Lua 具有良好的安全保证,自动内存管理,简便的字符串处理功能及其他动态数据的改变。</p>
<p>Lua 不仅是一种易于扩展的语言,也是一种易整合语言(glue language)；Lua 支持情况下,组件使用像C&#x2F;C++等静态的语言编写。但Lua 是我们整合各个组件的粘合剂。又通常情况下,组件(或对象)表现为具体在程序开发过程中很少变化的、占用大量CPU时间的决定性的程序,例如窗口部件和数据结构。对那种在产品的生命周期内变化比较多的应用方向使用Lua可以更方便的适应变化。除了作为整合语言外,Lua自身也是一个功能强大的语言。Lua 不仅可以整合组件,还可以编辑组件甚至完全使用Lua 创建组件。</p>
<p>除了Lua 外,还有很多类似的脚本语言,例如：Perl、Tcl、Ruby、Forth、Python。虽然其他语言在某些方面与Lua 有着共同的特色,但下面这些特征是Lua 特有的:</p>
<p>① 可扩展性。Lua 的扩展性非常卓越,以至于很多人把 Lua 用作搭建领域语言的工具(注：比如游戏脚本)。Lua 被设计为易于扩展的,可以通过Lua 代码或者C代码扩展,Lua 的很多功能都是通过外部库来扩展的。Lua 很容易与 C&#x2F;C++、java、fortran、Smalltalk、Ada,以及其他语言接口。</p>
<p>②简单。Lua 本身简单,小巧；内容少但功能强大,这使得Lua 易于学习,很容易实现一些小的应用。他的完全发布版(代码、手册以及某些平台的二进制文件)！！仅用一张软盘就可以装得下。</p>
<p>③高效率。Lua 有很高的执行效率,统计表明 Lua 是目前平均效率最高的脚本语言。</p>
<p>④与平台无关。Lua 几乎可以运行在所有我们听说过的系统上,如 NextStep、OS&#x2F;2、PlayStation II (Sony)、Mac OS-9、OS X、BeOS、MS-DOS、IBMmainframes、EPOC、PalmOS、MCF5206eLITE Evaluation Board、RISCOS,及所有的 Windows 和 Unix。Lua 不是通过使用条件编译实现平台无关,而是完全使用 ANSI(ISO)C,这意味着只要你有ANSIC 编译器你就可以编译并使用Lua。</p>
<p>Lua 大部分强大的功能来自于他的类库,这并非偶然。Lua 的长处之一就是可以通过新类型和函数来扩展其功能。动态类型检查最大限度允许多态出现,并自动简化调用内存管理的接口,因为这样不需要关心谁来分配内存谁来释放内存,也不必担心数据溢出。高级函数和匿名函数均可以接受高级参数,使函数更为通用。</p>
<p>Lua自带一个小规模的类库。在受限系统中使用Lua,如嵌入式系统,我们可以有留需要的函数。记住：Lua是很小的(即使加上全部的标准库)并且在大部分系统下你仍可以不用担心的使用全部的功能。</p>
<h2 id="0-2-Lua的使用者"><a href="#0-2-Lua的使用者" class="headerlink" title="0.2 Lua的使用者"></a>0.2 Lua的使用者</h2><p>Lua 使用者分为三大类：使用 Lua 嵌入到其他应用中的、独立使用Lua 的、将 Lua和C混合使用的。</p>
<p>第一：很多人使用Lua 嵌入在应用程序,比如CGILua(搭建动态网页)、LuaOrb(访问CORBA对象。这些类型用Lua-API注册新函数,创建新类型,通过配置Lua 就可以改变应用宿主语言的行为。通常,这种应用的使用者并不知道Lua是一种独立的语言。例如：CGILua用户一般会认为Lua是一种用于Web 的语言。</p>
<p>第二：作为一种独立运行的语言,Lua 也是很有用的,主要用于文本处理或者只运行一次的小程序。这种应用Lua主要使用它的标准库来实现,标准库提供模式匹配和其它一些字串处理的功能。我们可以这样认为：Lua是文本处理领域的嵌入式语言。</p>
<p>第三：还有一些使用者使用其他语言开发,把Lua 当作库使用。这些人大多使用C语言开发,但使用Lua建立简单灵活易于使用的接口。</p>
<p>本书面向以上三类读者。书的第一部分阐述了语言的本身,展示语言的潜在功能。我们讲述了不同的语言结构,并用一些例子展示如何解决实际问题。这部分既包括基本的语言的控制结构,也包括高级的迭代子和协同。</p>
<p>第二部分重点放在 Lua 特有的数据结构一—tables 上,讨论了数据结构、持久性、包及面向对象编程,这里我们将看到Lua的真正强大之处。</p>
<p>第三部分介绍标准库。每个标准库一章：数学库、table 库、string 库、ⅡO 库、OS库、Debug 库。</p>
<p>最后一部分介绍了 Lua 和 C 接口的 API,这部分介绍在C语言中开发应用而不是Lua 中,应用对于那些打算将Lua 嵌入到C&#x2F;C++中的读者可能会对此部分更感兴趣。</p>
<h2 id="0-3-Lua的相关资源"><a href="#0-3-Lua的相关资源" class="headerlink" title="0.3 Lua的相关资源"></a>0.3 Lua的相关资源</h2><p>如果你真得想学一门语言,参考手册是必备的。本书和Lua参考手册互为补充,手册仅仅描述语言本身,因此他既不会告诉你语言的数据结构也不会举例说明,但手册是Lua 的权威性文档,<a class="link"   target="_blank" rel="noopener" href="http://www.lua.org/" >http://www.lua.org<i class="fas fa-external-link-alt"></i></a> 可以得到手册的内容。</p>
<ul>
<li>Lua 用户社区,提供了一些第三方包和文档：<a class="link"   target="_blank" rel="noopener" href="http://lua-users.org/" >http://lua-users.org<i class="fas fa-external-link-alt"></i></a></li>
<li>本书的更新勘误表,代码和例子：<a class="link"   target="_blank" rel="noopener" href="http://www.inf.puc-rio.br/~roberto/book/" >http://www.inf.puc-rio.br/~roberto/book/<i class="fas fa-external-link-alt"></i></a></li>
</ul>
<p>另外本书仅针对Lua 5.0,如果你的版本不同,请查阅Lua 手册或者比较版本间的差异。</p>
<h2 id="0-4本书的体例"><a href="#0-4本书的体例" class="headerlink" title="0.4本书的体例"></a>0.4本书的体例</h2><p>&lt;1&gt;字符串使用双引号,比如”literal strings”；单字符使用单引号,比如’a’；模式串也是用单引号,比如’[%w_]*’。</p>
<p>&lt;2&gt; 符号–&gt;表示语句的输出或者表达式的结果：</p>
<p><img src="/%5C2025_04_08_lua%5C3.png"></p>
<p>&lt;3&gt;符号&lt;–&gt;表示等价,即对于 Lua 来说,用 this 与 that 没有区别。</p>
<p><img src="/%5C2025_04_08_lua%5Cc4cb33403a31074c79c7ba8c2882b6a6243e30cd4a1cc1f29d3b83444baa5fb2.png"></p>
<h2 id="0-5关于本书"><a href="#0-5关于本书" class="headerlink" title="0.5关于本书"></a>0.5关于本书</h2><p>开始打算写这本书是1998 年冬天(南半球),那时候Lua 版本是3.1；2000 年v4.0;2003 年 v5.0。</p>
<p>很明显的是,这些变化给本书带来很大的冲击,有些内容失去了它存在理由,比如关于超值(upvalues)的复杂的解释。一些章节被重写,比如CAPI,另外一些章节被增加进来,比如协同处理。</p>
<p>不太明显的是,Lua 语言本身的发展对本书的完成也产生了很大的影响。一些语言的变化在本书中并没有被涵盖进来,这并非偶然的。在本书的创作过程中,有的时候在当你想尽力去解释清楚如何使用的前提是你应该觉得使用这个东西很容易,这表明Lua某些地方需要被改进。还有的时候,我顺利的写完某个章节,结果却是没有人能看得懂我写的或者没有人对我在这个章节内表达的观点达成一致。大部分情况下,这是我的过错因为我是个作家,偶尔我也会因此发现语言本身的一些需要改进的缺陷(举例来说,从upvalues 到lexical scoping 的转变是由无意义的尝试所带来的抱怨所引发的,在此书的先前的草稿里,把 upvalues 形容成是lexical scoping 的一种)。</p>
<p>本书的完成必须服从语言的变化,本书在这个时候完成的原因：</p>
<p>&lt;1&gt;Lua5.0是一个成熟的版本</p>
<p>&lt;2&gt;语言变得越来越大,超出了最初本书的目标。此外一个原因是我迫切的想将Lua 介绍给大家让更多的人了解Lua</p>
<h2 id="0-6感谢"><a href="#0-6感谢" class="headerlink" title="0.6感谢"></a>0.6感谢</h2><p>在完成本书的过程中,很多人给了我极大的帮助：</p>
<p>Luiz Henrique de Figueiredo 和 Waldemar Celes 给了我很大的帮助,使得本书能够更好完成,LuizHenrique 也帮助设计了本书的内部。</p>
<p>Noemi Rodriguez,André Carregal, Diego Nehab,以及 Gavin Wraith 阅读了本书的草稿提出了很多有价值的建议。</p>
<p>Renato Cerqueira, Carlos Cassino, Tomas Guisasola, Joe Myers 和 Ed Ferguson 也提出了很多重要的建议。</p>
<p>Alexandre Nakonechnyj负责本书的封面和内部设计。</p>
<p>Rosane Teles 负责CIP数据的准备。</p>
<p>谢谢他们所有人。</p>
<h1 id="第1章起点"><a href="#第1章起点" class="headerlink" title="第1章起点"></a>第1章起点</h1><p>写一个最最简单的程序—Hello World。</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">print</span>(<span class="string">&quot;Hello World&quot;</span>)</span><br></pre></td></tr></table></figure>

<p>假定你把上面这句保存在 hello.lua 文件中,你在命令行只需要:</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">prompt&gt; lua hello.lua </span><br></pre></td></tr></table></figure>
<p>让我们来看一个稍微复杂点的例子:</p>
<p><img src="/%5C2025_04_08_lua%5C1ffa0092d9c846b769dc15b1acb93672527c3115745a09a6a37f9e5cc937bbd6.png"></p>
<p>这个例子定义了一个函数,计算输入参数n 的阶乘；本例要求用户输入一个数字 n,然后打印 n 的阶乘。</p>
<h2 id="1-1-Chunks"><a href="#1-1-Chunks" class="headerlink" title="1.1 Chunks"></a>1.1 Chunks</h2><p>Chunk 是一系列语句,Lua 执行的每一块语句,比如一个文件或者交互模式下的每-行都是一个Chunk。</p>
<p>每个语句结尾的分号(;)是可选的,但如果同一行有多个语句最好用；分开</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">a = <span class="number">1</span>   b = a*<span class="number">2</span>    <span class="comment">-- ugly, but valid </span></span><br></pre></td></tr></table></figure>

<p>一个Chunk 可以是一个语句,也可以是一系列语句的组合,还可以是函数,Chunk可以很大,在Lua 中几个 MByte 的 Chunk是很常见的。</p>
<p>你还可以以交互模式运行Lua,不带参数运行Lua:</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Lua 5.0  Copyright © 1994-2003 Tecgraf, PUC-Rio </span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure>

<p>你键入的每个命令（比如：”Hello World”）在你键入回车之后立即被执行，键入文件结束符可以退出交互模式（Ctrl-D in Unix, Ctrl-Z in DOS&#x2F;Windows），或者调用OS库的os.exit()函数也可以退出。 </p>
<p>在交互模式下,Lua 通常把每一个行当作一个Chunk,但如果Lua一行不是一个完整的Chunk 时,他会等待继续输入直到得到一个完整的Chunk.在Lua 等待续行时,显示不同的提示符(一般是&gt;&gt;).</p>
<p>可以通过指定参数让Lua 执行一系列Chunk。例如：假定一个文件 a 内有单个语句x&#x3D;1；另一个文件b 有语句 print(x)</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">prompt&gt; lua -la -lb</span><br></pre></td></tr></table></figure>

<p>命令首先在一个 Chunk 内先运行 a 然后运行 b。(注意：-1选项会调用 require,将会在指定的目录下搜索文件,如果环境变量没有设好,上面的命令可能不能正确运行。我们将在 8.1节详细更详细的讨论 the require function)</p>
<p>-i选项要求Lua运行指定Chunk后进入交互模式</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">prompt&gt; lua -i -la -lb</span><br></pre></td></tr></table></figure>

<p>将在一个 Chunk 内先运行 a 然后运行b,最后直接进入交互模式。</p>
<p>另一个连接外部 Chunk 的方式是使用 dofile 函数,dofile 函数加载文件并执行它.假设有一个文件:</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- file &#x27;lib1.lua&#x27; </span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">norm</span> <span class="params">(x, y)</span></span> </span><br><span class="line">    <span class="keyword">local</span> n2 = x^<span class="number">2</span> + y^<span class="number">2</span> </span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">math</span>.<span class="built_in">sqrt</span>(n2) </span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">twice</span> <span class="params">(x)</span></span> </span><br><span class="line">    <span class="keyword">return</span> <span class="number">2</span>*x </span><br><span class="line"><span class="keyword">end</span> </span><br></pre></td></tr></table></figure>

<p>在交互模式下:</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt; dofile(<span class="string">&quot;lib1.lua&quot;</span>)  -- load your library </span><br><span class="line">&gt; n = norm(3.4, 1.0) </span><br><span class="line">&gt; <span class="built_in">print</span>(twice(n))   --&gt; 7.0880180586677 </span><br></pre></td></tr></table></figure>

<p>-i 和 dofile 在调试或者测试 Lua 代码时是很方便的。</p>
<h2 id="1-2全局变量"><a href="#1-2全局变量" class="headerlink" title="1.2全局变量"></a>1.2全局变量</h2><p>全局变量不需要声明,给一个变量赋值后即创建了这个全局变量,访问一个没有初始化的全局变量也不会出错,只不过得到的结果是：nil.</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">print</span>(b)  <span class="comment">--&gt; nil </span></span><br><span class="line">b = <span class="number">10</span>  </span><br><span class="line"><span class="built_in">print</span>(b)  <span class="comment">--&gt; 10 </span></span><br></pre></td></tr></table></figure>
<p>如果你想删除一个全局变量,只需要将变量负值为 nil</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">b = <span class="literal">nil</span> </span><br><span class="line"><span class="built_in">print</span>(b)  <span class="comment">--&gt; nil </span></span><br></pre></td></tr></table></figure>

<p>这样变量 b 就好像从没被使用过一样.换句话说,当且仅当一个变量不等于 nil 时,这个变量存在。</p>
<h2 id="1-3词法约定"><a href="#1-3词法约定" class="headerlink" title="1.3词法约定"></a>1.3词法约定</h2><p>标示符：字母(letter)或者下划线开头的字母、下划线、数字序列.最好不要使用下划线加大写字母的标示符,因为Lua 的保留字也是这样的。Lua 中,letter 的含义是依赖于本地环境的。</p>
<p>保留字：以下字符为Lua 的保留字,不能当作标识符。</p>
<p><img src="/%5C2025_04_08_lua%5C98a939c34fb84f1d49129a755e0fc0fc2d3fd26747f1b68c190096278257acec.png"></p>
<p>注意：Lua是大小写敏感的.</p>
<p>注释：单行注释:–</p>
<p>多行注释：–[[ –]]</p>
<p><img src="/%5C2025_04_08_lua%5Ccd2f4c195c3adb35f05830071b512a52ef18f4a83654ae97d037661c0b17f345.png"></p>
<h2 id="1-4命令行方式"><a href="#1-4命令行方式" class="headerlink" title="1.4命令行方式"></a>1.4命令行方式</h2><p>lua [options] [script [args]]</p>
<p>-e：直接将命令传入Lua</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">prompt&gt; lua -e <span class="string">&quot;print(math.sin(12))&quot;</span> <span class="comment">--&gt; -0.53657291800043</span></span><br></pre></td></tr></table></figure>

<p>-l：加载一个文件.</p>
<p>-i：进入交互模式.</p>
<p>_PROMPT内置变量作为交互模式的提示符</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">prompt&gt; lua -i -e <span class="string">&quot;_PROMPT=&#x27; lua&gt; &#x27;&quot;</span> </span><br><span class="line">lua&gt; </span><br></pre></td></tr></table></figure>

<p>Lua 的运行过程,在运行参数之前,Lua 会查找环境变量 LUA_INIT 的值,如果变量存在并且值为@filename,Lua 将加载指定文件。如果变量存在但不是以@开头,Lua假定 filename 为 Lua 代码文件并且运行他。利用这个特性,我们可以通过配置,灵活的设置交互模式的环境。可以加载包,修改提示符和路径,定义自己的函数,修改或者重名名函数等。</p>
<p>全局变量 arg 存放 Lua 的命令行参数。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">prompt&gt; lua script a b c </span><br></pre></td></tr></table></figure>

<p>在运行以前,Lua 使用所有参数构造 arg 表。脚本名索引为O,脚本的参数从1开始增加。脚本前面的参数从-1开始减少。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">prompt&gt; lua -e <span class="string">&quot;sin=math.sin&quot;</span> script a b </span><br></pre></td></tr></table></figure>

<p>arg 表如下:</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">arg</span>[<span class="number">-3</span>] = <span class="string">&quot;lua&quot;</span> </span><br><span class="line"><span class="built_in">arg</span>[<span class="number">-2</span>] = <span class="string">&quot;-e&quot;</span> </span><br><span class="line"><span class="built_in">arg</span>[<span class="number">-1</span>] = <span class="string">&quot;sin=math.sin&quot;</span> </span><br><span class="line"><span class="built_in">arg</span>[<span class="number">0</span>] = <span class="string">&quot;script&quot;</span> </span><br><span class="line"><span class="built_in">arg</span>[<span class="number">1</span>] = <span class="string">&quot;a&quot;</span> </span><br><span class="line"><span class="built_in">arg</span>[<span class="number">2</span>] = <span class="string">&quot;b&quot;</span> </span><br></pre></td></tr></table></figure>

<h1 id="第2章-类型和值"><a href="#第2章-类型和值" class="headerlink" title="第2章 类型和值"></a>第2章 类型和值</h1><p>Lua 是动态类型语言,变量不要类型定义。Lua 中有8个基本类型分别为:nil、boolean、number、string、userdata、function、thread 和 table。函数 type 可以测试给定变量或者值的类型。</p>
<p><img src="/%5C2025_04_08_lua%5C2417542e9f91a709b8a4b36e9e3e4f0c9696fa372605cf8595d0287faa852cb7.png"></p>
<p>变量没有预定义的类型,每一个变量都可能包含任一种类型的值。</p>
<p><img src="/%5C2025_04_08_lua%5Cbc384ece86c9cfcc84830aac559d23f12e99854702e4d65050560d1f8bd47f42.png"></p>
<p>注意上面最后两行,我们可以使用 function 像使用其他值一样使用(更多的介绍参考第六章)。一般情况下同一变量代表不同类型的值会造成混乱,最好不要用,但是特殊情况下可以带来便利,比如nil。</p>
<h2 id="2-1-Nil"><a href="#2-1-Nil" class="headerlink" title="2.1 Nil"></a>2.1 Nil</h2><p>Lua 中特殊的类型,他只有一个值：nil; ；一个全局变量没有被赋值以前默认值为 nil;给全局变量负 nil 可以删除该变量。</p>
<h2 id="2-2-Booleans"><a href="#2-2-Booleans" class="headerlink" title="2.2 Booleans"></a>2.2 Booleans</h2><p>两个取值 false 和 true。但要注意Lua 中所有的值都可以作为条件。在控制结构的条件中除了false 和 nil为假,其他值都为真。所以Lua认为O和空串都是真。</p>
<h2 id="2-3-Numbers"><a href="#2-3-Numbers" class="headerlink" title="2.3 Numbers"></a>2.3 Numbers</h2><p>表示实数,Lua 中没有整数。一般有个错误的看法CPU运算浮点数比整数慢。事实不是如此,用实数代替整数不会有什么误差(除非数字大于100,000,000,000,000)。Lua的 numbers 可以处理任何长整数不用担心误差。你也可以在编译Lua 的时候使用长整型或者单精度浮点型代替 numbers,在一些平台硬件不支持浮点数的情况下这个特性是非常有用的,具体的情况请参考Lua发布版所附的详细说明。和其他语言类似,数字常量的小数部分和指数部分都是可选的,数字常量的例子:</p>
<p><img src="/%5C2025_04_08_lua%5C3bd71cb8f1dcca8142c15fc7dfda196787337d3f40884695c58347208c747cdb.png"></p>
<h2 id="2-4-Strings"><a href="#2-4-Strings" class="headerlink" title="2.4 Strings"></a>2.4 Strings</h2><p>指字符的序列。lua是8位字节,所以字符串可以包含任何数值字符,包括嵌入的0。这意味着你可以存储任意的二进制数据在一个字符串里。Lua 中字符串是不可以修改的,你可以创建一个新的变量存放你要的字符串,如下:</p>
<p><img src="/%5C2025_04_08_lua%5Cc59792c975be49375d52c3e8bbc57110f9dc1ed6f828b2af6a333223c3fed2dc.png"></p>
<p>string 和其他对象一样,Lua 自动进行内存分配和释放,一个 string 可以只包含一个字母也可以包含一本书,Lua 可以高效的处理长字符串,1M 的 string 在Lua 中是很常见的。可以使用单引号或者双引号表示字符串</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">a = <span class="string">&quot;a line&quot;</span></span><br><span class="line">b = <span class="string">&#x27;another line&#x27;</span></span><br></pre></td></tr></table></figure>

<p>为了风格统一,最好使用一种,除非两种引号嵌套情况。对于字符串中含有引号的情况还可以使用转义符来表示。Lua 中的转义序列有:</p>
<p><img src="/%5C2025_04_08_lua%5Cbed1a43e861d77120dbef29dc1f2dcc2882bb3d47eda29af31a2623f7832cecf.png"><br><img src="/%5C2025_04_08_lua%5Cb02800e2c9da02f27e18e63b376f0721898a8bbac494a3498527c86e17342e66.png"></p>
<p>例子：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&gt; <span class="built_in">print</span>(<span class="string">&quot;one line\nnext line\n\&quot;in quotes\&quot;, &#x27;in quotes&#x27;&quot;</span>) </span><br><span class="line">one line </span><br><span class="line">next line </span><br><span class="line"><span class="string">&quot;in quotes&quot;</span>, <span class="string">&#x27;in quotes&#x27;</span> </span><br><span class="line">&gt; <span class="built_in">print</span>(<span class="string">&#x27;a backslash inside quotes: \&#x27;</span>\\\&#x27;<span class="string">&#x27;) </span></span><br><span class="line"><span class="string">a backslash inside quotes: &#x27;</span>\&#x27; </span><br><span class="line">&gt; <span class="built_in">print</span>(<span class="string">&quot;a simpler way: &#x27;\\&#x27;&quot;</span>) </span><br><span class="line">a simpler way: <span class="string">&#x27;\&#x27;</span></span><br></pre></td></tr></table></figure>

<p>还可以在字符串中使用\ddd(ddd 为三位十进制数字)方式表示字母。</p>
<p>“alo\n123&quot;“和\97lo\10\04923”是相同的。</p>
<p>还可以使用[[…]]表示字符串。这种形式的字符串可以包含多行也,可以嵌套且不会解释转义序列,如果第一个字符是换行符会被自动忽略掉。这种形式的字符串用来包含一段代码是非常方便的。</p>
<p><img src="/%5C2025_04_08_lua%5Cbbe1109b4961d81f31afe93186841e8dfd897aaf0ff2ccff57011b149d0cf400.png"></p>
<p>运行时,Lua 会自动在 string 和 numbers 之间自动进行类型转换,当一个字符串使用算术操作符时,string 就会被转成数字。</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">print</span>(<span class="string">&quot;10&quot;</span> + <span class="number">1</span>)    <span class="comment">--&gt; 11 </span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;10 + 1&quot;</span>)    <span class="comment">--&gt; 10 + 1 </span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;-5.3e - 10&quot;</span> * <span class="string">&quot;2&quot;</span>) <span class="comment">--&gt; -1.06e-09 </span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;hello&quot;</span> + <span class="number">1</span>)   <span class="comment">-- ERROR (cannot convert &quot;hello&quot;) </span></span><br></pre></td></tr></table></figure>

<p>反过来,当Lua 期望一个 string 而碰到数字时,会将数字转成 string。</p>
<p><img src="/%5C2025_04_08_lua%5C287c301037b15ac318f435eb666ec9324c1a8bbce80488185248bcab4dc3f2f1.png"></p>
<p>..在Lua 中是字符串连接符,当在一个数字后面写..时,必须加上空格以防止被解释错。</p>
<p>尽管字符串和数字可以自动转换,但两者是不同的,像10&#x3D;&#x3D;”10”这样的比较永远都是错的。如果需要显式将 string 转成数字可以使用函数tonumberO,如果 string 不是正确的数字该函数将返回 nil。</p>
<p><img src="/%5C2025_04_08_lua%5Cb071c14851018b0f2ff71e8b45df256fde2cd6cd9d1a9583c26b58e988bec360.png"></p>
<p>反之,可以调用 tostring()将数字转成字符串,这种转换一直有效:</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">print</span>(<span class="built_in">tostring</span>(<span class="number">10</span>) == <span class="string">&quot;10&quot;</span>)  <span class="comment">--&gt; true </span></span><br><span class="line"><span class="built_in">print</span>(<span class="number">10</span> .. <span class="string">&quot;&quot;</span> == <span class="string">&quot;10&quot;</span>)   <span class="comment">--&gt; true </span></span><br></pre></td></tr></table></figure>

<h2 id="2-5-Functions"><a href="#2-5-Functions" class="headerlink" title="2.5 Functions"></a>2.5 Functions</h2><p>函数是第一类值(和其他变量相同),意味着函数可以存储在变量中,可以作为函数的参数,也可以作为函数的返回值。这个特性给了语言很大的灵活性：一个程序可以重新定义函数增加新的功能或者为了避免运行不可靠代码创建安全运行环境而隐藏函数,此外这特性在Lua 实现面向对象中也起了重要作用(在第16章详细讲述)。</p>
<p>Lua 可以调用 lua 或者C 实现的函数,Lua 所有标准库都是用C 实现的。标准库包括 string 库、table 库、IO库、OS 库、算术库、debug 库。</p>
<h2 id="2-6-Userdata-and-Threads"><a href="#2-6-Userdata-and-Threads" class="headerlink" title="2.6 Userdata and Threads"></a>2.6 Userdata and Threads</h2><p>userdata 可以将C数据存放在Lua 变量中,userdata 在Lua 中除了赋值和相等比较外没有预定义的操作。userdata 用来描述应用程序或者使用C 实现的库创建的新类型。例如：用标准IO 库来描述文件。下面在CAPI章节中我们将详细讨论。</p>
<p>在第九章讨论协同操作的时候,我们介绍线程。</p>
<h1 id="第3章表达式"><a href="#第3章表达式" class="headerlink" title="第3章表达式"></a>第3章表达式</h1><p>Lua 中的表达式包括数字常量、字符串常量、变量、一元和二元运算符、函数调用。还可以是非传统的函数定义和表构造。</p>
<h2 id="3-1算术运算符"><a href="#3-1算术运算符" class="headerlink" title="3.1算术运算符"></a>3.1算术运算符</h2><p>二元运算符：+－＊／～(加减乘除幂)</p>
<p>元运算符：- (负值)</p>
<p>这些运算符的操作数都是实数。</p>
<h2 id="3-2关系运算符"><a href="#3-2关系运算符" class="headerlink" title="3.2关系运算符"></a>3.2关系运算符</h2><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;   &gt;   &lt;=  &gt;=  ==  ~=</span><br></pre></td></tr></table></figure>
<p>这些操作符返回结果为 false 或者 true；&#x3D;&#x3D;和~&#x3D;比较两个值,如果两个值类型不同,Lua 认为两者不同；nil 只和自己相等。Lua 通过弓用比较 tables、userdata、functions。也就是说当且仅当两者表示同一个对象时相等。</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">a = &#123;&#125;; a.x = <span class="number">1</span>; a.y = <span class="number">0</span> </span><br><span class="line">b = &#123;&#125;; b.x = <span class="number">1</span>; b.y = <span class="number">0</span> </span><br><span class="line">c = a </span><br><span class="line">a==c but a~=b </span><br></pre></td></tr></table></figure>

<p>Lua 比较数字按传统的数字大小进行,比较字符串按字母的顺序进行,但是字母顺序依赖于本地环境。</p>
<p>当比较不同类型的值的时候要特别注意:</p>
<p><img src="/%5C2025_04_08_lua%5C59db53d1fce1907fab25871fc67196ee3b4ef887dc82da8ae5644ae7cebb21a8.png"></p>
<p>为了避免不一致的结果,混合比较数字和字符串,Lua 会报错,比如：2&lt;”15”</p>
<h2 id="3-3逻辑运算符"><a href="#3-3逻辑运算符" class="headerlink" title="3.3逻辑运算符"></a>3.3逻辑运算符</h2><p>and or not </p>
<p>逻辑运算符认为 false 和 nil是假(false),其他为真,O也是 true.</p>
<p>and 和 or 的运算结果不是 true 和 false,而是和它的两个操作数相关。</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">a <span class="keyword">and</span> b  <span class="comment">-- 如果a为false，则返回a，否则返回b </span></span><br><span class="line">a <span class="keyword">or</span>  b   <span class="comment">-- 如果a为true，则返回a，否则返回b </span></span><br></pre></td></tr></table></figure>
<p>例如：</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">print</span>(<span class="number">4</span> <span class="keyword">and</span> <span class="number">5</span>)   <span class="comment">--&gt; 5 </span></span><br><span class="line"><span class="built_in">print</span>(<span class="literal">nil</span> <span class="keyword">and</span> <span class="number">13</span>)   <span class="comment">--&gt; nil </span></span><br><span class="line"><span class="built_in">print</span>(<span class="literal">false</span> <span class="keyword">and</span> <span class="number">13</span>)  <span class="comment">--&gt; false </span></span><br><span class="line"><span class="built_in">print</span>(<span class="number">4</span> <span class="keyword">or</span> <span class="number">5</span>)    <span class="comment">--&gt; 4 </span></span><br><span class="line"><span class="built_in">print</span>(<span class="literal">false</span> <span class="keyword">or</span> <span class="number">5</span>)   <span class="comment">--&gt; 5</span></span><br></pre></td></tr></table></figure>

<p>个很实用的技巧：如果x为 false 或者 nil 则给x赋初始值 v</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">x = x <span class="keyword">or</span> v</span><br></pre></td></tr></table></figure>
<p>等价于</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> <span class="keyword">not</span> x <span class="keyword">then</span> </span><br><span class="line">    x = v </span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>
<p>and 的优先级比 or 高。</p>
<p>C语言中的三元运算符</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ａ?ｂ:ｃ</span><br></pre></td></tr></table></figure>

<p>在Lua 中可以这样实现:</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(a <span class="keyword">and</span> b) <span class="keyword">or</span> c</span><br></pre></td></tr></table></figure>

<p>not 的结果一直返回 false 或者 true</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">print</span>(<span class="keyword">not</span> <span class="literal">nil</span>)   <span class="comment">--&gt; true </span></span><br><span class="line"><span class="built_in">print</span>(<span class="keyword">not</span> <span class="literal">false</span>)   <span class="comment">--&gt; true </span></span><br><span class="line"><span class="built_in">print</span>(<span class="keyword">not</span> <span class="number">0</span>)    <span class="comment">--&gt; false </span></span><br><span class="line"><span class="built_in">print</span>(<span class="keyword">not</span> <span class="keyword">not</span> <span class="literal">nil</span>)  <span class="comment">--&gt; false </span></span><br></pre></td></tr></table></figure>

<h2 id="3-4连接运算符"><a href="#3-4连接运算符" class="headerlink" title="3.4连接运算符"></a>3.4连接运算符</h2><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">.. <span class="comment">--两个点</span></span><br></pre></td></tr></table></figure>

<p>字符串连接,如果操作数为数字,Lua将数字转成字符串。</p>
<p><img src="/%5C2025_04_08_lua%5C5641d9c46beb685cb54ee5c28cce00de7598e165f524f4dccd0a10e3c75d9e20.png"></p>
<h2 id="3-5优先级"><a href="#3-5优先级" class="headerlink" title="3.5优先级"></a>3.5优先级</h2><p>从高到低的顺序:<br><img src="/%5C2025_04_08_lua%5Cyxj.png"></p>
<p>除了~和..外所有的二元运算符都是左连接的。</p>
<p><img src="/%5C2025_04_08_lua%5Cc47247879166ca748be621445eb94e9c56ffbbc7f15e9b7857d716d46e80e0ca.png"></p>
<h2 id="3-6表的构造"><a href="#3-6表的构造" class="headerlink" title="3.6表的构造"></a>3.6表的构造</h2><p>构造器是创建和初始化表的表达式。表是Lua特有的功能强大的东西。最简单的构造函数是,用来创建一个空表。可以直接初始化数组:</p>
<p><img src="/%5C2025_04_08_lua%5Cf7c63f45cedb818d6fe945974d6dd4762b4713b656647ef5e471971a74111c7c.png"></p>
<p>不管用何种方式创建table,我们都可以向表中添加或者删除任何类型的域,构造函数仅仅影响表的初始化。</p>
<p><img src="/%5C2025_04_08_lua%5Ce7309638b6f93ebff697fe15dbb3b38dc42fe546d7c62f19c772da3d6bd3eee0.png"></p>
<p>每次调用构造函数,Lua 都会创建一个新的 table,可以使用 table 构造一个 list:</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">list = <span class="literal">nil</span> </span><br><span class="line"><span class="keyword">for</span> line <span class="keyword">in</span> <span class="built_in">io</span>.<span class="built_in">lines</span>() <span class="keyword">do</span> </span><br><span class="line"> list = &#123;<span class="built_in">next</span>=list, value=line&#125; </span><br><span class="line"><span class="keyword">end</span> </span><br></pre></td></tr></table></figure>

<p>这段代码从标准输入读进每行,然后反序形成链表。下面的代码打印链表的内容:</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">l = list </span><br><span class="line"><span class="keyword">while</span> l <span class="keyword">do</span> </span><br><span class="line"> <span class="built_in">print</span>(l.value) </span><br><span class="line"> l = l.<span class="built_in">next</span> </span><br><span class="line"><span class="keyword">end</span> </span><br></pre></td></tr></table></figure>

<p>在同一个构造函数中可以混合列表风格和record 风格进行初始化,如:</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">polyline = &#123;color=<span class="string">&quot;blue&quot;</span>, thickness=<span class="number">2</span>, npoints=<span class="number">4</span>, </span><br><span class="line">    &#123;x=<span class="number">0</span>,   y=<span class="number">0</span>&#125;, </span><br><span class="line">    &#123;x=<span class="number">-10</span>, y=<span class="number">0</span>&#125;, </span><br><span class="line">    &#123;x=<span class="number">-10</span>, y=<span class="number">1</span>&#125;, </span><br><span class="line">    &#123;x=<span class="number">0</span>,   y=<span class="number">1</span>&#125; </span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>

<p>这个例子也表明我们可以嵌套构造函数来表示复杂的数据结构</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">print</span>(polyline[<span class="number">2</span>].x) <span class="comment">--&gt; -10</span></span><br></pre></td></tr></table></figure>

<p>上面两种构造函数的初始化方式还有限制,比如你不能使用负索引初始化一个表中元素,字符串索引也不能被恰当的表示。下面介绍一种更一般的初始化方式,我们用[expression]显示的表示将被初始化的索引:</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">opnames = &#123;[<span class="string">&quot;+&quot;</span>] = <span class="string">&quot;add&quot;</span>, [<span class="string">&quot;-&quot;</span>] = <span class="string">&quot;sub&quot;</span>, </span><br><span class="line">    [<span class="string">&quot;*&quot;</span>] = <span class="string">&quot;mul&quot;</span>, [<span class="string">&quot;/&quot;</span>] = <span class="string">&quot;div&quot;</span>&#125; </span><br><span class="line">i = <span class="number">20</span>; s = <span class="string">&quot;-&quot;</span> </span><br><span class="line">a = &#123;[i+<span class="number">0</span>] = s, [i+<span class="number">1</span>] = s..s, [i+<span class="number">2</span>] = s..s..s&#125; </span><br><span class="line"><span class="built_in">print</span>(opnames[s])  <span class="comment">--&gt; sub</span></span><br><span class="line"><span class="built_in">print</span>(a[<span class="number">22</span>])   <span class="comment">--&gt; ---</span></span><br></pre></td></tr></table></figure>

<p>list 风格初始化和 record 风格初始化是这种一般初始化的特例:</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&#123;x=<span class="number">0</span>, y=<span class="number">0</span>&#125; </span><br><span class="line">  &lt;<span class="comment">--&gt; </span></span><br><span class="line"> &#123;[<span class="string">&quot;x&quot;</span>]=<span class="number">0</span>, [<span class="string">&quot;y&quot;</span>]=<span class="number">0</span>&#125; </span><br><span class="line">&#123;<span class="string">&quot;red&quot;</span>, <span class="string">&quot;green&quot;</span>, <span class="string">&quot;blue&quot;</span>&#125; </span><br><span class="line">  &lt;<span class="comment">--&gt; </span></span><br><span class="line">     &#123;[<span class="number">1</span>]=<span class="string">&quot;red&quot;</span>, [<span class="number">2</span>]=<span class="string">&quot;green&quot;</span>, [<span class="number">3</span>]=<span class="string">&quot;blue&quot;</span>&#125; </span><br></pre></td></tr></table></figure>

<p>如果真的想要数组下标从0开始:</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">days = &#123;[<span class="number">0</span>]=<span class="string">&quot;Sunday&quot;</span>, <span class="string">&quot;Monday&quot;</span>, <span class="string">&quot;Tuesday&quot;</span>, <span class="string">&quot;Wednesday&quot;</span>, </span><br><span class="line">    <span class="string">&quot;Thursday&quot;</span>, <span class="string">&quot;Friday&quot;</span>, <span class="string">&quot;Saturday&quot;</span>&#125; </span><br></pre></td></tr></table></figure>

<p>注意：不推荐数组下标从0开始,否则很多标准库不能使用。</p>
<p>在构造函数的最后的”,”是可选的,可以方便以后的扩展。</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">a = &#123;[<span class="number">1</span>]=<span class="string">&quot;red&quot;</span>, [<span class="number">2</span>]=<span class="string">&quot;green&quot;</span>, [<span class="number">3</span>]=<span class="string">&quot;blue&quot;</span>,&#125; </span><br></pre></td></tr></table></figure>

<p>在构造函数中域分隔符逗号(“,”)可以用分号(“;”)替代,通常我们使用分号用来分割不同类型的表元素。</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;x=<span class="number">10</span>, y=<span class="number">45</span>; <span class="string">&quot;one&quot;</span>, <span class="string">&quot;two&quot;</span>, <span class="string">&quot;three&quot;</span>&#125; </span><br></pre></td></tr></table></figure>

<h1 id="第4章基本语法"><a href="#第4章基本语法" class="headerlink" title="第4章基本语法"></a>第4章基本语法</h1><p>Lua 像C和PASCAL几乎支持所有的传统语句：赋值语句、控制结构语句、函数调用等,同时也支持非传统的多变量赋值、局部变量声明。</p>
<h2 id="4-1赋值语句"><a href="#4-1赋值语句" class="headerlink" title="4.1赋值语句"></a>4.1赋值语句</h2><p>赋值是改变一个变量的值和改变表域的最基本的方法。</p>
<p><img src="/%5C2025_04_08_lua%5C5bfa8886804f8486acddd3bdb4e4427234108d1f58a7d8ae8c6306d7eddd776e.png"></p>
<p>Lua 可以对多个变量同时赋值,变量列表和值列表的各个元素用逗号分开,赋值语句右边的值会依次赋给左边的变量。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">a, b = 10, 2*x  &lt;--&gt;  a=10; b=2*x</span><br></pre></td></tr></table></figure>

<p>遇到赋值语句Lua会先计算右边所有的值然后再执行赋值操作,所以我们可以这样进行交换变量的值:</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">x, y = y, x      <span class="comment">-- swap &#x27;x&#x27; for &#x27;y&#x27; </span></span><br><span class="line">a[i], a[j] = a[j], a[i]   <span class="comment">-- swap &#x27;a[i]&#x27; for &#x27;a[i]&#x27; </span></span><br></pre></td></tr></table></figure>

<p>当变量个数和值的个数不一致时,Lua会一直以变量个数为基础采取以下策略:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">a. 变量个数&gt;值的个数    按变量个数补足nil </span><br><span class="line">b. 变量个数&lt;值的个数    多余的值会被忽略 </span><br></pre></td></tr></table></figure>
<p>例如：</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">a, b, c = <span class="number">0</span>, <span class="number">1</span>  </span><br><span class="line"><span class="built_in">print</span>(a,b,c)    <span class="comment">--&gt; 0   1   nil </span></span><br><span class="line"></span><br><span class="line">a, b = a+<span class="number">1</span>, b+<span class="number">1</span>, b+<span class="number">2</span>  <span class="comment">-- value of b+2 is ignored </span></span><br><span class="line"><span class="built_in">print</span>(a,b)      <span class="comment">--&gt; 1   2 </span></span><br><span class="line"></span><br><span class="line">a, b, c = <span class="number">0</span> </span><br><span class="line"><span class="built_in">print</span>(a,b,c)    <span class="comment">--&gt; 0   nil   nil</span></span><br></pre></td></tr></table></figure>

<p>上面最后一个例子是一个常见的错误情况,注意：如果要对多个变量赋值必须依次对每个变量赋值。</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">a, b, c = <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span> </span><br></pre></td></tr></table></figure>
<p><img src="/%5C2025_04_08_lua%5C465d44a90ba7681fd6fe1b924c88fd0fed089e272f061100528bc79cb5566605.png"></p>
<p>f()返回两个值，第一个赋给a，第二个赋给b。 </p>
<h2 id="4-2局部变量与代码块-block"><a href="#4-2局部变量与代码块-block" class="headerlink" title="4.2局部变量与代码块(block)"></a>4.2局部变量与代码块(block)</h2><p>使用local 创建一个局部变量,与全局变量不同,局部变量只在被声明的那个代码块内有效。代码块：指一个控制结构内,一个函数体,或者一个chunk(变量被声明的那个文件或者文本串)。</p>
<p><img src="/%5C2025_04_08_lua%5C460815dc70ed6298f125173d86bab49df05ae238ec5d76957dcf3323faef6b2c.png"></p>
<p>注意,如果在交互模式下上面的例子可能不能输出期望的结果,因为第二句locali&#x3D;l第二句的i已经超出了他的有效范围。可以将这段代码放在 do.end(相当于c&#x2F;c++的{})块中。</p>
<p>应该尽可能的使用局部变量,有两个好处：</p>
<ol>
<li>避免命名冲突</li>
<li>访问局部变量的速度比全局变量更快</li>
</ol>
<p>我们给 block 划定一个明确的界限：do..end 内的部分。当你想更好的控制局部变量的作用范围的时候这是很有用的。</p>
<p><img src="/%5C2025_04_08_lua%5C1fdf45dceac8409d415966970c9cbe02e1abba0e119b15ea67f184f6fe3f339e.png"></p>
<h2 id="4-3控制结构语句"><a href="#4-3控制结构语句" class="headerlink" title="4.3控制结构语句"></a>4.3控制结构语句</h2><p>控制结构的条件表达式结果可以是任何值,Lua 认为 false 和 nil 为假,其他值为真。</p>
<p>if语句,有三种形式:<br><img src="/%5C2025_04_08_lua%5Cif.png"></p>
<p>while 语句:</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> condition <span class="keyword">do</span> </span><br><span class="line"> statements; </span><br><span class="line"><span class="keyword">end</span>;</span><br></pre></td></tr></table></figure>
<p>repeat-until 语句:</p>
<p><img src="/%5C2025_04_08_lua%5C7066ecacaa7e6d2c78b85878bd3729078fb6d769c7c06e705ce58a9e2c465f8c.png"></p>
<p>for 语句有两大类:第一,数值 for 循环:</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> var=exp1,exp2,exp3 <span class="keyword">do</span> </span><br><span class="line"> loop-part </span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>

<p>for 将用 exp3 作为 step 从 expl(初始值)到 exp2(终止值),执行 loop-part。其中exp3 可以省略,默认 step&#x3D;1</p>
<p>有几点需要注意:</p>
<ol>
<li>三个表达式只会被计算一次,并且是在循环开始前。</li>
</ol>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> i=<span class="number">1</span>,f(x) <span class="keyword">do</span> </span><br><span class="line"> <span class="built_in">print</span>(i) </span><br><span class="line"><span class="keyword">end</span> </span><br><span class="line"> </span><br><span class="line"><span class="keyword">for</span> i=<span class="number">10</span>,<span class="number">1</span>,<span class="number">-1</span> <span class="keyword">do</span> </span><br><span class="line"> <span class="built_in">print</span>(i) </span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>

<p>第一个例子f(x)只会在循环前被调用一次。</p>
<ol start="2">
<li>控制变量var 是局部变量自动被声明,并且只在循环内有效.</li>
</ol>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> i=<span class="number">1</span>,<span class="number">10</span> <span class="keyword">do</span> </span><br><span class="line"> <span class="built_in">print</span>(i) </span><br><span class="line"><span class="keyword">end</span> </span><br><span class="line"><span class="built_in">max</span> = i  <span class="comment">-- probably wrong! &#x27;i&#x27; here is global </span></span><br></pre></td></tr></table></figure>

<p>如果需要保留控制变量的值,需要在循环中将其保存</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- find a value in a list </span></span><br><span class="line"><span class="keyword">local</span> found = <span class="literal">nil</span> </span><br><span class="line"><span class="keyword">for</span> i=<span class="number">1</span>,a.n <span class="keyword">do</span> </span><br><span class="line"> <span class="keyword">if</span> a[i] == value <span class="keyword">then</span> </span><br><span class="line">  found = i   <span class="comment">-- save value of &#x27;i&#x27; </span></span><br><span class="line">  <span class="keyword">break</span> </span><br><span class="line"> <span class="keyword">end</span> </span><br><span class="line"><span class="keyword">end</span> </span><br><span class="line"><span class="built_in">print</span>(found) </span><br></pre></td></tr></table></figure>

<ol start="3">
<li>循环过程中不要改变控制变量的值,那样做的结果是不可预知的。如果要退出循环,使用 break 语句。</li>
</ol>
<p>第二, 范型 for 循环:</p>
<p>前面已经见过一个例子:</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- print all values of array &#x27;a&#x27;  </span></span><br><span class="line"><span class="keyword">for</span> i,v <span class="keyword">in</span> <span class="built_in">ipairs</span>(a) <span class="keyword">do</span> <span class="built_in">print</span>(v) <span class="keyword">end</span> </span><br></pre></td></tr></table></figure>

<p>范型for遍历迭代子函数返回的每一个值。<br>再看一个遍历表key 的例子:</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- print all keys of table &#x27;t&#x27; </span></span><br><span class="line"><span class="keyword">for</span> k <span class="keyword">in</span> <span class="built_in">pairs</span>(t) <span class="keyword">do</span> <span class="built_in">print</span>(k) <span class="keyword">end</span> </span><br></pre></td></tr></table></figure>

<p>范型for 和数值for 有两点相同:</p>
<ol>
<li>控制变量是局部变量</li>
<li>不要修改控制变量的值</li>
</ol>
<p>再看一个例子,假定有一个表：</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">days = &#123;<span class="string">&quot;Sunday&quot;</span>, <span class="string">&quot;Monday&quot;</span>, <span class="string">&quot;Tuesday&quot;</span>, <span class="string">&quot;Wednesday&quot;</span>, </span><br><span class="line"><span class="string">&quot;Thursday&quot;</span>, <span class="string">&quot;Friday&quot;</span>, <span class="string">&quot;Saturday&quot;</span>&#125; </span><br></pre></td></tr></table></figure>

<p>现在想把对应的名字转换成星期几,一个有效地解决问题的方式是构造一个反向表：</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">revDays = &#123;[<span class="string">&quot;Sunday&quot;</span>] = <span class="number">1</span>, [<span class="string">&quot;Monday&quot;</span>] = <span class="number">2</span>,  </span><br><span class="line">   [<span class="string">&quot;Tuesday&quot;</span>] = <span class="number">3</span>, [<span class="string">&quot;Wednesday&quot;</span>] = <span class="number">4</span>, </span><br><span class="line">   [<span class="string">&quot;Thursday&quot;</span>] = <span class="number">5</span>, [<span class="string">&quot;Friday&quot;</span>] = <span class="number">6</span>,   </span><br><span class="line">   [<span class="string">&quot;Saturday&quot;</span>] = <span class="number">7</span>&#125; </span><br></pre></td></tr></table></figure>
<p>下面就可以很容易获取问题的答案了:</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">x = <span class="string">&quot;Tuesday&quot;</span>  </span><br><span class="line"><span class="built_in">print</span>(revDays[x])   <span class="comment">--&gt; 3 </span></span><br></pre></td></tr></table></figure>

<p>我们不需要手工,可以自动构造反向表</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">revDays = &#123;&#125;  </span><br><span class="line"><span class="keyword">for</span> i,v <span class="keyword">in</span> <span class="built_in">ipairs</span>(days) <span class="keyword">do</span> </span><br><span class="line"><span class="keyword">end</span>  </span><br></pre></td></tr></table></figure>

<p>如果你对范型for还有些不清楚在后面的章节我们会继续来学习。</p>
<h2 id="4-4-break和-return-语句"><a href="#4-4-break和-return-语句" class="headerlink" title="4.4 break和 return 语句"></a>4.4 break和 return 语句</h2><p>break语句用来退出当前循环(for,repeat,while)。在循环外部不可以使用。</p>
<p>return 用来从函数返回结果,当一个函数自然结束结尾会有一个默认的 return。(这种函数类似pascal的过程)</p>
<p>Lua 语法要求 break 和 return 只能出现在 block 的结尾一句(也就是说：作为 chunk的最后一句,或者在 end 之前,或者 else 前,或者 until 前),例如:</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">local</span> i = <span class="number">1</span> </span><br><span class="line"><span class="keyword">while</span> a[i] <span class="keyword">do</span></span><br><span class="line">    <span class="keyword">if</span> a[i] == v <span class="keyword">then</span> <span class="keyword">break</span> <span class="keyword">end</span> </span><br><span class="line">    i = i + <span class="number">1</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>

<p>有时候为了调试或者其他目的需要在 block 的中间使用 return 或者 break,可以显式的使用 do..end 来实现:</p>
<p><img src="/%5C2025_04_08_lua%5C87a3c51aa6bac5888ebb084c9b6294b677af2f38b2b86162b48e763da6e2186a.png"></p>
<h1 id="第5章函数"><a href="#第5章函数" class="headerlink" title="第5章函数"></a>第5章函数</h1><p>函数有两种用途：1.完成指定的任务,这种情况下函数作为调用语句使用；2.计算并返回值,这种情况下函数作为赋值语句的表达式使用。</p>
<p>语法:</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">func_name</span> <span class="params">(arguments-list)</span></span> </span><br><span class="line"> statements-list; </span><br><span class="line"><span class="keyword">end</span>; </span><br></pre></td></tr></table></figure>

<p>调用函数的时候,如果参数列表为空,必须使用()表明是函数调用。</p>
<p><img src="/%5C2025_04_08_lua%5C380357cdf7be49ffeded738e0abf9717de4e403eb50a21ae2a61e7e16f352e68.png"></p>
<p>上述规则有一个例外,当函数只有一个参数并且这个参数是字符串或者表构造的时候,()是可选的：</p>
<p><img src="/%5C2025_04_08_lua%5Cf7403927312b86a11212413e98a0ab035a518d608b7fe6046784f35d6965c2f0.png"></p>
<p>Lua 也提供了面向对象方式调用函数的语法,比如 o:foo(x)与 o.foo(o,x)是等价的,后面的章节会详细介绍面向对象内容。</p>
<p>Lua 使用的函数可以是Lua 编写也可以是其他语言编写,对于Lua程序员来说用什么语言实现的函数使用起来都一样。</p>
<p>Lua 函数实参和形参的匹配与赋值语句类似,多余部分被忽略,缺少部分用 nil补足。</p>
<p><img src="/%5C2025_04_08_lua%5C946900e79341aae641deb59de39c720336e9da57dca183d4dc05b42a4b296562.png"></p>
<h2 id="5-1返回多个结果值"><a href="#5-1返回多个结果值" class="headerlink" title="5.1返回多个结果值"></a>5.1返回多个结果值</h2><p>Lua 函数可以返回多个结果值,比如 string.find,其返回匹配串“开始和结束的下标”(如果不存在匹配串返回 nil)。</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">s, e = <span class="built_in">string</span>.<span class="built_in">find</span>(<span class="string">&quot;hello Lua users&quot;</span>, <span class="string">&quot;Lua&quot;</span>) </span><br><span class="line"><span class="built_in">print</span>(s, e)  <span class="comment">--&gt; 7 9</span></span><br></pre></td></tr></table></figure>

<p>Lua 函数中,在return 后列出要返回的值得列表即可返回多值,如:</p>
<p><img src="/%5C2025_04_08_lua%5C47b96b33e8423f76dd08b652af01046c7178897f0ff10688e8e68f5a65e2080c.png"></p>
<p>Lua总是调整函数返回值的个数去适用调用环境,当作为一个语句调用函数时,所有返回值被忽略。假设有如下三个函数:</p>
<p><img src="/%5C2025_04_08_lua%5Ced2fa320923f6364020bd9a2571bae132fcb423f2b340f6dc59d4343a9dab20f.png"></p>
<p>第一,当作为表达式调用函数时,有以下几种情况:</p>
<ol>
<li><p>当调用作为表达式最后一个参数或者仅有一个参数时,根据变量个数函数尽可能多地返回多个值,不足补 nil,超出舍去。</p>
</li>
<li><p>其他情况下,函数调用仅返回第一个值 (如果没有返回值为 nil)</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">x,y = foo2()    <span class="comment">-- x=&#x27;a&#x27;, y=&#x27;b&#x27; </span></span><br><span class="line">x = foo2()     <span class="comment">-- x=&#x27;a&#x27;, &#x27;b&#x27; is discarded </span></span><br><span class="line">x,y,z = <span class="number">10</span>,foo2()   <span class="comment">-- x=10, y=&#x27;a&#x27;, z=&#x27;b&#x27; </span></span><br><span class="line"> </span><br><span class="line">x,y = foo0()    <span class="comment">-- x=nil, y=nil </span></span><br><span class="line">x,y = foo1()    <span class="comment">-- x=&#x27;a&#x27;, y=nil </span></span><br><span class="line">x,y,z = foo2()   <span class="comment">-- x=&#x27;a&#x27;, y=&#x27;b&#x27;, z=nil </span></span><br><span class="line"></span><br><span class="line">x,y = foo2(), <span class="number">20</span>   <span class="comment">-- x=&#x27;a&#x27;, y=20 </span></span><br><span class="line">x,y = foo0(), <span class="number">20</span>, <span class="number">30</span>  <span class="comment">-- x=&#x27;nil&#x27;, y=20, 30 is discarded </span></span><br></pre></td></tr></table></figure></li>
</ol>
<p>第二,函数调用作为函数参数被调用时,和多值赋值是相同。</p>
<p><img src="/%5C2025_04_08_lua%5C9d3b6ba5bed4f8f5a1525c3487b8c7bf1761f5fb8bf851b65c7156ada91d50ef.png"></p>
<p>第三,函数调用在表构造函数中初始化时,和多值赋值时相同。</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">a = &#123;foo0()&#125;    <span class="comment">-- a = &#123;&#125;    (an empty table) </span></span><br><span class="line">a = &#123;foo1()&#125;    <span class="comment">-- a = &#123;&#x27;a&#x27;&#125; </span></span><br><span class="line">a = &#123;foo2()&#125;    <span class="comment">-- a = &#123;&#x27;a&#x27;, &#x27;b&#x27;&#125; </span></span><br><span class="line"> </span><br><span class="line">a = &#123;foo0(), foo2(), <span class="number">4</span>&#125; <span class="comment">-- a[1] = nil, a[2] = &#x27;a&#x27;, a[3] = 4 </span></span><br></pre></td></tr></table></figure>

<p>另外,return f()这种类型的返回 f()返回的所有值</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span> <span class="params">(i)</span></span> </span><br><span class="line"> <span class="keyword">if</span> i == <span class="number">0</span> <span class="keyword">then</span> <span class="keyword">return</span> foo0() </span><br><span class="line"> <span class="keyword">elseif</span> i == <span class="number">1</span> <span class="keyword">then</span> <span class="keyword">return</span> foo1() </span><br><span class="line"> <span class="keyword">elseif</span> i == <span class="number">2</span> <span class="keyword">then</span> <span class="keyword">return</span> foo2() </span><br><span class="line"> <span class="keyword">end</span> </span><br><span class="line"><span class="keyword">end</span> </span><br><span class="line"> </span><br><span class="line"><span class="built_in">print</span>(foo(<span class="number">1</span>))   <span class="comment">--&gt; a </span></span><br><span class="line"><span class="built_in">print</span>(foo(<span class="number">2</span>))   <span class="comment">--&gt; a  b </span></span><br><span class="line"><span class="built_in">print</span>(foo(<span class="number">0</span>))   <span class="comment">-- (no results) </span></span><br><span class="line"><span class="built_in">print</span>(foo(<span class="number">3</span>))   <span class="comment">-- (no results)</span></span><br></pre></td></tr></table></figure>

<p>可以使用圆括号强制使调用返回一个值。</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">print</span>((foo0()))  <span class="comment">--&gt; nil </span></span><br><span class="line"><span class="built_in">print</span>((foo1()))  <span class="comment">--&gt; a </span></span><br><span class="line"><span class="built_in">print</span>((foo2()))  <span class="comment">--&gt; a</span></span><br></pre></td></tr></table></figure>

<p>一个return 语句如果使用圆括号将返回值括起来也将导致返回一个值。</p>
<p>函数多值返回的特殊函数unpack,接受一个数组作为输入参数,返回数组的所有元素。unpack被用来实现范型调用机制,在C语言中可以使用函数指针调用可变的函数,可以声明参数可变的函数,但不能两者同时可变。在Lua 中如果你想调用可变参数的可变函数只需要这样:</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">f(<span class="built_in">unpack</span>(a)) </span><br></pre></td></tr></table></figure>
<p>unpack返回a所有的元素作为f()的参数 </p>
<p><img src="/%5C2025_04_08_lua%5Cc5831c8835d60e0eed62b4f366fb97ec415d406eef002e929946d8c4bf795757.png"></p>
<p>预定义的 unpack 函数是用C语言实现的,我们也可以用 Lua来完成:</p>
<p><img src="/%5C2025_04_08_lua%5C3d2747545d8f3d8ddb778d5e84aca45ae27e525b162c80d846e4b596eec9cd89.png"></p>
<h2 id="5-2可变参数"><a href="#5-2可变参数" class="headerlink" title="5.2可变参数"></a>5.2可变参数</h2><p>Lua 函数可以接受可变数目的参数,和C语言类似在函数参数列表中使用三点(..)表示函数有可变的参数。Lua 将函数的参数放在一个叫 arg 的表中,除了参数以外,arg表中还有一个域n表示参数的个数。</p>
<p>例如,我们可以重写 print 函数:</p>
<p><img src="/%5C2025_04_08_lua%5C2f4d93568d186d765707dac441da4c1a49d6fa005b147f1fce891b36f6021d73.png"></p>
<p>有时候我们可能需要几个固定参数加上可变参数 </p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">function g (a, b, ...) end </span><br><span class="line"> </span><br><span class="line">CALL    PARAMETERS </span><br><span class="line"> </span><br><span class="line">g(3)    a=3, b=nil, arg=&#123;n=0&#125; </span><br><span class="line">g(3, 4)   a=3, b=4, arg=&#123;n=0&#125; </span><br><span class="line">g(3, 4, 5, 8)  a=3, b=4, arg=&#123;5, 8; n=2&#125;</span><br></pre></td></tr></table></figure>

<p>如上面所示,Lua 会将前面的实参传给函数的固定参数,后面的实参放在 arg 表中。举个具体的例子,如果我们只想要 string.find 返回的第二个值:</p>
<p>个典型的方法是使用虚变量 (下划线)</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">local _, x = string.find(s, p) </span><br><span class="line">-- now use  &#x27;x&#x27;</span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<p>还可以利用可变参数声明一个 select 函数:</p>
<p><img src="/%5C2025_04_08_lua%5C7804faff906f48c7a64ccbdfa8f32f2648bb4baa88d17a7132bbadbb59e34750.png"></p>
<p>有时候需要将函数的可变参数传递给另外的函数调用,可以使用前面我们说过的unpack(arg)返回 arg 表所有的可变参数,Lua 提供了一个文本格式化的函数 string.format(类似 C语言的 sprintf 函数):</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fwrite</span><span class="params">(fmt, ...)</span></span> </span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">io</span>.<span class="built_in">write</span>(<span class="built_in">string</span>.<span class="built_in">format</span>(fmt, <span class="built_in">unpack</span>(<span class="built_in">arg</span>))) </span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>

<p>这个例子将文本格式化操作和写操作组合为一个函数。</p>
<h2 id="5-3命名参数"><a href="#5-3命名参数" class="headerlink" title="5.3命名参数"></a>5.3命名参数</h2><p>Lua 的函数参数是和位置相关的,调用时实参会按顺序依次传给形参。有时候用名字指定参数是很有用的,比如rename 函数用来给一个文件重命名,有时候我们我们记不清命名前后两个参数的顺序了:</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- invalid code </span></span><br><span class="line"><span class="built_in">rename</span>(old=<span class="string">&quot;temp.lua&quot;</span>, new=<span class="string">&quot;temp1.lua&quot;</span>) </span><br></pre></td></tr></table></figure>

<p>上面这段代码是无效的,Lua 可以通过将所有的参数放在一个表中,把表作为函数的唯一参数来实现上面这段伪代码的功能。因为Lua语法支持函数调用时实参可以是表的构造。</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">rename</span>&#123;old=<span class="string">&quot;temp.lua&quot;</span>, new=<span class="string">&quot;templ.lua&quot;</span>&#125;</span><br></pre></td></tr></table></figure>

<p>根据这个想法我们重定义了rename:</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">rename</span> <span class="params">(arg)</span></span> </span><br><span class="line"> <span class="keyword">return</span> <span class="built_in">os</span>.<span class="built_in">rename</span>(<span class="built_in">arg</span>.old, <span class="built_in">arg</span>.new) </span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>

<p>当函数的参数很多的时候,这种函数参数的传递方式很方便的。例如GUI库中创建窗体的函数有很多参数并且大部分参数是可选的,可以用下面这种方式:</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">w = Window &#123; </span><br><span class="line"> x=<span class="number">0</span>, y=<span class="number">0</span>, width=<span class="number">300</span>, height=<span class="number">200</span>, </span><br><span class="line"> title = <span class="string">&quot;Lua&quot;</span>, background=<span class="string">&quot;blue&quot;</span>, </span><br><span class="line"> border = <span class="literal">true</span> </span><br><span class="line">&#125; </span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Window</span> <span class="params">(options)</span></span> </span><br><span class="line"> <span class="comment">-- check mandatory options </span></span><br><span class="line"> <span class="keyword">if</span> <span class="built_in">type</span>(options.title) ~= <span class="string">&quot;string&quot;</span> <span class="keyword">then</span> </span><br><span class="line">  <span class="built_in">error</span>(<span class="string">&quot;no title&quot;</span>) </span><br><span class="line"> <span class="keyword">elseif</span> <span class="built_in">type</span>(options.width) ~= <span class="string">&quot;number&quot;</span> <span class="keyword">then</span> </span><br><span class="line">  <span class="built_in">error</span>(<span class="string">&quot;no width&quot;</span>) </span><br><span class="line"> <span class="keyword">elseif</span> <span class="built_in">type</span>(options.height) ~= <span class="string">&quot;number&quot;</span> <span class="keyword">then</span> </span><br><span class="line">  <span class="built_in">error</span>(<span class="string">&quot;no height&quot;</span>) </span><br><span class="line"> <span class="keyword">end</span> </span><br><span class="line"> </span><br><span class="line"> <span class="comment">-- everything else is optional </span></span><br><span class="line"> _Window(options.title, </span><br><span class="line">  options.x <span class="keyword">or</span> <span class="number">0</span>,   <span class="comment">-- default value </span></span><br><span class="line">  options.y <span class="keyword">or</span> <span class="number">0</span>,   <span class="comment">-- default value </span></span><br><span class="line">  options.width, options.height, </span><br><span class="line">  options.background <span class="keyword">or</span> <span class="string">&quot;white&quot;</span>, <span class="comment">-- default </span></span><br><span class="line">  options.border   <span class="comment">-- default is false (nil) </span></span><br><span class="line"> )</span><br></pre></td></tr></table></figure>

<h1 id="第6章-再论函数"><a href="#第6章-再论函数" class="headerlink" title="第6章 再论函数"></a>第6章 再论函数</h1><p>Lua 中的函数是带有词法定界（lexical scoping）的第一类值（first-class values）</p>
<p>第一类值指：在Lua 中函数和其他值(数值、字符串)一样,函数可以被存放在变量中,也可以存放在表中,可以作为函数的参数,还可以作为函数的返回值。</p>
<p>词法定界指：被嵌套的函数可以访问他外部函数中的变量。这一特性给Lua提供了强大的编程能力。</p>
<p>Lua中关于函数稍微难以理解的是函数也可以没有名字,匿名的。当我们提到函数名(比如 print),实际上是说一个指向函数的变量,像持有其他类型值的变量一样:</p>
<p><img src="/%5C2025_04_08_lua%5C0ca3819418e32198b7838ca375c24c76271f684c86a21ac6fcc45b593c442db6.png"></p>
<p>既然函数是值,那么表达式也可以创建函数了,Lua中我们经常这样写:</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span> <span class="params">(x)</span></span> <span class="keyword">return</span> <span class="number">2</span>*x <span class="keyword">end</span></span><br></pre></td></tr></table></figure>

<p>这实际上是利用Lua 提供的“语法上的甜头”(syntacticsugar)的结果,下面是原本的函数:</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">foo = <span class="function"><span class="keyword">function</span> <span class="params">(x)</span></span> <span class="keyword">return</span> <span class="number">2</span>*x <span class="keyword">end</span></span><br></pre></td></tr></table></figure>

<p>函数定义实际上是一个赋值语句,将类型为 function 的变量赋给一个变量。我们使用&#96;&#96;&#96;lua</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span><span class="params">(x)</span></span>..<span class="keyword">end</span></span><br></pre></td></tr></table></figure>
<p>来定义一个函数和使用{}创建一个表一样。</p>
<p>table 标准库提供一个排序函数,接受一个表作为输入参数并且排序表中的元素。这个函数必须能够对不同类型的值(字符串或者数值)按升序或者降序进行排序。Lua不是尽可能多地提供参数来满足这些情况的需要,而是接受一个排序函数作为参数(类似C++的函数对象),排序函数接受两个排序元素作为输入参数,并且返回两者的大小关系,例如:</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">network = &#123; </span><br><span class="line"> &#123;name = <span class="string">&quot;grauna&quot;</span>, IP = <span class="string">&quot;210.26.30.34&quot;</span>&#125;, </span><br><span class="line"> &#123;name = <span class="string">&quot;arraial&quot;</span>, IP = <span class="string">&quot;210.26.30.23&quot;</span>&#125;, </span><br><span class="line"> &#123;name = <span class="string">&quot;lua&quot;</span>,  IP = <span class="string">&quot;210.26.23.12&quot;</span>&#125;, </span><br><span class="line"> &#123;name = <span class="string">&quot;derain&quot;</span>, IP = <span class="string">&quot;210.26.23.20&quot;</span>&#125;,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果我们想通过表的 name 域排序:</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">table</span>.<span class="built_in">sort</span>(network, <span class="function"><span class="keyword">function</span> <span class="params">(a,b)</span></span> </span><br><span class="line"> <span class="keyword">return</span> (a.name &gt; b.name) </span><br><span class="line"><span class="keyword">end</span>) </span><br></pre></td></tr></table></figure>

<p>以其他函数作为参数的函数在Lua 中被称作高级函数,高级函数在Lua 中并没有特权,只是Lua把函数当作第一类函数处理的一个简单的结果。</p>
<p>下面给出一个绘图函数的例子:</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">eraseTerminal</span><span class="params">()</span></span> </span><br><span class="line"> <span class="built_in">io</span>.<span class="built_in">write</span>(<span class="string">&quot;\27[2J&quot;</span>) </span><br><span class="line"><span class="keyword">end</span>  </span><br><span class="line"> <span class="comment">-- writes an `*&#x27; at column `x&#x27; , row `y&#x27; </span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">mark</span> <span class="params">(x,y)</span></span> </span><br><span class="line"> <span class="built_in">io</span>.<span class="built_in">write</span>(<span class="built_in">string</span>.<span class="built_in">format</span>(<span class="string">&quot;\27[%d;%dH*&quot;</span>, y, x)) </span><br><span class="line"><span class="keyword">end</span> </span><br><span class="line"> <span class="comment">-- Terminal size </span></span><br><span class="line">TermSize = &#123;w = <span class="number">80</span>, h = <span class="number">24</span>&#125; </span><br><span class="line"> <span class="comment">-- plot a function -- (assume that domain and image are in the range [-1,1]) </span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">plot</span> <span class="params">(f)</span></span> </span><br><span class="line"> eraseTerminal() </span><br><span class="line"> <span class="keyword">for</span> i=<span class="number">1</span>,TermSize.w <span class="keyword">do</span> </span><br><span class="line">  <span class="keyword">local</span> x = (i/TermSize.w)*<span class="number">2</span> - <span class="number">1</span> </span><br><span class="line">  <span class="keyword">local</span> y = (f(x) + <span class="number">1</span>)/<span class="number">2</span> * TermSize.h </span><br><span class="line">  mark(i, y) </span><br><span class="line"> <span class="keyword">end</span> </span><br><span class="line"> <span class="built_in">io</span>.<span class="built_in">read</span>()  <span class="comment">-- wait before spoiling the screen </span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>

<p>要想让这个例子正确的运行,你必须调整你的终端类型和代码中的控制符一致:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">plot(function (x) return math.sin(x*2*math.pi) end)</span><br></pre></td></tr></table></figure>

<p>将在屏幕上输出一个正弦曲线。</p>
<p>将第一类值函数应用在表中是Lua 实现面向对象和包机制的关键,这部分内容在后面章节介绍。</p>
<h2 id="6-1闭包"><a href="#6-1闭包" class="headerlink" title="6.1闭包"></a>6.1闭包</h2><p>当一个函数内部嵌套另一个函数定义时,内部的函数体可以访问外部的函数的局部变量,这种特征我们称作词法定界。虽然这看起来很清楚,事实并非如此,词法定界加上第一类函数在编程语言里是一个功能强大的概念,很少语言提供这种支持。</p>
<p>下面看一个简单的例子,假定有一个学生姓名的列表和一个学生名和成绩对应的表;现在想根据学生的成绩从高到低对学生进行排序,可以这样做:</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">names = &#123;<span class="string">&quot;Peter&quot;</span>, <span class="string">&quot;Paul&quot;</span>, <span class="string">&quot;Mary&quot;</span>&#125; </span><br><span class="line">grades = &#123;Mary = <span class="number">10</span>, Paul = <span class="number">7</span>, Peter = <span class="number">8</span>&#125; </span><br><span class="line"><span class="built_in">table</span>.<span class="built_in">sort</span>(names, <span class="function"><span class="keyword">function</span> <span class="params">(n1, n2)</span></span> </span><br><span class="line"> <span class="keyword">return</span> grades[n1] &gt; grades[n2]    <span class="comment">-- compare the grades </span></span><br><span class="line"><span class="keyword">end</span>) </span><br></pre></td></tr></table></figure>

<p>假定创建一个函数实现此功能:</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sortbygrade</span> <span class="params">(names, grades)</span></span> </span><br><span class="line"> <span class="built_in">table</span>.<span class="built_in">sort</span>(names, <span class="function"><span class="keyword">function</span> <span class="params">(n1, n2)</span></span> </span><br><span class="line">  <span class="keyword">return</span> grades[n1] &gt; grades[n2]    <span class="comment">-- compare the grades </span></span><br><span class="line"> <span class="keyword">end</span>) </span><br><span class="line"><span class="keyword">end</span> </span><br></pre></td></tr></table></figure>

<p>例子中包含在 sortbygrade 函数内部的 sort 中的匿名函数可以访问 sortbygrade 的参数grades,在匿名函数内部 grades 不是全局变量也不是局部变量,我们称作外部的局部变量(externallocalvariable)或者upvalue。(upvalue 意思有些误导,然而在Lua 中他的存在有历史的根源,还有他比起 external local variable 简短)。</p>
<p>看下面的代码:</p>
<p><img src="/%5C2025_04_08_lua%5C0ed891814f8fed755b0649f875f8167201265ebe9d9524aab0344994b0a8179f.png"></p>
<p>匿名函数使用upvalue i保存他的计数，当我们调用匿名函数的时候i已经超出了作用范围,因为创建i的函数newCounter已经返回了。然而Lua 用闭包的思想正确处理了这种情况。简单的说闭包是一个函数加上它可以正确访问的upvalues。如果我们再次调用 newCounter,将创建一个新的局部变量i,因此我们得到了一个作用在新的变量i上的新闭包。</p>
<p><img src="/%5C2025_04_08_lua%5Cbd9030e59ca9603bcb4b7c489e5b56bdbafeb225703ae9c23bbb63dba36e5ff2.png"></p>
<p>cl、c2 是建立在同一个函数上,但作用在同一个局部变量的不同实例上的两个不同的闭包。</p>
<p>技术上来讲,闭包指值而不是指函数,函数仅仅是闭包的一个原型声明；尽管如此,在不会导致混淆的情况下我们继续使用术语函数代指闭包。</p>
<p>闭包在上下文环境中提供很有用的功能,如前面我们见到的可以作为高级函数(sort)的参数；作为函数嵌套的函数(newCounter)。这一机制使得我们可以在Lua 的函数世界里组合出奇幻的编程技术。闭包也可用在回调函数中,比如在GUI环境中你需要创建一系列button,但用户按下button 时回调函数被调用,可能不同的按钮被按下时需要处理的任务有点区别。具体来讲,一个十进制计算器需要10个相似的按钮,每个按钮对应一个数字,可以使用下面的函数创建他们:</p>
<p><img src="/%5C2025_04_08_lua%5C14c0bf68207b206a1c230a516eceaf1f2934af3d55214eba170a7b4f735e7ce1.png"></p>
<p>这个例子中我们假定 Button 是一个用来创建新按钮的工具,label 是按钮的标签,action 是按钮被按下时调用的回调函数。(实际上是一个闭包,因为他访问 upvalue digit)。digitButton 完成任务返回后,局部变量 digit超出范围,回调函数仍然可以被调用并且可以访问局部变量 digit。</p>
<p>闭包在完全不同的上下文中也是很有用途的。因为函数被存储在普通的变量内我们可以很方便的重定义或者预定义函数。通常当你需要原始函数有一个新的实现时可以重定义函数。例如你可以重定义 sin 使其接受一个度数而不是弧度作为参数:</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">oldSin = <span class="built_in">math</span>.<span class="built_in">sin</span> </span><br><span class="line"><span class="built_in">math</span>.<span class="built_in">sin</span> = <span class="function"><span class="keyword">function</span> <span class="params">(x)</span></span> </span><br><span class="line">    <span class="keyword">return</span> oldSin(x*<span class="built_in">math</span>.<span class="built_in">pi</span>/<span class="number">180</span>) </span><br><span class="line"><span class="keyword">end</span> </span><br></pre></td></tr></table></figure>

<p>更清楚的方式：</p>
<p><img src="/%5C2025_04_08_lua%5Cbc021a019aa3c0d8dd7a655ae2b44d0b7e9f6d3808031693f85036b54613e411.png"></p>
<p>这样我们把原始版本放在一个局部变量内,访问 sin 的唯一方式是通过新版本的函数。</p>
<p>利用同样的特征我们可以创建一个安全的环境(也称作沙箱,和java 里的沙箱一样),当我们运行一段不信任的代码(比如我们运行网络服务器上获取的代码)时安全的环境是需要的,比如我们可以使用闭包重定义io 库的 open 函数来限制程序打开的文件。</p>
<p><img src="/%5C2025_04_08_lua%5C3b0692c308701c91b9961fd5c58ee8057018306b3edda604d1fe187c718b396b.png"></p>
<h2 id="6-2非全局函数"><a href="#6-2非全局函数" class="headerlink" title="6.2非全局函数"></a>6.2非全局函数</h2><p>Lua 中函数可以作为全局变量也可以作为局部变量,我们已经看到一些例子：函数作为 table 的域(大部分 Lua 标准库使用这种机制来实现的比如 io.read、math.sin)。这种情况下,必须注意函数和表语法:</p>
<ol>
<li>表和函数放在一起</li>
</ol>
<p><img src="/%5C2025_04_08_lua%5Cd6300c1ae01b1557a098bd7028c9f1fcc8b53a16dbf77c6c05b6c1c90750e35b.png"></p>
<ol start="2">
<li>使用表构造函数</li>
</ol>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Lib = &#123; </span><br><span class="line"> foo = <span class="function"><span class="keyword">function</span> <span class="params">(x,y)</span></span> <span class="keyword">return</span> x + y <span class="keyword">end</span>, </span><br><span class="line"> goo = <span class="function"><span class="keyword">function</span> <span class="params">(x,y)</span></span> <span class="keyword">return</span> x - y <span class="keyword">end</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="3">
<li>Lua 提供另一种语法方式</li>
</ol>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Lib = &#123;&#125; </span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Lib.foo</span> <span class="params">(x,y)</span></span> </span><br><span class="line"> <span class="keyword">return</span> x + y </span><br><span class="line"><span class="keyword">end</span> </span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Lib.goo</span> <span class="params">(x,y)</span></span> </span><br><span class="line"> <span class="keyword">return</span> x - y </span><br><span class="line"><span class="keyword">end</span> </span><br></pre></td></tr></table></figure>

<p>当我们将函数保存在一个局部变量内时,我们得到一个局部函数,也就是说局部函数像局部变量一样在一定范围内有效。这种定义在包中是非常有用的：因为Lua把chunk当作函数处理,在 chunk 内可以声明局部函数(仅仅在 chunk 内可见),词法定界保证了包内的其他函数可以调用此函数。下面是声明局部函数的两种方式:</p>
<ol>
<li>方式一</li>
</ol>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">local</span> f = <span class="function"><span class="keyword">function</span> <span class="params">(...)</span></span> </span><br><span class="line"> ... </span><br><span class="line"><span class="keyword">end</span> </span><br><span class="line"> </span><br><span class="line"><span class="keyword">local</span> g = <span class="function"><span class="keyword">function</span> <span class="params">(...)</span></span> </span><br><span class="line"> ... </span><br><span class="line"> f()   <span class="comment">-- external local `f&#x27; is visible here </span></span><br><span class="line"> ... </span><br><span class="line"><span class="keyword">end</span> </span><br></pre></td></tr></table></figure>

<ol start="2">
<li>方式二</li>
</ol>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">local</span> <span class="function"><span class="keyword">function</span> <span class="title">f</span> <span class="params">(...)</span></span> </span><br><span class="line"> ... </span><br><span class="line"><span class="keyword">end</span> </span><br></pre></td></tr></table></figure>
<p>有一点需要注意的是在声明递归局部函数的方式:</p>
<p><img src="/%5C2025_04_08_lua%5C7e2b9f4df8fa564b2cc95f3ebd0fdd23ad8523721c9108466c81fadc31eff84a.png"></p>
<p>上面这种方式导致 Lua 编译时遇到 fact(n-1)并不知道他是局部函数 fact,Lua 会去查找是否有这样的全局函数fact。为了解决这个问题我们必须在定义函数以前先声明:</p>
<p><img src="/%5C2025_04_08_lua%5C8e1431f9ec1d2f27efeb1f412c596aa305d65586e1d903ee314be399e61845df.png"></p>
<p>这样在 fact 内部 fact(n-1)调用是一个局部函数调用,运行时 fact 就可以获取正确的值了。</p>
<p>但是Lua扩展了他的语法使得可以在直接递归函数定义时使用两种方式都可以。</p>
<p>在定义非直接递归局部函数时要先声明然后定义才可以:</p>
<p><img src="/%5C2025_04_08_lua%5Cfc23f7f6b6f4bd1a6a9a7d8ac9b7b5ba639f6ad2903f17a48e965c60426fd532.png"></p>
<h2 id="6-3正确的尾调用-ProperTailCalls"><a href="#6-3正确的尾调用-ProperTailCalls" class="headerlink" title="6.3正确的尾调用(ProperTailCalls)"></a>6.3正确的尾调用(ProperTailCalls)</h2><p>Lua 中函数的另一个有趣的特征是可以正确的处理尾调用(proper tail recursion,些书使用术语“尾递归”,虽然并未涉及到递归的概念)。</p>
<p>尾调用是一种类似在函数结尾的 goto 调用,当函数最后一个动作是调用另外一个函数时,我们称这种调用尾调用。例如:</p>
<p><img src="/%5C2025_04_08_lua%5Cd624773f5cac3f5273b664bbae5be83f230165eba8bbe133d13673a8a214aa89.png"></p>
<p>g 的调用是尾调用。</p>
<p>例子中 f调用 g 后不会再做任何事情,这种情况下当被调用函数 g 结束时程序不需要返回到调用者 f；所以尾调用之后程序不需要在栈中保留关于调用者的任何信息。一些编译器比如Lua 解释器利用这种特性在处理尾调用时不使用额外的栈,我们称这种语言支持正确的尾调用。</p>
<p>由于尾调用不需要使用栈空间,那么尾调用递归的层次可以无限制的。例如下面调用不论n为何值不会导致栈溢出。</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span> <span class="params">(n)</span></span> </span><br><span class="line">    <span class="keyword">if</span> n &gt; <span class="number">0</span> <span class="keyword">then</span> <span class="keyword">return</span> foo(n - <span class="number">1</span>) <span class="keyword">end</span> </span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>

<p>需要注意的是：必须明确什么是尾调用。</p>
<p>一些调用者函数调用其他函数后也没有做其他的事情但不属于尾调用。比如:</p>
<p><img src="/%5C2025_04_08_lua%5C452266b4a17b0c1f3ef8ee3a0b4a40122bed446ef5e96c8627bf67a36937d9f6.png"></p>
<p>上面这个例子中 f在调用 g 后,不得不丢弃 g 地返回值,所以不是尾调用,同样的下面几个例子也不时尾调用：</p>
<p><img src="/%5C2025_04_08_lua%5C96ecb3394468ef4520a2400c597dc2a8f613f236d671450399cd4d24d59a78f4.png"></p>
<p>Lua 中类似 return g(..)这种格式的调用是尾调用。但是 g 和 g 的参数都可以是复杂表达式,因为Lua会在调用之前计算表达式的值。例如下面的调用是尾调用:</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">return</span> x[i].foo(x[j] + a*b, i + j) </span><br></pre></td></tr></table></figure>

<p>可以将尾调用理解成一种 goto,在状态机的编程领域尾调用是非常有用的。状态机的应用要求函数记住每一个状态,改变状态只需要 goto(or call)一个特定的函数。我们考虑一个迷宫游戏作为例子：迷宫有很多个房间,每个房间有东西南北四个门,每一步输入一个移动的方向,如果该方向存在即到达该方向对应的房间,否则程序打印警告信息。目标是：从开始的房间到达目的房间。</p>
<p>这个迷宫游戏是典型的状态机,每个当前的房间是一个状态。我们可以对每个房间写一个函数实现这个迷宫游戏,我们使用尾调用从一个房间移动到另外一个房间。一个四个房间的迷宫代码如下：</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">room1</span> <span class="params">()</span></span> </span><br><span class="line"><span class="keyword">local</span> move = <span class="built_in">io</span>.<span class="built_in">read</span>() </span><br><span class="line"><span class="keyword">if</span> move == <span class="string">&quot;south&quot;</span> <span class="keyword">then</span> </span><br><span class="line"><span class="keyword">return</span> room3() </span><br><span class="line"><span class="keyword">elseif</span> move == <span class="string">&quot;east&quot;</span> <span class="keyword">then</span> </span><br><span class="line"><span class="keyword">return</span> room2() </span><br><span class="line"><span class="keyword">else</span> </span><br><span class="line">  <span class="built_in">print</span>(<span class="string">&quot;invalid move&quot;</span>) </span><br><span class="line">  <span class="keyword">return</span> room1()   <span class="comment">-- stay in the same room </span></span><br><span class="line"> <span class="keyword">end</span> </span><br><span class="line"><span class="keyword">end</span> </span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">room2</span> <span class="params">()</span></span> </span><br><span class="line"> <span class="keyword">local</span> move = <span class="built_in">io</span>.<span class="built_in">read</span>() </span><br><span class="line"> <span class="keyword">if</span> move == <span class="string">&quot;south&quot;</span> <span class="keyword">then</span> </span><br><span class="line">  <span class="keyword">return</span> room4() </span><br><span class="line"> <span class="keyword">elseif</span> move == <span class="string">&quot;west&quot;</span> <span class="keyword">then</span> </span><br><span class="line">  <span class="keyword">return</span> room1() </span><br><span class="line"> <span class="keyword">else</span> </span><br><span class="line">  <span class="built_in">print</span>(<span class="string">&quot;invalid move&quot;</span>) </span><br><span class="line">  <span class="keyword">return</span> room2() </span><br><span class="line"> <span class="keyword">end</span> </span><br><span class="line"><span class="keyword">end</span> </span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">room3</span> <span class="params">()</span></span> </span><br><span class="line"> <span class="keyword">local</span> move = <span class="built_in">io</span>.<span class="built_in">read</span>() </span><br><span class="line"> <span class="keyword">if</span> move == <span class="string">&quot;north&quot;</span> <span class="keyword">then</span> </span><br><span class="line">  <span class="keyword">return</span> room1() </span><br><span class="line"> <span class="keyword">elseif</span> move == <span class="string">&quot;east&quot;</span> <span class="keyword">then</span> </span><br><span class="line">  <span class="keyword">return</span> room4() </span><br><span class="line"> <span class="keyword">else</span> </span><br><span class="line">  <span class="built_in">print</span>(<span class="string">&quot;invalid move&quot;</span>) </span><br><span class="line">  <span class="keyword">return</span> room3() </span><br><span class="line"> <span class="keyword">end</span> </span><br><span class="line"><span class="keyword">end</span> </span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">room4</span> <span class="params">()</span></span> </span><br><span class="line"> <span class="built_in">print</span>(<span class="string">&quot;congratilations!&quot;</span>) </span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>

<p>我们可以调用rooml0开始这个游戏。</p>
<p>如果没有正确的尾调用,每次移动都要创建一个栈,多次移动后可能导致栈溢出。但正确的尾调用可以无限制的尾调用,因为每次尾调用只是一个 goto 到另外一个函数并不是传统的函数调用。</p>
<h1 id="第7章迭代器与泛型for"><a href="#第7章迭代器与泛型for" class="headerlink" title="第7章迭代器与泛型for"></a>第7章迭代器与泛型for</h1><p>在这一章我们讨论为范性 for 写迭代器,我们从一个简单的迭代器开始,然后我们学习如何通过利用范性for的强大之处写出更高效的迭代器。</p>
<h2 id="7-1迭代器与闭包"><a href="#7-1迭代器与闭包" class="headerlink" title="7.1迭代器与闭包"></a>7.1迭代器与闭包</h2><p>迭代器是一种支持指针类型的结构,它可以遍历集合的每一个元素。在Lua 中我们常常使用函数来描述迭代器,每次调用该函数就返回集合的下一个元素。</p>
<p>迭代器需要保留上一次成功调用的状态和下一次成功调用的状态,也就是他知道来自于哪里和将要前往哪里。闭包提供的机制可以很容易实现这个任务。记住：闭包是个内部函数,它可以访问一个或者多个外部函数的外部局部变量。每次闭包的成功调用后这些外部局部变量都保存他们的值(状态)。当然如果要创建一个闭包必须要创建其外部局部变量。所以一个典型的闭包的结构包含两个函数：一个是闭包自己；另一个是工厂(创建闭包的函数)。</p>
<p>举一个简单的例子,我们为一个 list 写一个简单的迭代器,与 ipairs(不同的是我们实现的这个迭代器返回元素的值而不是索引下标：</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">list_iter</span> <span class="params">(t)</span></span> </span><br><span class="line">    <span class="keyword">local</span> i = <span class="number">0</span> </span><br><span class="line">    <span class="keyword">local</span> n = <span class="built_in">table</span>.<span class="built_in">getn</span>(t) </span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> <span class="params">()</span></span> </span><br><span class="line">        i = i + <span class="number">1</span> </span><br><span class="line">        <span class="keyword">if</span> i &lt;= n <span class="keyword">then</span> <span class="keyword">return</span> t[i] <span class="keyword">end</span> </span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>

<p>这个例子中 list_iter是一个工厂,每次调用他都会创建一个新的闭包(迭代器本身)。闭包保存内部局部变量(t,i,n),因此每次调用他返回 list 中的下一个元素值,当 list 中没有值时,返回 nil.我们可以在 while 语句中使用这个迭代器:</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">t = &#123;<span class="number">10</span>, <span class="number">20</span>, <span class="number">30</span>&#125; </span><br><span class="line">iter = list_iter(t)  <span class="comment">-- creates the iterator </span></span><br><span class="line"><span class="keyword">while</span> <span class="literal">true</span> <span class="keyword">do</span> </span><br><span class="line">    <span class="keyword">local</span> element = iter() <span class="comment">-- calls the iterator </span></span><br><span class="line">    <span class="keyword">if</span> element == <span class="literal">nil</span> <span class="keyword">then</span> <span class="keyword">break</span> <span class="keyword">end</span> </span><br><span class="line">    <span class="built_in">print</span>(element)</span><br><span class="line"> <span class="keyword">end</span></span><br></pre></td></tr></table></figure>
<p>我们设计的这个迭代器也很容易用于范性for语句 </p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">t = &#123;<span class="number">10</span>, <span class="number">20</span>, <span class="number">30</span>&#125; </span><br><span class="line"><span class="keyword">for</span> element <span class="keyword">in</span> list_iter(t) <span class="keyword">do</span> </span><br><span class="line"> <span class="built_in">print</span>(element) </span><br><span class="line"><span class="keyword">end</span> </span><br></pre></td></tr></table></figure>

<p>范性 for 为迭代循环处理所有的薄记(bookkeeping)：首先调用迭代工厂；内部保留迭代函数,因此我们不需要 iter 变量；然后在每一个新的迭代处调用迭代器函数；当迭代器返回 nil时循环结束(后面我们将看到范性 for 能胜任更多的任务)。</p>
<p>下面看一个稍微高级一点的例子：我们写一个迭代器遍历一个文件内的所有匹配的单词。为了实现目的,我们需要保留两个值：当前行和在当前行的偏移量,我们使用两个外部局部变量 line、pos 保存这两个值。</p>
<p><img src="/%5C2025_04_08_lua%5C7b5ec375662cf2b12adc9106e299c360048ec5e92141076732490a67b0957653.png"></p>
<p>迭代函数的主体部分调用了 string.find 函数,string.find 在当前行从当前位置开始查找匹配的单词,例子中匹配的单词使用模式’%w+’描述的；如果查找到一个单词,迭代函数更新当前位置 pos 为单词后的第一个位置,并且返回这个单词(string.sub 函数从 lineline 可读返回 nil 结束。</p>
<p>尽管迭代函数有些复杂,但使用起来是很直观的:</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> word <span class="keyword">in</span> allwords() <span class="keyword">do</span></span><br><span class="line">    <span class="built_in">print</span>(word)</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>

<p>通常情况下,迭代函数都难写易用。这不是一个大问题：一般Lua 编程不需要自己定义迭代函数,而是使用语言提供的,除非确实需要自己定义。</p>
<h2 id="7-2范性for的语义"><a href="#7-2范性for的语义" class="headerlink" title="7.2范性for的语义"></a>7.2范性for的语义</h2><p>前面我们看到的迭代器有一个缺点：每次调用都需要创建一个闭包,大多数情况下这种做法都没什么问题,例如在 allwords 迭代器中创建一个闭包的代价比起读整个文件来说微不足道,然而在有些情况下创建闭包的代价是不能忍受的。在这些情况下我们可以使用范性 for 本身来保存迭代的状态。</p>
<p>前面我们看到在循环过程中范性 for 在自己内部保存迭代函数,实际上它保存三个值:迭代函数,状态常量和控制变量.下面详细说明。</p>
<p>范性 for 的文法如下:</p>
<p><img src="/%5C2025_04_08_lua%5C0a7c8b63bc84524e9aed0631026c63827223ac5d3b8b1b1c5bb2b71af8da1457.png"></p>
<p><var-list>是一个或多个以逗号分割的变量名列表,<exp-list>是一个或多个以逗号分割的表达式列表,通常情况下 exp-list 只有一个值：迭代工厂的调用。</p>
<p><img src="/%5C2025_04_08_lua%5C478aa0cfa676ee5d1cc5f66a7a2b08aa6b255f6bb2fa4cd7f35f5e51caa8f7bf.png"></p>
<p>变量列表k,v；表达式列表 pair(t),在很多情况下变量列表也只有一个变量,比如:</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> line <span class="keyword">in</span> <span class="built_in">io</span>.<span class="built_in">lines</span>() <span class="keyword">do</span> </span><br><span class="line"> <span class="built_in">io</span>.<span class="built_in">write</span>(line, <span class="string">&#x27;\n&#x27;</span>) </span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>

<p>我们称变量列表中第一个变量为控制变量,其值为 nil 时循环结束。</p>
<p>下面我们看看范性 for的执行过程:</p>
<p>首先,初始化,计算in 后面表达式的值,表达式应该返回范性 for 需要的三个值:迭代函数,状态常量和控制变量；与多值赋值一样,如果表达式返回的结果个数不足三个会自动用 nil补足,多出部分会被忽略。</p>
<p>第二,将状态常量和控制变量作为参数调用迭代函数(注意：对于 for 结构来说,状态常量没有用处,仅仅在初始化时获取他的值并传递给迭代函数)。</p>
<p>第三,将迭代函数返回的值赋给变量列表。</p>
<p>第四,如果返回的第一个值为 nil循环结束,否则执行循环体。</p>
<p>第五,回到第二步再次调用迭代函数。</p>
<p>更精确的来说:</p>
<p><img src="/%5C2025_04_08_lua%5C056a8312627be2480e6ebbb5e90c80d352f8020f768325959f5f2016596930b5.png"></p>
<p>如果我们的迭代函数是f,状态常量是 s,控制变量的初始值是 a0,那么控制变量将循环：al&#x3D;f(s,a0)、a2&#x3D;f(s,al)、·..·,直到 ai&#x3D;nil。</p>
<h2 id="7-3无状态的迭代器"><a href="#7-3无状态的迭代器" class="headerlink" title="7.3无状态的迭代器"></a>7.3无状态的迭代器</h2><p>无状态的迭代器是指不保留任何状态的迭代器,因此在循环中我们可以利用无状态迭代器避免创建闭包花费额外的代价。</p>
<p>每一次迭代,迭代函数都是用两个变量(状态常量和控制变量)的值作为参数被调型的简单的例子是ipairs,他遍历数组的每一个元素。</p>
<p><img src="/%5C2025_04_08_lua%5Cd68b6a2f202845a055da1b4c896583d63f60cde047cf0e0de43900c3d9360eed.png"></p>
<p>迭代的状态包括被遍历的表(循环过程中不会改变的状态常量)和当前的索引下标(控制变量),ipairs 和迭代函数都很简单,我们在Lua 中可以这样实现:</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">iter</span> <span class="params">(a, i)</span></span> </span><br><span class="line"> i = i + <span class="number">1</span> </span><br><span class="line"> <span class="keyword">local</span> v = a[i] </span><br><span class="line"> <span class="keyword">if</span> v <span class="keyword">then</span> </span><br><span class="line">  <span class="keyword">return</span> i, v </span><br><span class="line"> <span class="keyword">end</span> </span><br><span class="line"><span class="keyword">end</span> </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">ipairs</span> <span class="params">(a)</span></span> </span><br><span class="line">    <span class="keyword">return</span> iter, a, <span class="number">0</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>

<p>当 Lua 调用 ipairs(a)开始循环时,他获取三个值:迭代函数 iter,状态常量 a 和控制变)非)返回 2,a[2]···直到第一个非nil 元素。</p>
<p>Lua 库中实现的 pairs 是一个用 next实现的原始方法:</p>
<p><img src="/%5C2025_04_08_lua%5Ca54fd24468ce4a3d90552b9818f8f0eba207e82eeadddfd5e6684e27721492e8.png"></p>
<p>还可以不使用ipairs直接使用next </p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> k, v <span class="keyword">in</span> <span class="built_in">next</span>, t <span class="keyword">do</span></span><br><span class="line">    ...</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>
<p>记住：exp-list 返回结果会被调整为三个,所以 Lua 获取 next、t、nil；确切地说当他调用 pairs 时获取。</p>
<h2 id="7-4多状态的迭代器"><a href="#7-4多状态的迭代器" class="headerlink" title="7.4多状态的迭代器"></a>7.4多状态的迭代器</h2><p>很多情况下,迭代器需要保存多个状态信息而不是简单的状态常量和控制变量,最简单的方法是使用闭包,还有一种方法就是将所有的状态信息封装到 table 内,将 table作为迭代器的状态常量,因为这种情况下可以将所有的信息存放在 table 内,所以迭代函数通常不需要第二个参数。</p>
<p>下面我们重写allwords迭代器,这一次我们不是使用闭包而是使用带有两个域(line,pos)的 table 。</p>
<p>开始迭代的函数是很简单的,他必须返回迭代函数和初始状态:</p>
<p><img src="/%5C2025_04_08_lua%5Cb44d60908eecbbe40833a43152afbac573956b72937b3d438d4f1d775256dc04.png"></p>
<p>真正的处理工作是在迭代函数内完成:</p>
<p><img src="/%5C2025_04_08_lua%5Ce87aab6252aecde833cbad644bf6b04da98e1ca03736fe4c8c9790df6901f887.png"></p>
<p>我们应该尽可能的写无状态的迭代器,因为这样循环的时候由 for 来保存状态,不需要创建对象花费的代价小；如果不能用无状态的迭代器实现,应尽可能使用闭包；尽可能不要使用 table 这种方式,因为创建闭包的代价要比创建 table 小,另外Lua 处理闭包要比处理table 速度快些。后面我们还将看到另一种使用协同来创建迭代器的方式,这种方式功能更强但更复杂。</p>
<h2 id="7-5真正的迭代器"><a href="#7-5真正的迭代器" class="headerlink" title="7.5真正的迭代器"></a>7.5真正的迭代器</h2><p>迭代器的名字有一些误导,因为它并没有迭代,完成迭代功能的是 for 语句,也许更好的叫法应该是’生成器；但是在其他语言比如java、C++迭代器的说法已经很普遍了,我们也将沿用这种术语。</p>
<p>有一种方式创建一个在内部完成迭代的迭代器。这样当我们使用迭代器的时候就不需要使用循环了；我们仅仅使用每一次迭代需要处理的任务作为参数调用迭代器即可,具体地说,迭代器接受一个函数作为参数,并且这个函数在迭代器内部被调用。</p>
<p>作为一个具体的例子,我们使用上述方式重写 allwords 迭代器:</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">allwords</span> <span class="params">(f)</span></span> </span><br><span class="line"> <span class="comment">-- repeat for each line in the file </span></span><br><span class="line"> <span class="keyword">for</span> l <span class="keyword">in</span> <span class="built_in">io</span>.<span class="built_in">lines</span>() <span class="keyword">do</span> </span><br><span class="line">  <span class="comment">-- repeat for each word in the line </span></span><br><span class="line">    <span class="keyword">for</span> w <span class="keyword">in</span> <span class="built_in">string</span>.<span class="built_in">gfind</span>(l, <span class="string">&quot;%w+&quot;</span>) <span class="keyword">do</span> </span><br><span class="line">        <span class="comment">-- call the function </span></span><br><span class="line">        f(w) </span><br><span class="line">    <span class="keyword">end</span> </span><br><span class="line">  <span class="keyword">end</span> </span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>

<p>如果我们想要打印出单词,只需要</p>
<p><img src="/%5C2025_04_08_lua%5C125a139ee208902c698bbf24cf394857b20bb8bdde2a236686f3686a765d1137.png"></p>
<p>更一般的做法是我们使用匿名函数作为作为参数,下面的例子打印出单词hello’出现的次数：</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">local</span> count = <span class="number">0</span> </span><br><span class="line">allwords(<span class="function"><span class="keyword">function</span> <span class="params">(w)</span></span> </span><br><span class="line">    <span class="keyword">if</span> w == <span class="string">&quot;hello&quot;</span> <span class="keyword">then</span> count = count + <span class="number">1</span> <span class="keyword">end</span> </span><br><span class="line">en ) </span><br><span class="line"> <span class="built_in">print</span>(count) </span><br></pre></td></tr></table></figure>

<p>用 for 结构完成同样的任务:</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">local</span> count = <span class="number">0</span> </span><br><span class="line"><span class="keyword">for</span> w <span class="keyword">in</span> allwords() <span class="keyword">do</span> </span><br><span class="line">    <span class="keyword">if</span> w == <span class="string">&quot;hello&quot;</span> <span class="keyword">then</span> count = count + <span class="number">1</span> <span class="keyword">end</span> </span><br><span class="line"><span class="keyword">end</span> </span><br><span class="line"><span class="built_in">print</span>(count)</span><br></pre></td></tr></table></figure>

<p>真正的迭代器风格的写法在Lua 老版本中很流行,那时还没有for 循环。</p>
<p>两种风格的写法相差不大,但也有区别：一方面,第二种风格更容易书写和理解;另一方面,for 结构更灵活,可以使用 break和 continue 语句；在真正的迭代器风格写法中return语句只是从匿名函数中返回而不是退出循环。</p>
<h1 id="第8章编译·运行·调试"><a href="#第8章编译·运行·调试" class="headerlink" title="第8章编译·运行·调试"></a>第8章编译·运行·调试</h1><p>虽然我们把Lua 当作解释型语言,但是Lua 会首先把代码预编译成中间码然后再执行(很多解释型语言都是这么做的)。在解释型语言中存在编译阶段听起来不合适,然而,解释型语言的特征不在于他们是否被编译,而是编译器是语言运行时的一部分,所以,执行编译产生的中间码速度会更快。我们可以说函数 dofile 的存在就是说明可以将Lua作为一种解释型语言被调用。</p>
<p>前面我们介绍过 dofile,把它当作Lua 运行代码的 chunk 的一种原始的操作。dofile实际上是一个辅助的函数。真正完成功能的函数是 loadfile；与 dofile 不同的是 loadfile不会抛出错误信息而是返回错误代。.我们可以这样定义dofile:</p>
<p><img src="/%5C2025_04_08_lua%5C5fa21a38f9bd60bb1431dedf0630f9b9faeadccc52efc8acae1d27e8875fa7ab.png"></p>
<p>如果loadfile失败assert会抛出错误。</p>
<p>完成简单的功能 dofile 比较方便,他读入文件编译并且执行。然而loadfile更加灵活。在发生错误的情况下,loadfile 返回 nil 和错误信息,这样我们就可以自定义错误处理。另外,如果我们运行一个文件多次的话,loadfile 只需要编译一次,但可多次运行。dofile却每次都要编译。</p>
<p>loadstring与loadfile 相似,只不过它不是从文件里读入chunk,而是从一个串中读入。例如：</p>
<p><img src="/%5C2025_04_08_lua%5C098bc218c974b6a65750580eb55e2c06eb2721d97b196ba142ebb24e7cd0f9a7.png"></p>
<p>f将是一个函数,调用时执行i&#x3D;i+l。</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">i = <span class="number">0</span></span><br><span class="line">f(); <span class="built_in">print</span>(i)  <span class="comment">--&gt; 1 </span></span><br><span class="line">f(); <span class="built_in">print</span>(i)  <span class="comment">--&gt; 2 </span></span><br></pre></td></tr></table></figure>

<p>loadstring 函数功能强大,但使用时需多加小心。确认没有其它简单的解决问题的方法再使用。</p>
<p>Lua 把每一个 chunk 都作为一个匿名函数处理。例如：chunk”a&#x3D;1”,loadstring 返回与其等价的 function(a&#x3D;1 end</p>
<p>与其他函数一样,chunks 可以定义局部变量也可以返回值:</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">f = <span class="built_in">loadstring</span>(<span class="string">&quot;local a = 10; return a + 20&quot;</span>)</span><br><span class="line"> <span class="built_in">print</span>(f())   <span class="comment">--&gt; 30 </span></span><br></pre></td></tr></table></figure>

<p>loadfile 和loadstring都不会抛出错误,如果发生错误他们将返回 nil加上错误信息：</p>
<p><img src="/%5C2025_04_08_lua%5Ceda629e4887275ad2c6e463301325dbeae114b40f6eeee3fbc7043190fe5d5bf.png"></p>
<p>另外,loadfile 和loadstring 都不会有边界效应产生,他们仅仅编译 chunk成为自己内部实现的一个匿名函数。通常对他们的误解是他们定义了函数。Lua中的函数定义是发生在运行时的赋值而不是发生在编译时。假如我们有一个文件foo.lua:</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- file `foo.lua&#x27; </span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span> <span class="params">(x)</span></span></span><br><span class="line">    <span class="built_in">print</span>(x) </span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>

<p>当我们执行命令f &#x3D;loadfile(“foo.lua”)后,foo 被编译了但还没有被定义,如果要定义他必须运行chunk:</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">f()    <span class="comment">-- defines `foo&#x27; </span></span><br><span class="line">foo(<span class="string">&quot;ok&quot;</span>)  <span class="comment">--&gt; ok </span></span><br></pre></td></tr></table></figure>

<p>如果你想快捷的调用 dostring(比如加载并运行),可以这样</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">loadstring</span>(s)()</span><br></pre></td></tr></table></figure>

<p>调用 loadstring 返回的结果,然而如果加载的内容存在语法错误的话,loadstring 返</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">assert</span>(<span class="built_in">loadstring</span>(s))()</span><br></pre></td></tr></table></figure>

<p>通常使用loadstring 加载一个字串没什么意义,例如:</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">f = <span class="built_in">loadstring</span>(<span class="string">&quot;i = i + l&quot;</span>)</span><br></pre></td></tr></table></figure>

<p>大概与f&#x3D;function(i&#x3D;i+1 end 等价,但是第二段代码速度更快因为它只需要编译一次,第一段代码每次调用loadstring 都会重新编译,还有一个重要区别：loadstring 编译的时候不关心词法范围：</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">local</span> i = <span class="number">0</span> </span><br><span class="line">f = <span class="built_in">loadstring</span>(<span class="string">&quot;i = i + 1&quot;</span>) </span><br><span class="line">g = <span class="function"><span class="keyword">function</span> <span class="params">()</span></span> i = i + <span class="number">1</span> <span class="keyword">end</span> </span><br></pre></td></tr></table></figure>

<p>这个例子中,和想象的一样 g使用局部变量i,然而f使用全局变量i；loadstring 总是在全局环境中编译他的串。</p>
<p>loadstring通常用于运行程序外部的代码,比如运行用户自定义的代码。注意：loadstring 期望一个 chunk,即语句。如果想要加载表达式,需要在表达式前加 return,那样将返回表达式的值。看例子:</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">print</span> <span class="string">&quot;enter your expression:&quot;</span> </span><br><span class="line"><span class="keyword">local</span> l = <span class="built_in">io</span>.<span class="built_in">read</span>() </span><br><span class="line"><span class="keyword">local</span> func = <span class="built_in">assert</span>(<span class="built_in">loadstring</span>(<span class="string">&quot;return &quot;</span> .. l)) </span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;the value of your expression is &quot;</span> .. func()) </span><br></pre></td></tr></table></figure>

<p>loadstring返回的函数和普通函数一样,可以多次被调用:</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">print</span> <span class="string">&quot;enter function to be plotted (with variable `x&#x27;):&quot;</span> </span><br><span class="line"><span class="keyword">local</span> l = <span class="built_in">io</span>.<span class="built_in">read</span>() </span><br><span class="line"><span class="keyword">local</span> f = <span class="built_in">assert</span>(<span class="built_in">loadstring</span>(<span class="string">&quot;return &quot;</span> .. l)) </span><br><span class="line"><span class="keyword">for</span> i=<span class="number">1</span>,<span class="number">20</span> <span class="keyword">do</span> </span><br><span class="line">    x = i   <span class="comment">-- global `x&#x27; (to be visible from the chunk) </span></span><br><span class="line">    <span class="built_in">print</span>(<span class="built_in">string</span>.<span class="built_in">rep</span>(<span class="string">&quot;*&quot;</span>, f()))</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>

<h2 id="8-1reguire函数"><a href="#8-1reguire函数" class="headerlink" title="8.1reguire函数"></a>8.1reguire函数</h2><p>Lua 提供高级的 require 函数来加载运行库。粗略的说 require 和 dofile 完成同样的功能但有两点不同:</p>
<ol>
<li><p>require 会搜索目录加载文件</p>
</li>
<li><p>require 会判断是否文件已经加载避免重复加载同一文件。由于上述特征,require在Lua中是加载库的更好的函数。</p>
</li>
</ol>
<p>require 使用的路径和普通我们看到的路径还有些区别,我们一般见到的路径都是-个目录列表。require 的路径是一个模式列表,每一个模式指明一种由虚文件名(require的参数)转成实文件名的方法。更明确地说,每一个模式是一个包含可选的问号的文件名。匹配的时候Lua会首先将问号用虚文件名替换,然后看是否有这样的文件存在。如果不存在继续用同样的方法用第二个模式匹配。例如,路径如下:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">?;?.lua;c:\windows\?;/usr/local/lua/?/?.lua</span><br></pre></td></tr></table></figure>

<p>调用 require”lili”时会试着打开这些文件:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">lili </span><br><span class="line">lili.lua </span><br><span class="line">c:\windows\lili </span><br><span class="line">/usr/local/lua/lili/lili.lua </span><br></pre></td></tr></table></figure>

<p>require 关注的问题只有分号(模式之间的分隔符)和问号,其他的信息(目录分隔符,文件扩展名)在路径中定义。</p>
<p>为了确定路径,Lua 首先检查全局变量LUA_PATH是否为一个字符串,如果是则认为这个串就是路径;否则 require 检查环境变量 LUA_PATH 的值,如果两个都失败 require使用固定的路径(典型的”?;?.lua”)</p>
<p>require 的另一个功能是避免重复加载同一个文件两次。Lua 保留一张所有已经加载的文件的列表(使用 table 保存)。如果一个加载的文件在表中存在 require 简单的返回；表中保留加载的文件的虚名,而不是实文件名。所以如果你使用不同的虚文件名 require同一个文件两次,将会加载两次该文件。比如 require “foo”和 require“”foo.lua”,路径为这样我们就可以判断文件是否被加载过；同样我们也可以使用一点小技巧让require 加载一个文件两次。比如,require “foo”之后_LOADED[“foo”]将不为 nil,我们可以将其赋值为nil,require”foo.lua”将会再次加载该文件。</p>
<p>个路径中的模式也可以不包含问号而只是一个固定的路径,比如:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">?;?.lua;/usr/local/default.lua</span><br></pre></td></tr></table></figure>

<p>这种情况下，require没有匹配的时候就会使用这个固定的文件（当然这个固定的路径必须放在模式列表的最后才有意义）。在require运行一个chunk以前，它定义了一个全局变量_REQUIREDNAME 用来保存被 required 的虚文件的文件名。我们可以通过使用这个技巧扩展 require 的功能。举个极端的例子，我们可以把路径设为<br>“&#x2F;usr&#x2F;local&#x2F;lua&#x2F;newrequire.lua”，这样以后每次调用 require 都会运行 newrequire.lua，这种情况下可以通过使用_REQUIREDNAME的值去实际加载required的文件。</p>
<h2 id="8-2-C-Packages"><a href="#8-2-C-Packages" class="headerlink" title="8.2 C Packages"></a>8.2 C Packages</h2><p>Lua 和C是很容易结合的,使用C为Lua 写包。与Lua 中写包不同,C包在使用以前必须首先加载并连接,在大多数系统中最容易的实现方式是通过动态连接库机制,然而动态连接库不是ANSIC的一部分,也就是说在标准C中实现动态连接是很困难的。</p>
<p>通常Lua不包含任何不能用标准C实现的机制,动态连接库是一个特例。我们可以将动态连接库机制视为其他机制之母：一旦我们拥有了动态连接机制,我们就可以动态的加载Lua 中不存在的机制。所以,在这种特殊情况下,Lua 打破了他平台兼容的原则FreeBSD、Solaris 和其他一些Unix平台实现了这种机制,扩展其它平台支持这种机制也是不难的。在 Lua 提示符下运行 print(loadibO)看返回的结果,如果显示 bad arguments</p>
<p>Lua在一个叫loadlib 的函数内提供了所有的动态连接的功能。这个函数有两个参数:库的绝对路径和初始化函数。所以典型的调用的例子如下:</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">local</span> <span class="built_in">path</span> = <span class="string">&quot;/usr/local/lua/lib/libluasocket.so&quot;</span> </span><br><span class="line"><span class="keyword">local</span> f = <span class="built_in">loadlib</span>(<span class="built_in">path</span>, <span class="string">&quot;luaopen_socket&quot;</span>) </span><br></pre></td></tr></table></figure>

<p>loadlib 函数加载指定的库并且连接到Lua,然而它并不打开库(也就是说没有调用初始化函数),反之他返回初始化函数作为Lua 的一个函数,这样我们就可以直接在Lua中调用他。如果加载动态库或者查找初始化函数时出错,loadlib 将返回 nil和错误信息。我们可以修改前面一段代码,使其检测错误然后调用初始化函数：</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">local</span> <span class="built_in">path</span> = <span class="string">&quot;/usr/local/lua/lib/libluasocket.so&quot;</span> <span class="comment">-- or path = &quot;C:\\windows\\luasocket.dll&quot; </span></span><br><span class="line"><span class="keyword">local</span> f = <span class="built_in">assert</span>(<span class="built_in">loadlib</span>(<span class="built_in">path</span>, <span class="string">&quot;luaopen_socket&quot;</span>)) </span><br><span class="line">f()  <span class="comment">-- actually open the library </span></span><br></pre></td></tr></table></figure>
<p>一般情况下我们期望二进制的发布库包含一个与前面代码段相似的 stub 文件,安装二进制库的时候可以随便放在某个目录,只需要修改 stub 文件对应二进制库的实际路径即可。将 stub 文件所在的目录加入到LUA_PATH,这样设定后就可以使用 require 函数加载C库了。</p>
<h2 id="8-3错误"><a href="#8-3错误" class="headerlink" title="8.3错误"></a>8.3错误</h2><p>Errare humanum ést(拉丁谚语：犯错是人的本性)。所以我们要尽可能的防止错误的发生,Lua 经常作为扩展语言嵌入在别的应用中,所以不能当错误发生时简单的崩溃或者退出。相反,当错误发生时Lua 结束当前的chunk并返回到应用中。</p>
<p>当Lua遇到不期望的情况时就会抛出错误,比如：两个非数字进行相加；调用一个非函数的变量；访问表中不存在的值等(可以通过 metatables 修改这种行为,后面介绍)。你也可以通过调用error 函数显示的抛出错误,error 的参数是要抛出的错误信息。</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">print</span> <span class="string">&quot;enter a number:&quot;</span> </span><br><span class="line">n = <span class="built_in">io</span>.<span class="built_in">read</span>(<span class="string">&quot;*number&quot;</span>) </span><br><span class="line"><span class="keyword">if</span> <span class="keyword">not</span> n <span class="keyword">then</span> <span class="built_in">error</span>(<span class="string">&quot;invalid input&quot;</span>) <span class="keyword">end</span> </span><br></pre></td></tr></table></figure>

<p>Lua提供了专门的内置函数 assert来完成上面类似的功能:</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">print</span> <span class="string">&quot;enter a number:&quot;</span> </span><br><span class="line">n = <span class="built_in">assert</span>(<span class="built_in">io</span>.<span class="built_in">read</span>(<span class="string">&quot;*number&quot;</span>), <span class="string">&quot;invalid input&quot;</span>) </span><br></pre></td></tr></table></figure>

<p>assert 首先检查第一个参数是否返回错误,如果不返回错误 assert 简单的返回,否则assert 以第二个参数抛出错误信息。第二个参数是可选的。注意 assert是普通的函数,他会首先计算两个参数然后再调用函数,所以以下代码:</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">n = <span class="built_in">io</span>.<span class="built_in">read</span>() </span><br><span class="line"><span class="built_in">assert</span>(<span class="built_in">tonumber</span>(n), <span class="string">&quot;invalid input: &quot;</span> .. n .. <span class="string">&quot; is not a number&quot;</span>)</span><br></pre></td></tr></table></figure>

<p>将会总是进行连接操作,使用显示的test可以避免这种情况。</p>
<p>当函数遇到异常有两个基本的动作：返回错误代码或者抛出错误。这两种方式选择哪一种没有固定的规则,但有一般的原则：容易避免的异常应该抛出错误否则返回错误代码。</p>
<p>例如我们考虑 sin 函数,如果以一个 table 作为参数,假定我们返回错误代码,我们需要检查错误的发生,代码可能如下：</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">local</span> res = <span class="built_in">math</span>.<span class="built_in">sin</span>(x)</span><br><span class="line"> <span class="keyword">if</span> <span class="keyword">not</span> res <span class="keyword">then</span>  <span class="comment">-- error </span></span><br><span class="line"> ... </span><br></pre></td></tr></table></figure>
<p>local res &#x3D; math.sin(x)</p>
<p>然而我们可以在调用函数以前很容易的判断是否有异常：</p>
<p><img src="/%5C2025_04_08_lua%5C33d6f07da71b8c11cc774b03911b8599bf2b22921768c191fe63b512a66ada0e.png"></p>
<p>然而通常情况下我们既不是检查参数也不是检查返回结果,因为参数错误可能意味着我们的程序某个地方存在问题,这种情况下,处理异常最简单最实际的方式是抛出错误并且终止代码的运行。</p>
<p>再来看一个例子io.open 函数用来打开一个文件,如果文件不存在结果会怎么样呢?很多系统中,通过试着去打开文件来判断是否文件存在。所以如果io.open 不能打开文件(由于文件不存在或者没有权限),函数返回 nil和错误信息。以这种方式我们可以通过与用户交互(比如：是否要打开另一个文件)合理的处理问题:</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">local</span> file, msg </span><br><span class="line"><span class="keyword">repeat</span> </span><br><span class="line">    <span class="built_in">print</span> <span class="string">&quot;enter a file name:&quot;</span> </span><br><span class="line">    <span class="keyword">local</span> name = <span class="built_in">io</span>.<span class="built_in">read</span>() </span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> name <span class="keyword">then</span> <span class="keyword">return</span> <span class="keyword">end</span>  <span class="comment">-- no input </span></span><br><span class="line">    file, msg = <span class="built_in">io</span>.<span class="built_in">open</span>(name, <span class="string">&quot;r&quot;</span>) </span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> file <span class="keyword">then</span> <span class="built_in">print</span>(msg) <span class="keyword">end</span> </span><br><span class="line"><span class="keyword">until</span> file</span><br></pre></td></tr></table></figure>

<p>如果你想偷懒不想处理这些情况,又想代码安全的运行,可以简单的使用 assert:</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">file = <span class="built_in">assert</span>(<span class="built_in">io</span>.<span class="built_in">open</span>(name, <span class="string">&quot;r&quot;</span>)) </span><br></pre></td></tr></table></figure>

<p>Lua 中有一个习惯：如果io.open 失败,assert将抛出错误。</p>
<p><img src="/%5C2025_04_08_lua%5C687d97a43b8ee2beff2be27c1822461a4b4aee6f72f8154e2374b8d6577d554b.png"></p>
<p>注意：io.open 返回的第二个结果(错误信息)作为 assert 的第二个参数。</p>
<h2 id="8-4异常和错误处理"><a href="#8-4异常和错误处理" class="headerlink" title="8.4异常和错误处理"></a>8.4异常和错误处理</h2><p>很多应用中,不需要在Lua 进行错误处理,一般有应用来完成。通常应用要求Lua运行一段 chunk,如果发生异常,应用根据Lua 返回的错误代码进行处理。在控制台模式下的Lua解释器如果遇到异常,打印出错误然后继续显示提示符等待下一个命令。</p>
<p>如果在Lua 中需要处理错误,需要使用 pcall 函数封装你的代码。</p>
<p>假定你想运行一段Lua代码,这段代码运行过程中可以捕捉所有的异常和错误。</p>
<p>第一步：将这段代码封装在一个函数内</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span> <span class="params">()</span></span> </span><br><span class="line"> ... </span><br><span class="line"> <span class="keyword">if</span> unexpected_condition <span class="keyword">then</span> <span class="built_in">error</span>() <span class="keyword">end</span> </span><br><span class="line"> ... </span><br><span class="line"> <span class="built_in">print</span>(a[i]) <span class="comment">-- potential error: `a&#x27; may not be a table </span></span><br><span class="line"> ... </span><br><span class="line"><span class="keyword">end</span> </span><br></pre></td></tr></table></figure>

<p>第二步：使用 pcall 调用这个函数</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> <span class="built_in">pcall</span>(foo) <span class="keyword">then</span> </span><br><span class="line"> <span class="comment">-- no errors while running `foo&#x27; </span></span><br><span class="line"> ... </span><br><span class="line"><span class="keyword">else</span> </span><br><span class="line"> <span class="comment">-- `foo&#x27; raised an error: take appropriate actions </span></span><br><span class="line"> ... </span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>

<p>当然也可以用匿名函数的方式调用 pcall:</p>
<p><img src="/%5C2025_04_08_lua%5C2903446d4a457d3cde3ce74983b18865093028e8d0f9afbc6cc92da08f26a273.png"></p>
<p>pcall在保护模式下调用他的第一个参数并运行,因此可以捕获所有的异常和错误。如果没有异常和错误,pcall 返回 true 和调用返回的任何值；否则返回 nil 加错误信息。</p>
<p>错误信息不一定非要是一个字符串(下面的例子是一个 table),传递给 error 的任何信息都会被 pcall 返回:</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">local</span> <span class="built_in">status</span>, err = <span class="built_in">pcall</span>(<span class="function"><span class="keyword">function</span> <span class="params">()</span></span> <span class="built_in">error</span>(&#123;code=<span class="number">121</span>&#125;) <span class="keyword">end</span>) </span><br><span class="line"><span class="built_in">print</span>(err.code)  <span class="comment">--&gt;  121</span></span><br></pre></td></tr></table></figure>

<p>这种机制提供了我们在Lua 中处理异常和错误的所需要的全部内容。我们通过 error抛出异常,然后通过 pcall捕获他。</p>
<h2 id="8-5错误信息和回跟踪-Tracebacks"><a href="#8-5错误信息和回跟踪-Tracebacks" class="headerlink" title="8.5错误信息和回跟踪(Tracebacks)"></a>8.5错误信息和回跟踪(Tracebacks)</h2><p>虽然你可以使用任何类型的值作为错误信息,通常情况下,我们使用字符串来描述遇到的错误信息。如果遇到内部错误(比如对一个非table 的值使用索引下表访问)Lua将自己产生错误信息,否则Lua 使用传递给error 函数的参数作为错误信息。不管在什么情况下,Lua都尽可能清楚的描述发生的错误。</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">local</span> <span class="built_in">status</span>, err = <span class="built_in">pcall</span>(<span class="function"><span class="keyword">function</span> <span class="params">()</span></span> a = <span class="string">&#x27;a&#x27;</span>+<span class="number">1</span> <span class="keyword">end</span>) </span><br><span class="line"><span class="built_in">print</span>(err) <span class="comment">--&gt; stdin:1: attempt to perform arithmetic on a string value</span></span><br><span class="line"><span class="keyword">local</span> <span class="built_in">status</span>, err = <span class="built_in">pcall</span>(<span class="function"><span class="keyword">function</span> <span class="params">()</span></span> <span class="built_in">error</span>(<span class="string">&quot;my error&quot;</span>) <span class="keyword">end</span>) </span><br><span class="line"><span class="built_in">print</span>(err) </span><br><span class="line"><span class="comment">--&gt; stdin:1: my error </span></span><br></pre></td></tr></table></figure>

<p>例子中错误信息给出了文件名(stdin)加上行号。</p>
<p>函数error还可以有第二个参数,表示错误的运行级别。有了这个参数你就无法抵赖错误是别人的了,比如,加入你写了一个函数用来检查error 是否被正确的调用：</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span> <span class="params">(str)</span></span> </span><br><span class="line"><span class="keyword">if</span> <span class="built_in">type</span>(str) ~= <span class="string">&quot;string&quot;</span> <span class="keyword">then</span> </span><br><span class="line">  <span class="built_in">error</span>(<span class="string">&quot;string expected&quot;</span>) </span><br><span class="line"><span class="keyword">end</span> </span><br><span class="line"> ...</span><br><span class="line"><span class="keyword">end</span> </span><br></pre></td></tr></table></figure>

<p>可能有人这样调用这个函数:</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">foo(&#123;x=<span class="number">1</span>&#125;) </span><br></pre></td></tr></table></figure>

<p>Lua 会指出发生错误的是foo 而不是 error,实际的错误是调用 error 时产生的,为了纠正这个问题修改前面的代码让 error报告错误发生在第二级 (你自己的函数是第一级)如下:</p>
<p><img src="/%5C2025_04_08_lua%5Cbf51357f978544fcbb2b1315c30d2f87ffe9970044a19346fd0f70f3fcd42d98.png"></p>
<p>当错误发生的时候,我们常常需要更多的错误发生相关的信息,而不单单是错误发生的位置。至少期望有一个完整的显示导致错误发生的调用栈的 tracebacks,当 pcall 返回错误信息的时候他已经释放了保存错误发生情况的栈的信息。因此,如果我们想得到tracebacks 我们必须在 pcall 返回以前获取。Lua 提供了xpcall 来实现这个功能,xpcall误处理函数,因此可以使用 debug 库收集错误相关的信息。有两个常用的 debug 处理函数：debug。debug 和 debug.traceback,前者给出Lua 的提示符,你可以自己动手察看错误发生时的情况；后者通过 traceback 创建更多的错误信息,后者是控制台解释器用来构建错误信息的函数。你可以在任何时候调用 debug.traceback获取当前运行的traceback信息:</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">print</span>(<span class="built_in">debug</span>.<span class="built_in">traceback</span>())</span><br></pre></td></tr></table></figure>

<h1 id="第9章-协同程序"><a href="#第9章-协同程序" class="headerlink" title="第9章 协同程序"></a>第9章 协同程序</h1><p>协同程序(coroutine)与多线程情况下的线程比较类似：有自己的堆栈,自己的局部变量,有自己的指令指针,但是和其他协同程序共享全局变量等很多信息。线程和协同程序的主要不同在于：在多处理器情况下,从概念上来讲多线程程序同时运行多个线程；而协同程序是通过协作来完成,在任一指定时刻只有一个协同程序在运行,并且这个正在运行的协同程序只有在明确的被要求挂起的时候才会被挂起。</p>
<p>协同是非常强大的功能,但是用起来也很复杂。如果你第一次阅读本章时不理解本章中的例子请不要担心,你可以继续阅读本书的其他部分然后再回过头来阅读本章。</p>
<h2 id="9-1协同的基础"><a href="#9-1协同的基础" class="headerlink" title="9.1协同的基础"></a>9.1协同的基础</h2><p>Lua 通过 table 提供了所有的协同函数,create 函数创建一个新的协同程序,create只有一个参数：协同程序将要运行的代码封装而成的函数,返回值为 thread类型的值表示创建了一个新的协同程序。通常情况下,create 的参数是一个匿名函数:</p>
<p><img src="/%5C2025_04_08_lua%5C4d40341a151e1237f1f56a0fdfe6871832f29c083243b5478267f27f110cf6a7.png"></p>
<p>协同有三个状态：挂起态、运行态、停止态。当我们创建一个协同程序时他开始的状态为挂起态,也就是说我们创建协同程序的时候不会自动运行,可以使用 status 函数检查协同的状态：</p>
<p><img src="/%5C2025_04_08_lua%5Cd68c48918bcecb0e5544b583ec64b630d46d30313efb1de0c0a6496486f6cc8a.png"></p>
<p>函数coroutine.resume 可以使程序由挂起状态变为运行态：</p>
<p><img src="/%5C2025_04_08_lua%5C0e636d38ef414a0c5660b338aa7614920511d15a91200228d2d760e84e71d033.png"></p>
<p>这个例子中,协同体仅仅打印出”hi”之后便进入终止状态:</p>
<p><img src="/%5C2025_04_08_lua%5C2a05ca4ae282a3ab47cbb6e8721d34a7e9fc1f7c94cf9ee40e929f9cd86e3e15.png"></p>
<p>当目前为止,协同看起来只是一种复杂的调用函数的方式,真正的强大之处体现在yield 函数,它可以将正在运行的代码挂起,看一个例子:</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">co = <span class="built_in">coroutine</span>.<span class="built_in">create</span>(<span class="function"><span class="keyword">function</span> <span class="params">()</span></span> </span><br><span class="line">    <span class="keyword">for</span> i=<span class="number">1</span>,<span class="number">10</span> <span class="keyword">do</span></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;co&quot;</span>, i) </span><br><span class="line">        <span class="built_in">coroutine</span>.<span class="built_in">yield</span>() </span><br><span class="line">    <span class="keyword">end</span> </span><br><span class="line"><span class="keyword">end</span>)</span><br></pre></td></tr></table></figure>

<p>现在重新执行这个协同程序，程序将在第一个yield处被挂起：</p>
<p><img src="/%5C2025_04_08_lua%5Cb7d35756ebace5997b3701d2131bf290445bf88e54466e16326d8cd84abac63c.png"></p>
<p>从协同的观点看：使用函数yield可以使程序挂起,当我们激活被挂起的程序时，yield<br>返回并继续程序的执行直到再次遇到yield或者程序结束。 </p>
<p><img src="/%5C2025_04_08_lua%5C6187947fcacd1074a28d0266f901882f7432d1ddc8fb1d74c175cc0b41167cce.png"></p>
<p>上面最后一次调用的时候,协同体已经结束,因此协同程序处于终止状态。如果我们仍然企图激活他,resume 将返回 false和错误信息。</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">print</span>(<span class="built_in">coroutine</span>.<span class="built_in">resume</span>(co)) </span><br><span class="line">  <span class="comment">--&gt; false   cannot resume dead coroutine </span></span><br></pre></td></tr></table></figure>

<p>注意:resume 运行在保护模式下,因此如果协同内部存在错误Lua 并不会抛出错误而是将错误返回给resume函数。</p>
<p>Lua 中一对 resume-yield 可以相互交换数据。</p>
<p>下面第一个例子resume,没有相应的 yield,resume 把额外的参数传递给协同的主程序。</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">co = <span class="built_in">coroutine</span>.<span class="built_in">create</span>(<span class="function"><span class="keyword">function</span> <span class="params">(a,b,c)</span></span> </span><br><span class="line"> <span class="built_in">print</span>(<span class="string">&quot;co&quot;</span>, a,b,c) </span><br><span class="line"><span class="keyword">end</span>) </span><br><span class="line"><span class="built_in">coroutine</span>.<span class="built_in">resume</span>(co, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>)  <span class="comment">--&gt; co  1  2  3 </span></span><br></pre></td></tr></table></figure>

<p>第二个例子,resume 返回除了 true 以外的其他部分将作为参数传递给相应的 yield</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">co = <span class="built_in">coroutine</span>.<span class="built_in">create</span>(<span class="function"><span class="keyword">function</span> <span class="params">(a,b)</span></span> </span><br><span class="line"> <span class="built_in">coroutine</span>.<span class="built_in">yield</span>(a + b, a - b) </span><br><span class="line"><span class="keyword">end</span>) </span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">coroutine</span>.<span class="built_in">resume</span>(co, <span class="number">20</span>, <span class="number">10</span>)) <span class="comment">--&gt; true  30  10    </span></span><br></pre></td></tr></table></figure>

<p>对称性,yield返回的额外的参数也将会传递给 resume。</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">co = <span class="built_in">coroutine</span>.<span class="built_in">create</span> (<span class="function"><span class="keyword">function</span> <span class="params">()</span></span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;co&quot;</span>, <span class="built_in">coroutine</span>.<span class="built_in">yield</span>()) </span><br><span class="line"><span class="keyword">end</span>) </span><br><span class="line"><span class="built_in">coroutine</span>.<span class="built_in">resume</span>(co) </span><br><span class="line"><span class="built_in">coroutine</span>.<span class="built_in">resume</span>(co, <span class="number">4</span>, <span class="number">5</span>)  <span class="comment">--&gt; co  4  5 </span></span><br></pre></td></tr></table></figure>

<p>最后一个例子,当协同代码结束时主函数返回的值都会传给相应的resume:</p>
<p><img src="/%5C2025_04_08_lua%5C219972b117c73a7df3ae9faa97168fbfed5ca9616b4477b519569cd0cb007e7b.png"></p>
<p>我们很少在同一个协同程序中使用这几种特性,但每一种都有其用处</p>
<p>现在已经了解了一些协同的内容,在我们继续学习以前,先要澄清两个概念：Lua提供的这种协同我们称为不对称的协同,就是说挂起一个正在执行的协同的函数与使一个被挂起的协同再次执行的函数是不同的,有些语言提供对称的协同,这种情况下,由执行到挂起之间状态转换的函数是相同的。</p>
<p>有人称不对称的协同为半协同,另一些人使用同样的术语表示真正的协同,严格意义上的协同不论在什么地方只要它不是在其他的辅助代码内部的时候都可以并且只能使执行挂起,不论什么时候在其控制栈内都不会有不可决定的调用。(However,other peopleuse the same term semi-coroutine to denote a restricted implementation of coroutines, where acoroutine can only suspend its execution when it is not inside any auxiliary function, that is,when it has no pending calls in its control stack.)。只有半协同程序的主体中才可以 yield,python 中的产生器（generator）就是这种类型的半协同的例子。</p>
<p>与对称的协同和不对称协同的区别不同的是,协同与产生器的区别更大。产生器相对比较简单,他不能完成真正的协同所能完成的一些任务。我们熟练使用不对称的协同之后,可以利用不对称的协同实现比较优越的对称协同。</p>
<h2 id="9-2管道和过滤器"><a href="#9-2管道和过滤器" class="headerlink" title="9.2管道和过滤器"></a>9.2管道和过滤器</h2><p>协同最有代表性的作用是用来描述生产者-消费者问题。我们假定有一个函数在不断(中一)一中)这两个函数如下:</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">producer</span> <span class="params">()</span></span> </span><br><span class="line"><span class="keyword">while</span> <span class="literal">true</span> <span class="keyword">do</span> </span><br><span class="line">  <span class="keyword">local</span> x = <span class="built_in">io</span>.<span class="built_in">read</span>()  </span><br><span class="line">  send(x)     <span class="comment">-- produce new value -- send to consumer </span></span><br><span class="line"> <span class="keyword">end</span> </span><br><span class="line"><span class="keyword">end</span> </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">consumer</span> <span class="params">()</span></span> </span><br><span class="line"> <span class="keyword">while</span> <span class="literal">true</span> <span class="keyword">do</span> </span><br><span class="line">  <span class="keyword">local</span> x = receive()  <span class="comment">-- receive from producer </span></span><br><span class="line">  <span class="built_in">io</span>.<span class="built_in">write</span>(x, <span class="string">&quot;\n&quot;</span>)   <span class="comment">-- consume new value </span></span><br><span class="line"> <span class="keyword">end</span> </span><br><span class="line"><span class="keyword">end</span> </span><br></pre></td></tr></table></figure>

<p>（例子中生产者和消费者都在不停的循环，修改一下使得没有数据的时候他们停下<br>来并不困难），问题在于如何使得receive和send协同工作。只是一个典型的谁拥有住循<br>环的情况，生产者和消费者都处在活动状态，都有自己的主循环，都认为另一方是可调<br>用的服务。对于这种特殊的情况，可以改变一个函数的结构解除循环，使其作为被动的<br>接受。然而这种改变在某些特定的实际情况下可能并不简单。 </p>
<p>协同为解决这种问题提供了理想的方法,因为调用者与被调用者之间的resume-yield关系会不断颠倒。当一个协同调用 yield时并不会进入一个新的函数,取而代之的是返回一个未决的 resume 的调用。相似的,调用 resume 时也不会开始一个新的函数而是返回yield 的调用。这种性质正是我们所需要的,与使得 send-receive 协同工作的方式是一致的.receive 唤醒生产者生产新值,send把产生的值送给消费者消费。</p>
<p><img src="/%5C2025_04_08_lua%5Ca88231ff668b1f2e0b53149f24c4694cc3450533a1383e5ccaaaa01106cc9ce7.png"></p>
<p>这种设计下,开始时调用消费者,当消费者需要值时他唤起生产者生产值,生产者生产值后停止直到消费者再次请求。我们称这种设计为消费者驱动的设计。</p>
<p>我们可以使用过滤器扩展这个涉及,过滤器指在生产者与消费者之间,可以对数据进行某些转换处理。过滤器在同一时间既是生产者又是消费者,他请求生产者生产值并且转换格式后传给消费者,我们修改上面的代码加入过滤器(每一行前面加上行号)。完整的代码如下：</p>
<p><img src="/%5C2025_04_08_lua%5C79ab6e7526e5286ec457312eb07a73c3a17a6939d084a0b394f9e1b887dbd1d7.png"></p>
<p>可以调用：</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">p = producer()</span><br><span class="line">f = filter(p) </span><br><span class="line">consumer(f)</span><br></pre></td></tr></table></figure>

<p>或者：</p>
<p><img src="/%5C2025_04_08_lua%5C8c1320466ce22aa0fbd0b7c4a1239bd6d363d74f442f9a8f36c22c6fdbfa4747.png"></p>
<p>看完上面这个例子你可能很自然的想到UNIX的管道,协同是一种非抢占式的多线程。管道的方式下,每一个任务在独立的进程中运行,而协同方式下,每个任务运行在独立的协同代码中。管道在读(consumer)与写(producer)之间提供了一个缓冲,因此两者相关的的速度没有什么限制,在上下文管道中这是非常重要的,因为在进程间的切换代价是很高的。协同模式下,任务间的切换代价较小,与函数调用相当,因此读写可以很好的协同处理。</p>
<h2 id="9-3用作迭代器的协同"><a href="#9-3用作迭代器的协同" class="headerlink" title="9.3用作迭代器的协同"></a>9.3用作迭代器的协同</h2><p>我们可以将循环的迭代器看作生产者-消费者模式的特殊的例子。迭代函数产生值给循环体消费。所以可以使用协同来实现迭代器。协同的一个关键特征是它可以不断颠倒调用者与被调用者之间的关系,这样我们毫无顾虑的使用它实现一个迭代器,而不用保存迭代函数返回的状态。</p>
<p>我们来完成一个打印一个数组元素的所有的排列来阐明这种应用。直接写这样一个迭代函数来完成这个任务并不容易,但是写一个生成所有排列的递归函数并不难。思路是这样的：将数组中的每一个元素放到最后,依次递归生成所有剩余元素的排列。代码如下:</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">permgen</span> <span class="params">(a, n)</span></span> </span><br><span class="line"> <span class="keyword">if</span> n == <span class="number">0</span> <span class="keyword">then</span> </span><br><span class="line">  printResult(a) </span><br><span class="line"> <span class="keyword">else</span> </span><br><span class="line">  <span class="keyword">for</span> i=<span class="number">1</span>,n <span class="keyword">do</span> </span><br><span class="line"> </span><br><span class="line">   <span class="comment">-- put i-th element as the last one </span></span><br><span class="line">   a[n], a[i] = a[i], a[n] </span><br><span class="line"> </span><br><span class="line">   <span class="comment">-- generate all permutations of the other elements </span></span><br><span class="line">   permgen(a, n - <span class="number">1</span>) </span><br><span class="line"> </span><br><span class="line">   <span class="comment">-- restore i-th element </span></span><br><span class="line">   a[n], a[i] = a[i], a[n] </span><br><span class="line"> </span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line"> <span class="keyword">end</span> </span><br><span class="line"><span class="keyword">end</span> </span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">printResult</span> <span class="params">(a)</span></span> </span><br><span class="line"> <span class="keyword">for</span> i,v <span class="keyword">in</span> <span class="built_in">ipairs</span>(a) <span class="keyword">do</span> </span><br><span class="line">  <span class="built_in">io</span>.<span class="built_in">write</span>(v, <span class="string">&quot; &quot;</span>) </span><br><span class="line"> <span class="keyword">end</span> </span><br><span class="line"> <span class="built_in">io</span>.<span class="built_in">write</span>(<span class="string">&quot;\n&quot;</span>) </span><br><span class="line"><span class="keyword">end</span> </span><br><span class="line"> </span><br><span class="line">permgen (&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>&#125;, <span class="number">4</span>) </span><br></pre></td></tr></table></figure>

<p>有了上面的生成器后,下面我们将这个例子修改一下使其转换成一个迭代函数:</p>
<ol>
<li>第一步 printResult 改为 yield</li>
</ol>
<p><img src="/%5C2025_04_08_lua%5Cc957421fd2272980f7f3734bc399f9b7de4eb7443b8434f6640e9f497f74fc1c.png"></p>
<ol start="2">
<li>第二步,我们定义一个迭代工厂,修改生成器在生成器内创建迭代函数,并使生成器运行在一个协同程序内。迭代函数负责请求协同产生下一个可能的排列。</li>
</ol>
<p><img src="/%5C2025_04_08_lua%5Cd0cf427003b1af71be79963b4f8ac9a1c4286a22c51ec211dfb01b6e529b2cd6.png"></p>
<p>这样我们就可以使用 for循环来打印出一个数组的所有排列情况了：</p>
<p><img src="/%5C2025_04_08_lua%5C86ff4857fb44cfd1854855830e7df1594325f9c27c6a909bdd3a7453c93931c1.png"></p>
<p>perm 函数使用了 Lua 中常用的模式：将一个对协同的 resume 的调用封装在一个函数内部,这种方式在Lua非常常见,所以Lua专门为此专门提供了一个函数coroutine.wrap。与 create 相同的是,wrap 创建一个协同程序；不同的是 wrap 不返回协同本身,而是返回一个函数,当这个函数被调用时将 resume 协同。wrap 中 resume 协同以使用 wrap 重写 perm:</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">perm</span> <span class="params">(a)</span></span> </span><br><span class="line">    <span class="keyword">local</span> n = <span class="built_in">table</span>.<span class="built_in">getn</span>(a) </span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">coroutine</span>.<span class="built_in">wrap</span>(<span class="function"><span class="keyword">function</span> <span class="params">()</span></span> permgen(a, n) <span class="keyword">end</span>) </span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>

<p>一般情况下,coroutine.wrap比 coroutine.create使用起来简单直观,前者更确切的提供了我们所需要的：一个可以 resume 协同的函数,然而缺少灵活性,没有办法知道 wrap所创建的协同的状态,也没有办法检查错误的发生。</p>
<h2 id="9-4非抢占式多线程"><a href="#9-4非抢占式多线程" class="headerlink" title="9.4非抢占式多线程"></a>9.4非抢占式多线程</h2><p>如前面所见,Lua中的协同是一协作的多线程,每一个协同等同于一个线程,yield-resume 可以实现在线程中切换。然而与真正的多线程不同的是,协同是非抢占式的。当一个协同正在运行时,不能在外部终止他。只能通过显示的调用 yield 挂起他的执行。对于某些应用来说这个不存在问题,但有些应用对此是不能忍受的。不存在抢占式调用的程序是容易编写的。不需要考虑同步带来的bugs,因为程序中的所有线程间的同步都是显示的。你仅仅需要在协同代码超出临界区时调用 yield 即可。</p>
<p>对非抢占式多线程来说,不管什么时候只要有一个线程调用一个阻塞操作(blocking)忍受的,这使得很多程序员离协同而去。下面我们将看到这个问题可以被有趣的解决。</p>
<p>看一个多线程的例子：我们想通过http 协议从远程主机上下在一些文件。我们使用Diego Nehab 开发的LuaSocket 库来完成。我们先看下在一个文件的实现,大概步骤是打开一个到远程主机的连接,发送下载文件的请求,开始下载文件,下载完毕后关闭连接。</p>
<p>第一,加载LuaSocket库</p>
<p><img src="/%5C2025_04_08_lua%5Ce5160c94b87229c30f282a4ade370c494da8613b8dd28bd3c2dd617c7bb3509b.png"></p>
<p>第二,定义远程主机和需要下载的文件名</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">host = &quot;www.w3.org&quot; </span><br><span class="line">file = &quot;/TR/REC-html32.html&quot; </span><br></pre></td></tr></table></figure>

<p>第三,打开一个TCP 连接到远程主机的 80 端口(http 服务的标准端口)</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">c = <span class="built_in">assert</span>(socket.connect(host, <span class="number">80</span>)) </span><br></pre></td></tr></table></figure>

<p>上面这句返回一个连接对象,我们可以使用这个连接对象请求发送文件</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">c:send(<span class="string">&quot;GET &quot;</span> .. file .. <span class="string">&quot; HTTP/1.0\r\n\r\n&quot;</span>) </span><br></pre></td></tr></table></figure>

<p>receive 函数返回他送接收到的数据加上一个表示操作状态的字符串。当主机断开连接时,我们退出循环。</p>
<p>第四,关闭连接</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">c:<span class="built_in">close</span>()</span><br></pre></td></tr></table></figure>

<p>现在我们知道了如何下载一个文件,下面我们来看看如何下载多个文件。一种方法是我们在一个时刻只下载一个文件,这种顺序下载的方式必须等前一个文件下载完成后一个文件才能开始下载。实际上是,当我们发送一个请求之后有很多时间是在等待数据的到达,也就是说大部分时间浪费在调用receive上。如果同时可以下载多个文件,效率将会有很大提高。当一个连接没有数据到达时,可以从另一个连接读取数据。很显然,协同为这种同时下载提供了很方便的支持,我们为每一个下载任务创建一个线程,当一个线程没有数据到达时,他将控制权交给一个分配器,由分配器唤起另外的线程读取数据。</p>
<p>使用协同机制重写上面的代码,在一个函数内：</p>
<p><img src="/%5C2025_04_08_lua%5C4b0f80a91489b3a411721fc18a327036d7eb2b7cfe579fdf46dd848db033c35c.png"></p>
<p>由于我们不关心文件的内容,上面的代码只是计算文件的大小而不是将文件内容输出。(当有多个线程下载多个文件时,输出会混杂在一起),在新的函数代码中,我们使用receive从远程连接接收数据,在顺序接收数据的方式下代码如下:</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">receive</span> <span class="params">(connection)</span></span> </span><br><span class="line">    <span class="keyword">return</span> connection:receive(<span class="number">2</span>^<span class="number">10</span>) </span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>

<p>在同步接受数据的方式下,函数接收数据时不能被阻塞,而是在没有数据可取时yield,代码如下:</p>
<p><img src="/%5C2025_04_08_lua%5Cf64d16a850c7530ab6625473e40bc64666726c93a20ca2868d92dbdffe726944.png"></p>
<p>调用函数 timeout(O)使得对连接的任何操作都不会阻塞。当操作返回的状态为timeout 时意味着操作未完成就返回了。在这种情况下,线程 yield。非 false 的数值作为yield的参数告诉分配器线程仍在执行它的任务。(后面我们将看到分配器需要timeout连接的情况),注意:即使在 timeout 模式下,连接依然返回他接受到直到 timeout 为止,因此receive会一直返回 s给她的调用者。</p>
<p>下面的函数保证每一个下载运行在自己独立的线程内：</p>
<p><img src="/%5C2025_04_08_lua%5C1f522dae7d982de3a1da6b55f2184089223c31faf7f3a28ba49ec2c49aa7195f.png"></p>
<p>代码中 table 中为分配器保存了所有活动的线程。</p>
<p>分配器代码是很简单的,它是一个循环,逐个调用每一个线程。并且从线程列表中移除已经完成任务的线程。当没有线程可以运行时退出循环。</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">dispatcher</span> <span class="params">()</span></span> </span><br><span class="line"> <span class="keyword">while</span> <span class="literal">true</span> <span class="keyword">do</span> </span><br><span class="line">  <span class="keyword">local</span> n = <span class="built_in">table</span>.<span class="built_in">getn</span>(threads) </span><br><span class="line">  <span class="keyword">if</span> n == <span class="number">0</span> <span class="keyword">then</span> <span class="keyword">break</span> <span class="keyword">end</span>  <span class="comment">-- no more threads to run </span></span><br><span class="line">  <span class="keyword">for</span> i=<span class="number">1</span>,n <span class="keyword">do</span> </span><br><span class="line">   <span class="keyword">local</span> <span class="built_in">status</span>, res = <span class="built_in">coroutine</span>.<span class="built_in">resume</span>(threads[i]) </span><br><span class="line">   <span class="keyword">if</span> <span class="keyword">not</span> res <span class="keyword">then</span> <span class="comment">-- thread finished its task? </span></span><br><span class="line">    <span class="built_in">table</span>.<span class="built_in">remove</span>(threads, i) </span><br><span class="line">    <span class="keyword">break</span> </span><br><span class="line">   <span class="keyword">end</span> </span><br><span class="line">  <span class="keyword">end</span> </span><br><span class="line"> <span class="keyword">end</span> </span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>

<p>最后,在主程序中创建需要的线程调用分配器,例如：从 W3C 站点上下载4个文件：</p>
<p><img src="/%5C2025_04_08_lua%5Cb4ff3546af8fa747640fd03e0cf2b4c80cafc8669544d6afdcd90f89ba3bf4e7.png"></p>
<p>使用协同方式下,我的机器花了6s下载完这几个文件；顺序方式下用了15s,大概2 倍的时间。</p>
<p>尽管效率提高了,但距离理想的实现还相差甚远,当至少有一个线程有数据可读取的时候,这段代码可以很好的运行。否则,分配器将进入忙等待状态,从一个线程到另个线程不停的循环判断是否有数据可获取。结果协同实现的代码比顺序读取将花费30倍的CPU时间。</p>
<p>为了避免这种情况出现,我们可以使用LuaSocket 库中的 select 函数。当程序在一组 socket中不断的循环等待状态改变时,它可以使程序被阻塞。我们只需要修改分配器,使用 select 函数修改后的代码如下:</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">dispatcher</span> <span class="params">()</span></span> </span><br><span class="line"> <span class="keyword">while</span> <span class="literal">true</span> <span class="keyword">do</span> </span><br><span class="line">  <span class="keyword">local</span> n = <span class="built_in">table</span>.<span class="built_in">getn</span>(threads) </span><br><span class="line">  <span class="keyword">if</span> n == <span class="number">0</span> <span class="keyword">then</span> <span class="keyword">break</span> <span class="keyword">end</span>  <span class="comment">-- no more threads to run </span></span><br><span class="line">  <span class="keyword">local</span> connections = &#123;&#125; </span><br><span class="line">  <span class="keyword">for</span> i=<span class="number">1</span>,n <span class="keyword">do</span> </span><br><span class="line">   <span class="keyword">local</span> <span class="built_in">status</span>, res = <span class="built_in">coroutine</span>.<span class="built_in">resume</span>(threads[i]) </span><br><span class="line">   <span class="keyword">if</span> <span class="keyword">not</span> res <span class="keyword">then</span> <span class="comment">-- thread finished its task? </span></span><br><span class="line">    <span class="built_in">table</span>.<span class="built_in">remove</span>(threads, i) </span><br><span class="line">    <span class="keyword">break</span> </span><br><span class="line">   <span class="keyword">else</span> <span class="comment">-- timeout </span></span><br><span class="line">    <span class="built_in">table</span>.<span class="built_in">insert</span>(connections, res) </span><br><span class="line">   <span class="keyword">end</span> </span><br><span class="line">  <span class="keyword">end</span> </span><br><span class="line">  <span class="keyword">if</span> <span class="built_in">table</span>.<span class="built_in">getn</span>(connections) == n <span class="keyword">then</span> </span><br><span class="line">   socket.<span class="built_in">select</span>(connections) </span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line"> <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>

<p>在内层的循环分配器收集连接表中timeout地连接,注意:receive将连接传递给yield,因此 resume 返回他们。当所有的连接都 timeout 分配器调用 select 等待任一连接状态的改变。最终的实现效率和上一个协同实现的方式相当,另外,他不会发生忙等待,比起顺序实现的方式消耗CPU的时间仅仅多一点点。</p>
<h1 id="第10章完整示例"><a href="#第10章完整示例" class="headerlink" title="第10章完整示例"></a>第10章完整示例</h1><p>我们看两个完整的例子来阐明Lua 语言的使用。第一个例子来自于Lua 网站,他展示了Lua作为数据描述语言的使用。第二个例子讲解了马尔可夫链算法的实现,这个算法在Kernighan &amp; Pike 著作的 Practice of Programming 书中也有描述。这两个完整的例子之后,Lua 语言方面的介绍便到此结束。后面将继续介绍table 和面向对象的内容以及标准库、C-API等。</p>
<h2 id="10-1Lua作为数据描述语言使用"><a href="#10-1Lua作为数据描述语言使用" class="headerlink" title="10.1Lua作为数据描述语言使用"></a>10.1Lua作为数据描述语言使用</h2><p>Lua 网站保留一个包含世界各地使用Lua 创建的工程的例子的数据库。在数据库中我们用一个构造器以自动归档的方式表示每一个工程入口点,代码如下:</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">entry&#123; </span><br><span class="line">title = <span class="string">&quot;Tecgraf&quot;</span>, </span><br><span class="line">org = <span class="string">&quot;Computer Graphics Technology Group, PUC-Rio&quot;</span>, </span><br><span class="line">url = <span class="string">&quot;http://www.tecgraf.puc-rio.br/&quot;</span>, </span><br><span class="line">contact = <span class="string">&quot;Waldemar Celes&quot;</span>, </span><br><span class="line">description = <span class="string">[[ </span></span><br><span class="line"><span class="string">TeCGraf is the result of a partnership between PUC-Rio, </span></span><br><span class="line"><span class="string">the Pontifical Catholic University of Rio de Janeiro, </span></span><br><span class="line"><span class="string">and &lt;A HREF=&quot;http://www.petrobras.com.br/&quot;&gt;PETROBRAS&lt;/A&gt;, </span></span><br><span class="line"><span class="string">the Brazilian Oil Company. </span></span><br><span class="line"><span class="string">TeCGraf is Lua&#x27;s birthplace, </span></span><br><span class="line"><span class="string">and the language has been used there since 1993. </span></span><br><span class="line"><span class="string">Currently, more than thirty programmers in TeCGraf use </span></span><br><span class="line"><span class="string">Lua regularly; they have written more than two hundred </span></span><br><span class="line"><span class="string">&#125; </span></span><br><span class="line"><span class="string">thousand lines of code, distributed among dozens of </span></span><br><span class="line"><span class="string">final products.]]</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>有趣的是,工程入口的列表是存放在一个Lua 文件中的,每个工程入口以 table 的形式作为参数去调用 entry 函数。我们的目的是写一个程序将这些数据以 html 格式展示出来。由于工程太多,我们首先列出工程的标题,然后显示每个工程的明细。结果如下:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">&lt;HTML&gt; </span><br><span class="line">&lt;HEAD&gt;&lt;TITLE&gt;Projects using Lua&lt;/TITLE&gt;&lt;/HEAD&gt; </span><br><span class="line">&lt;BODY BGCOLOR=&quot;#FFFFFF&quot;&gt; </span><br><span class="line">Here are brief descriptions of some projects around the </span><br><span class="line">world that use &lt;A HREF=&quot;home.html&quot;&gt;Lua&lt;/A&gt;. </span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">&lt;UL&gt; </span><br><span class="line">&lt;LI&gt;&lt;A HREF=&quot;#1&quot;&gt;TeCGraf&lt;/A&gt; </span><br><span class="line">&lt;LI&gt; ... </span><br><span class="line">&lt;/UL&gt; </span><br><span class="line"> </span><br><span class="line">&lt;H3&gt; </span><br><span class="line">&lt;A NAME=&quot;1&quot; </span><br><span class="line"> HREF=&quot;http://www.tecgraf.puc-rio.br/&quot;&gt;TeCGraf&lt;/A&gt; </span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">&lt;SMALL&gt;&lt;EM&gt;Computer Graphics Technology Group, </span><br><span class="line">PUC-Rio&lt;/EM&gt;&lt;/SMALL&gt; </span><br><span class="line">&lt;/H3&gt; </span><br><span class="line"> </span><br><span class="line">TeCGraf is the result of a partnership between </span><br><span class="line">... </span><br><span class="line">distributed among dozens of final products.&lt;P&gt; </span><br><span class="line">Contact: Waldemar Celes </span><br><span class="line"> </span><br><span class="line">&lt;A NAME=&quot;2&quot;&gt;&lt;/A&gt;&lt;HR&gt; </span><br><span class="line">... </span><br><span class="line"> </span><br><span class="line">&lt;/BODY&gt;&lt;/HTML&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>为了读取数据,我们需要做的是正确的定义函数 entry,然后使用 dofile 直接运行数据文件即可(db.lua)。注意,我们需要遍历入口列表两次,第一次为了获取标题,第二所有的入口放在一个数组内；另一种方法：使用不同的entry 函数运行数据文件两次。因为Lua 编译文件是很快的,这里我们选用第二种方法。</p>
<p>首先,我们定义一个辅助函数用来格式化文本的输出(参见5.2函数部分内容)</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fwrite</span> <span class="params">(fmt, ...)</span></span> </span><br><span class="line"> <span class="keyword">return</span> <span class="built_in">io</span>.<span class="built_in">write</span>(<span class="built_in">string</span>.<span class="built_in">format</span>(fmt, <span class="built_in">unpack</span>(<span class="built_in">arg</span>))) </span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>

<p>第二,我们定义一个BEGIN 函数用来写html 页面的头部</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">BEGIN</span><span class="params">()</span></span> </span><br><span class="line"><span class="built_in">io</span>.<span class="built_in">write</span>(<span class="string">[[ </span></span><br><span class="line"><span class="string">&lt;HTML&gt; </span></span><br><span class="line"><span class="string">&lt;HEAD&gt;&lt;TITLE&gt;Projects using Lua&lt;/TITLE&gt;&lt;/HEAD&gt; </span></span><br><span class="line"><span class="string">&lt;BODY BGCOLOR=&quot;#FFFFFF&quot;&gt; </span></span><br><span class="line"><span class="string">Here are brief descriptions of some projects around the </span></span><br><span class="line"><span class="string">world that use &lt;A HREF=&quot;home.html&quot;&gt;Lua&lt;/A&gt;. </span></span><br><span class="line"><span class="string">]]</span>) </span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>

<p>第三,定义 entry 函数</p>
<p>a．第一个entry函数,将每个工程一列表方式写出,entry的参数o是描述工程的table。</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">entry0</span> <span class="params">(o)</span></span> </span><br><span class="line"> N=N + <span class="number">1</span> </span><br><span class="line"> <span class="keyword">local</span> title = o.title <span class="keyword">or</span> <span class="string">&#x27;(no title)&#x27;</span> </span><br><span class="line"> fwrite(<span class="string">&#x27;&lt;LI&gt;&lt;A HREF=&quot;#%d&quot;&gt;%s&lt;/A&gt;\n&#x27;</span>, N, title) </span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>

<p>如果 o.title 为 nil 表明 table 中的域 title 没有提供,我们用固定的”no title”替换。</p>
<p>b．第二个 éntry 函数,写出工程所有的相关信息,稍微有些复杂,因为所有项都是可选的。</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">entry1</span> <span class="params">(o)</span></span> </span><br><span class="line"> N=N + <span class="number">1</span> </span><br><span class="line"> <span class="keyword">local</span> title = o.title <span class="keyword">or</span> o.org <span class="keyword">or</span> <span class="string">&#x27;org&#x27;</span> </span><br><span class="line"> fwrite(<span class="string">&#x27;&lt;HR&gt;\n&lt;H3&gt;\n&#x27;</span>) </span><br><span class="line"> <span class="keyword">local</span> href = <span class="string">&#x27;&#x27;</span> </span><br><span class="line"> </span><br><span class="line"> <span class="keyword">if</span> o.url <span class="keyword">then</span> </span><br><span class="line">  href = <span class="built_in">string</span>.<span class="built_in">format</span>(<span class="string">&#x27; HREF=&quot;%s&quot;&#x27;</span>, o.url) </span><br><span class="line"> <span class="keyword">end</span> </span><br><span class="line"> fwrite(<span class="string">&#x27;&lt;A NAME=&quot;%d&quot;%s&gt;%s&lt;/A&gt;\n&#x27;</span>, N, href, title) </span><br><span class="line"> </span><br><span class="line"> <span class="keyword">if</span> o.title <span class="keyword">and</span> o.org <span class="keyword">then</span> </span><br><span class="line">  fwrite(<span class="string">&#x27;\n&lt;SMALL&gt;&lt;EM&gt;%s&lt;/EM&gt;&lt;/SMALL&gt;&#x27;</span>, o.org) </span><br><span class="line"> <span class="keyword">end</span> </span><br><span class="line"> fwrite(<span class="string">&#x27;\n&lt;/H3&gt;\n&#x27;</span>) </span><br><span class="line"> </span><br><span class="line"> <span class="keyword">if</span> o.description <span class="keyword">then</span> </span><br><span class="line">  fwrite(<span class="string">&#x27;%s&#x27;</span>, <span class="built_in">string</span>.<span class="built_in">gsub</span>(o.description, </span><br><span class="line"><span class="string">&#x27;\n\n\n*&#x27;</span>, <span class="string">&#x27;&lt;P&gt;\n&#x27;</span>)) </span><br><span class="line">  fwrite(<span class="string">&#x27;&lt;P&gt;\n&#x27;</span>) </span><br><span class="line"> <span class="keyword">end</span> </span><br><span class="line"> </span><br><span class="line"> <span class="keyword">if</span> o.email <span class="keyword">then</span> </span><br><span class="line">  fwrite(<span class="string">&#x27;Contact: &lt;A HREF=&quot;mailto:%s&quot;&gt;%s&lt;/A&gt;\n&#x27;</span>, </span><br><span class="line">    o.email, o.contact <span class="keyword">or</span> o.email) </span><br><span class="line"> <span class="keyword">elseif</span> o.contact <span class="keyword">then</span> </span><br><span class="line">  fwrite(<span class="string">&#x27;Contact: %s\n&#x27;</span>, o.contact) </span><br><span class="line"> <span class="keyword">end</span> </span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>

<p>由于html中使用双引号,为了避免冲突我们这里使用单引号表示串。</p>
<p>第四,定义END 函数,写 html 的尾部</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">END</span><span class="params">()</span></span> </span><br><span class="line">    fwrite(<span class="string">&#x27;&lt;/BODY&gt;&lt;/HTML&gt;\n&#x27;</span>) </span><br><span class="line"><span class="keyword">end</span> </span><br></pre></td></tr></table></figure>

<p>在主程序中,我们首先使用第一个 entry 运行数据文件输出工程名称的列表,然后再以第二个 entry 运行数据文件输出工程相关信息。</p>
<p><img src="/%5C2025_04_08_lua%5Cfa3e6fe89033441a2e7cf92101cf9259bb24444f104a4af89d4e1aeb36f30281.png"></p>
<h2 id="10-2马尔可夫链算法"><a href="#10-2马尔可夫链算法" class="headerlink" title="10.2马尔可夫链算法"></a>10.2马尔可夫链算法</h2><p>我们第二个例子是马尔可夫链算法的实现,我们的程序以前 n(n&#x3D;2)个单词串为基础随机产生一个文本串。</p>
<p>程序的第一部分读出原文,并且对没两个单词的前缀建立一个表,这个表给出了具有那些前缀的单词的一个顺序。建表完成后，这个程序利用这张表生成一个随机的文本。在此文本中，每个单词都跟随着它的的前两个单词，这两个单词在文本中有相同的概率。这样，我们就产生了一个非常随机，但并不完全随机的文本。例如，当应用这个程序的输出结果会出现“构造器也可以通过表构造器，那么一下几行的插入语对于整个文件来说，不是来存储每个功能的内容，而是来展示它的结构。”如果你想在队列里找到最大元素并返回最大值，接着显示提示和运行代码。下面的单词是保留单词，不能用在度和弧度之间转换。</p>
<p>我们编写一个函数用来将两个单词中间加上空个连接起来:</p>
<p><img src="/%5C2025_04_08_lua%5C120d1c0c2972bcf76e19efc19ac33652944e5fd8035eb481d4b3f977ca94a7aa.png"></p>
<p>我们用 NOWORD（即\n）表示文件的结尾并且初始化前缀单词，例如，下面的文<br>本：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">the more we try the more we do</span><br></pre></td></tr></table></figure>

<p>初始化构造的表为：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&#123; </span><br><span class="line"> [&quot;\n \n&quot;]  = &#123;&quot;the&quot;&#125;,  </span><br><span class="line"> [&quot;\n the&quot;] = &#123;&quot;more&quot;&#125;,  </span><br><span class="line"> [&quot;the more&quot;] = &#123;&quot;we&quot;, &quot;we&quot;&#125;,  </span><br><span class="line"> [&quot;we try&quot;]  = &#123;&quot;the&quot;&#125;, </span><br><span class="line"> [&quot;try the&quot;] = &#123;&quot;more&quot;&#125;,  </span><br><span class="line"> [&quot;we do&quot;] = &#123;&quot;\n&quot;&#125;,  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们使用全局变量 statetab 来保存这个表,下面我们完成一个插入函数用来在这个statetab中插入新的单词。</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">insert</span> <span class="params">(index, value)</span></span> </span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> statetab[index] <span class="keyword">then</span> </span><br><span class="line">    statetab[index] = &#123;value&#125; </span><br><span class="line">    <span class="keyword">else</span> </span><br><span class="line">    <span class="built_in">table</span>.<span class="built_in">insert</span>(statetab[index], value) </span><br><span class="line">    <span class="keyword">end</span> </span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>

<p>这个函数中首先检查指定的前缀是否存在,如果不存在则创建一个新的并赋上新值。如果已经存在则调用table.insert将新值插入到列表尾部。</p>
<p>我们使用两个变量w1和w2 来保存最后读入的两个单词的值,对于每一个前缀,我们保存紧跟其后的单词的列表。例如上面例子中初始化构造的表。</p>
<p>初始化表之后,下面来看看如何生成一个MAXGEN(&#x3D;1000)个单词的文本。首先,重新初始化 w1和 w2,然后对于每一个前缀,在其next 单词的列表中随机选择一个,打印此单词并更新w1和w2,完整的代码如下:</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- Markov Chain Program in Lua </span></span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">allwords</span> <span class="params">()</span></span> </span><br><span class="line"> <span class="keyword">local</span> line = <span class="built_in">io</span>.<span class="built_in">read</span>() <span class="comment">-- current line </span></span><br><span class="line"> <span class="keyword">local</span> pos = <span class="number">1</span> <span class="comment">-- current position in the line </span></span><br><span class="line"> <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> <span class="params">()</span></span> <span class="comment">-- iterator function </span></span><br><span class="line">  <span class="keyword">while</span> line <span class="keyword">do</span> <span class="comment">-- repeat while there are lines </span></span><br><span class="line">   <span class="keyword">local</span> s, e = <span class="built_in">string</span>.<span class="built_in">find</span>(line, <span class="string">&quot;%w+&quot;</span>, pos) </span><br><span class="line">   <span class="keyword">if</span> s <span class="keyword">then</span> <span class="comment">-- found a word? </span></span><br><span class="line">    pos = e + <span class="number">1</span> <span class="comment">-- update next position </span></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">string</span>.<span class="built_in">sub</span>(line, s, e) <span class="comment">-- return the word </span></span><br><span class="line">   <span class="keyword">else</span> </span><br><span class="line">    line = <span class="built_in">io</span>.<span class="built_in">read</span>() <span class="comment">-- word not found; try next line </span></span><br><span class="line">    pos = <span class="number">1</span> <span class="comment">-- restart from first position </span></span><br><span class="line">   <span class="keyword">end</span> </span><br><span class="line">  <span class="keyword">end</span> </span><br><span class="line">  <span class="keyword">return</span> <span class="literal">nil</span> <span class="comment">-- no more lines: end of traversal </span></span><br><span class="line"> <span class="keyword">end</span> </span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">prefix</span> <span class="params">(w1, w2)</span></span> </span><br><span class="line"> <span class="keyword">return</span> w1 .. <span class="string">&#x27; &#x27;</span> .. w2 </span><br><span class="line"><span class="keyword">end</span> </span><br><span class="line"> </span><br><span class="line"><span class="keyword">local</span> statetab </span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">insert</span> <span class="params">(index, value)</span></span> </span><br><span class="line"> <span class="keyword">if</span> <span class="keyword">not</span> statetab[index] <span class="keyword">then</span> </span><br><span class="line">  statetab[index] = &#123;n=<span class="number">0</span>&#125; </span><br><span class="line"> <span class="keyword">end</span> </span><br><span class="line"> <span class="built_in">table</span>.<span class="built_in">insert</span>(statetab[index], value) </span><br><span class="line"><span class="keyword">end</span> </span><br><span class="line"> </span><br><span class="line"><span class="keyword">local</span> N = <span class="number">2</span> </span><br><span class="line"><span class="keyword">local</span> MAXGEN = <span class="number">10000</span> </span><br><span class="line"><span class="keyword">local</span> NOWORD = <span class="string">&quot;\n&quot;</span> </span><br><span class="line"> <span class="comment">-- build table </span></span><br><span class="line">statetab = &#123;&#125; </span><br><span class="line"><span class="keyword">local</span> w1, w2 = NOWORD, NOWORD </span><br><span class="line"><span class="keyword">for</span> w <span class="keyword">in</span> allwords() <span class="keyword">do</span> </span><br><span class="line"> <span class="built_in">insert</span>(prefix(w1, w2), w) </span><br><span class="line"> w1 = w2; w2 = w; </span><br><span class="line"><span class="keyword">end</span> </span><br><span class="line"><span class="built_in">insert</span>(prefix(w1, w2), NOWORD) </span><br><span class="line"> <span class="comment">-- generate text </span></span><br><span class="line">w1 = NOWORD; w2 = NOWORD <span class="comment">-- reinitialize </span></span><br><span class="line"><span class="keyword">for</span> i=<span class="number">1</span>,MAXGEN <span class="keyword">do</span> </span><br><span class="line"> <span class="keyword">local</span> list = statetab[prefix(w1, w2)] </span><br><span class="line"> <span class="comment">-- choose a random item from list </span></span><br><span class="line"> <span class="keyword">local</span> r = <span class="built_in">math</span>.<span class="built_in">random</span>(<span class="built_in">table</span>.<span class="built_in">getn</span>(list)) </span><br><span class="line"> <span class="keyword">local</span> nextword = list[r] </span><br><span class="line"> <span class="keyword">if</span> nextword == NOWORD <span class="keyword">then</span> <span class="keyword">return</span> <span class="keyword">end</span> </span><br><span class="line"> <span class="built_in">io</span>.<span class="built_in">write</span>(nextword, <span class="string">&quot; &quot;</span>) </span><br><span class="line"> w1 = w2; w2 = nextword </span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>
        </div>

        
            <div class="post-copyright-info">
                <div class="article-copyright-info-container">
    <ul>
        <li>本文标题：《Lua编程》 第一篇：语言</li>
        <li>本文作者：形而上</li>
        <li>创建时间：2025-04-08 18:23:45</li>
        <li>
            本文链接：https://deepter.gitee.io/2025_04_08_lua/
        </li>
        <li>
            版权声明：本博客所有文章除特别声明外，均采用 <a class="license" target="_blank" rel="noopener" href="https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh">BY-NC-SA</a> 许可协议。转载请注明出处！
        </li>
    </ul>
</div>

            </div>
        

        
            <div class="article-nav">
                
                
                    <div class="article-next">
                        <a class="next"
                           rel="next"
                           href="/2025_03_01_the_long_river/"
                        >
                            <span class="title flex-center">
                                <span class="post-nav-title-item">一条长江，半部华夏文明史</span>
                                <span class="post-nav-item">下一篇</span>
                            </span>
                            <span class="right arrow-icon flex-center">
                              <i class="fas fa-chevron-right"></i>
                            </span>
                        </a>
                    </div>
                
            </div>
        

        
    </div>
</div>


                
            </div>

        </div>

        <div class="page-main-content-bottom">
            <footer class="footer">
    <div class="info-container">
        <div class="copyright-info info-item">
            &copy;
            
              <span>2017</span>&nbsp;-&nbsp;
            
            2025&nbsp;<i class="fas fa-heart icon-animate"></i>&nbsp;<a href="/">形而上</a>
        </div>
        
            <script async  src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
            <div class="website-count info-item">
                
                    <span id="busuanzi_container_site_uv">
                        访问人数&nbsp;<span id="busuanzi_value_site_uv"></span>&ensp;
                    </span>
                
                
                    <span id="busuanzi_container_site_pv">
                        总访问量&nbsp;<span id="busuanzi_value_site_pv"></span>
                    </span>
                
            </div>
        
        <div class="theme-info info-item">
            由 <a target="_blank" href="https://hexo.io">Hexo</a> 驱动&nbsp;|&nbsp;主题&nbsp;<a class="theme-version" target="_blank" href="https://github.com/XPoet/hexo-theme-keep">Keep v3.4.3</a>
        </div>
        
    </div>
</footer>

        </div>
    </div>

    
        <div class="post-tools">
            <div class="post-tools-container">
    <ul class="tools-list">
        <!-- TOC aside toggle -->
        
            <li class="tools-item page-aside-toggle">
                <i class="fas fa-outdent"></i>
            </li>
        

        <!-- go comment -->
        
    </ul>
</div>

        </div>
    

    <div class="right-bottom-side-tools">
        <div class="side-tools-container">
    <ul class="side-tools-list">
        <li class="tools-item tool-font-adjust-plus flex-center">
            <i class="fas fa-search-plus"></i>
        </li>

        <li class="tools-item tool-font-adjust-minus flex-center">
            <i class="fas fa-search-minus"></i>
        </li>

        <li class="tools-item tool-expand-width flex-center">
            <i class="fas fa-arrows-alt-h"></i>
        </li>

        <li class="tools-item tool-dark-light-toggle flex-center">
            <i class="fas fa-moon"></i>
        </li>

        <!-- rss -->
        

        

        <li class="tools-item tool-scroll-to-bottom flex-center">
            <i class="fas fa-arrow-down"></i>
        </li>
    </ul>

    <ul class="exposed-tools-list">
        <li class="tools-item tool-toggle-show flex-center">
            <i class="fas fa-cog fa-spin"></i>
        </li>
        
            <li class="tools-item tool-scroll-to-top flex-center">
                <i class="arrow-up fas fa-arrow-up"></i>
                <span class="percent"></span>
            </li>
        
    </ul>
</div>

    </div>

    
        <aside class="page-aside">
            <div class="post-toc-wrap">
    <div class="post-toc">
        <ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#%E8%AF%91%E5%BA%8F"><span class="nav-text">译序</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E7%9B%AE%E5%BD%95"><span class="nav-text">目录</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E7%AC%AC0%E7%AB%A0%E5%BA%8F%E8%A8%80"><span class="nav-text">第0章序言</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#0-1%E5%BA%8F%E8%A8%80"><span class="nav-text">0.1序言</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#0-2-Lua%E7%9A%84%E4%BD%BF%E7%94%A8%E8%80%85"><span class="nav-text">0.2 Lua的使用者</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#0-3-Lua%E7%9A%84%E7%9B%B8%E5%85%B3%E8%B5%84%E6%BA%90"><span class="nav-text">0.3 Lua的相关资源</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#0-4%E6%9C%AC%E4%B9%A6%E7%9A%84%E4%BD%93%E4%BE%8B"><span class="nav-text">0.4本书的体例</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#0-5%E5%85%B3%E4%BA%8E%E6%9C%AC%E4%B9%A6"><span class="nav-text">0.5关于本书</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#0-6%E6%84%9F%E8%B0%A2"><span class="nav-text">0.6感谢</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E7%AC%AC1%E7%AB%A0%E8%B5%B7%E7%82%B9"><span class="nav-text">第1章起点</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#1-1-Chunks"><span class="nav-text">1.1 Chunks</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#1-2%E5%85%A8%E5%B1%80%E5%8F%98%E9%87%8F"><span class="nav-text">1.2全局变量</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#1-3%E8%AF%8D%E6%B3%95%E7%BA%A6%E5%AE%9A"><span class="nav-text">1.3词法约定</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#1-4%E5%91%BD%E4%BB%A4%E8%A1%8C%E6%96%B9%E5%BC%8F"><span class="nav-text">1.4命令行方式</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E7%AC%AC2%E7%AB%A0-%E7%B1%BB%E5%9E%8B%E5%92%8C%E5%80%BC"><span class="nav-text">第2章 类型和值</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#2-1-Nil"><span class="nav-text">2.1 Nil</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2-2-Booleans"><span class="nav-text">2.2 Booleans</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2-3-Numbers"><span class="nav-text">2.3 Numbers</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2-4-Strings"><span class="nav-text">2.4 Strings</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2-5-Functions"><span class="nav-text">2.5 Functions</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2-6-Userdata-and-Threads"><span class="nav-text">2.6 Userdata and Threads</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E7%AC%AC3%E7%AB%A0%E8%A1%A8%E8%BE%BE%E5%BC%8F"><span class="nav-text">第3章表达式</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#3-1%E7%AE%97%E6%9C%AF%E8%BF%90%E7%AE%97%E7%AC%A6"><span class="nav-text">3.1算术运算符</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#3-2%E5%85%B3%E7%B3%BB%E8%BF%90%E7%AE%97%E7%AC%A6"><span class="nav-text">3.2关系运算符</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#3-3%E9%80%BB%E8%BE%91%E8%BF%90%E7%AE%97%E7%AC%A6"><span class="nav-text">3.3逻辑运算符</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#3-4%E8%BF%9E%E6%8E%A5%E8%BF%90%E7%AE%97%E7%AC%A6"><span class="nav-text">3.4连接运算符</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#3-5%E4%BC%98%E5%85%88%E7%BA%A7"><span class="nav-text">3.5优先级</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#3-6%E8%A1%A8%E7%9A%84%E6%9E%84%E9%80%A0"><span class="nav-text">3.6表的构造</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E7%AC%AC4%E7%AB%A0%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95"><span class="nav-text">第4章基本语法</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#4-1%E8%B5%8B%E5%80%BC%E8%AF%AD%E5%8F%A5"><span class="nav-text">4.1赋值语句</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#4-2%E5%B1%80%E9%83%A8%E5%8F%98%E9%87%8F%E4%B8%8E%E4%BB%A3%E7%A0%81%E5%9D%97-block"><span class="nav-text">4.2局部变量与代码块(block)</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#4-3%E6%8E%A7%E5%88%B6%E7%BB%93%E6%9E%84%E8%AF%AD%E5%8F%A5"><span class="nav-text">4.3控制结构语句</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#4-4-break%E5%92%8C-return-%E8%AF%AD%E5%8F%A5"><span class="nav-text">4.4 break和 return 语句</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E7%AC%AC5%E7%AB%A0%E5%87%BD%E6%95%B0"><span class="nav-text">第5章函数</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#5-1%E8%BF%94%E5%9B%9E%E5%A4%9A%E4%B8%AA%E7%BB%93%E6%9E%9C%E5%80%BC"><span class="nav-text">5.1返回多个结果值</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#5-2%E5%8F%AF%E5%8F%98%E5%8F%82%E6%95%B0"><span class="nav-text">5.2可变参数</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#5-3%E5%91%BD%E5%90%8D%E5%8F%82%E6%95%B0"><span class="nav-text">5.3命名参数</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E7%AC%AC6%E7%AB%A0-%E5%86%8D%E8%AE%BA%E5%87%BD%E6%95%B0"><span class="nav-text">第6章 再论函数</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#6-1%E9%97%AD%E5%8C%85"><span class="nav-text">6.1闭包</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#6-2%E9%9D%9E%E5%85%A8%E5%B1%80%E5%87%BD%E6%95%B0"><span class="nav-text">6.2非全局函数</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#6-3%E6%AD%A3%E7%A1%AE%E7%9A%84%E5%B0%BE%E8%B0%83%E7%94%A8-ProperTailCalls"><span class="nav-text">6.3正确的尾调用(ProperTailCalls)</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E7%AC%AC7%E7%AB%A0%E8%BF%AD%E4%BB%A3%E5%99%A8%E4%B8%8E%E6%B3%9B%E5%9E%8Bfor"><span class="nav-text">第7章迭代器与泛型for</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#7-1%E8%BF%AD%E4%BB%A3%E5%99%A8%E4%B8%8E%E9%97%AD%E5%8C%85"><span class="nav-text">7.1迭代器与闭包</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#7-2%E8%8C%83%E6%80%A7for%E7%9A%84%E8%AF%AD%E4%B9%89"><span class="nav-text">7.2范性for的语义</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#7-3%E6%97%A0%E7%8A%B6%E6%80%81%E7%9A%84%E8%BF%AD%E4%BB%A3%E5%99%A8"><span class="nav-text">7.3无状态的迭代器</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#7-4%E5%A4%9A%E7%8A%B6%E6%80%81%E7%9A%84%E8%BF%AD%E4%BB%A3%E5%99%A8"><span class="nav-text">7.4多状态的迭代器</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#7-5%E7%9C%9F%E6%AD%A3%E7%9A%84%E8%BF%AD%E4%BB%A3%E5%99%A8"><span class="nav-text">7.5真正的迭代器</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E7%AC%AC8%E7%AB%A0%E7%BC%96%E8%AF%91%C2%B7%E8%BF%90%E8%A1%8C%C2%B7%E8%B0%83%E8%AF%95"><span class="nav-text">第8章编译·运行·调试</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#8-1reguire%E5%87%BD%E6%95%B0"><span class="nav-text">8.1reguire函数</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#8-2-C-Packages"><span class="nav-text">8.2 C Packages</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#8-3%E9%94%99%E8%AF%AF"><span class="nav-text">8.3错误</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#8-4%E5%BC%82%E5%B8%B8%E5%92%8C%E9%94%99%E8%AF%AF%E5%A4%84%E7%90%86"><span class="nav-text">8.4异常和错误处理</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#8-5%E9%94%99%E8%AF%AF%E4%BF%A1%E6%81%AF%E5%92%8C%E5%9B%9E%E8%B7%9F%E8%B8%AA-Tracebacks"><span class="nav-text">8.5错误信息和回跟踪(Tracebacks)</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E7%AC%AC9%E7%AB%A0-%E5%8D%8F%E5%90%8C%E7%A8%8B%E5%BA%8F"><span class="nav-text">第9章 协同程序</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#9-1%E5%8D%8F%E5%90%8C%E7%9A%84%E5%9F%BA%E7%A1%80"><span class="nav-text">9.1协同的基础</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#9-2%E7%AE%A1%E9%81%93%E5%92%8C%E8%BF%87%E6%BB%A4%E5%99%A8"><span class="nav-text">9.2管道和过滤器</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#9-3%E7%94%A8%E4%BD%9C%E8%BF%AD%E4%BB%A3%E5%99%A8%E7%9A%84%E5%8D%8F%E5%90%8C"><span class="nav-text">9.3用作迭代器的协同</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#9-4%E9%9D%9E%E6%8A%A2%E5%8D%A0%E5%BC%8F%E5%A4%9A%E7%BA%BF%E7%A8%8B"><span class="nav-text">9.4非抢占式多线程</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E7%AC%AC10%E7%AB%A0%E5%AE%8C%E6%95%B4%E7%A4%BA%E4%BE%8B"><span class="nav-text">第10章完整示例</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#10-1Lua%E4%BD%9C%E4%B8%BA%E6%95%B0%E6%8D%AE%E6%8F%8F%E8%BF%B0%E8%AF%AD%E8%A8%80%E4%BD%BF%E7%94%A8"><span class="nav-text">10.1Lua作为数据描述语言使用</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#10-2%E9%A9%AC%E5%B0%94%E5%8F%AF%E5%A4%AB%E9%93%BE%E7%AE%97%E6%B3%95"><span class="nav-text">10.2马尔可夫链算法</span></a></li></ol></li></ol>
    </div>
</div>
        </aside>
    

    <div class="image-viewer-container">
    <img src="">
</div>


    
        <div class="search-pop-overlay">
    <div class="popup search-popup">
        <div class="search-header">
          <span class="search-input-field-pre">
            <i class="fas fa-keyboard"></i>
          </span>
            <div class="search-input-container">
                <input autocomplete="off"
                       autocorrect="off"
                       autocapitalize="off"
                       placeholder="搜索..."
                       spellcheck="false"
                       type="search"
                       class="search-input"
                >
            </div>
            <span class="popup-btn-close">
                <i class="fas fa-times"></i>
            </span>
        </div>
        <div id="search-result">
            <div id="no-result">
                <i class="fas fa-spinner fa-pulse fa-5x fa-fw"></i>
            </div>
        </div>
    </div>
</div>

    

</main>




<script src="/js/utils.js"></script>

<script src="/js/main.js"></script>

<script src="/js/header-shrink.js"></script>

<script src="/js/back2top.js"></script>

<script src="/js/dark-light-toggle.js"></script>



    
<script src="/js/local-search.js"></script>




    
<script src="/js/code-copy.js"></script>





<div class="post-scripts">
    
        
<script src="/js/left-side-toggle.js"></script>

<script src="/js/libs/anime.min.js"></script>

<script src="/js/toc.js"></script>

    
</div>



</body>
</html>
